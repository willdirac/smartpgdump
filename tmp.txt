postgres://postgres:AIYlIc76NyOSm1@localhost:5433/dirac
--
-- PostgreSQL database dump
--

\restrict ZayBcrqv3zzCm7TallgSbvuhWeAUijNb4WVj2dfO5AlTd2IIRnvbamYD5p0b90b

-- Dumped from database version 17.6 (Debian 17.6-2.pgdg12+1)
-- Dumped by pg_dump version 17.6 (Ubuntu 17.6-2.pgdg24.04+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: admin; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA admin;


ALTER SCHEMA admin OWNER TO postgres;

--
-- Name: api; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA api;


ALTER SCHEMA api OWNER TO postgres;

--
-- Name: auth; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA auth;


ALTER SCHEMA auth OWNER TO postgres;

--
-- Name: dirac; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA dirac;


ALTER SCHEMA dirac OWNER TO postgres;

--
-- Name: enrichment; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA enrichment;


ALTER SCHEMA enrichment OWNER TO postgres;

--
-- Name: google; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA google;


ALTER SCHEMA google OWNER TO postgres;

--
-- Name: linkedin; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA linkedin;


ALTER SCHEMA linkedin OWNER TO postgres;

--
-- Name: outbound; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA outbound;


ALTER SCHEMA outbound OWNER TO postgres;

--
-- Name: plpython3u; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS plpython3u WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpython3u; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpython3u IS 'PL/Python3U untrusted procedural language';


--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: pgtap; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgtap WITH SCHEMA public;


--
-- Name: EXTENSION pgtap; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgtap IS 'Unit testing for PostgreSQL';


--
-- Name: vector; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA public;


--
-- Name: EXTENSION vector; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION vector IS 'vector data type and ivfflat and hnsw access methods';


--
-- Name: product_detail_display; Type: TYPE; Schema: api; Owner: postgres
--

CREATE TYPE api.product_detail_display AS (
	id bigint,
	slug character varying(255),
	name character varying(255),
	barcode character(14),
	brand_id bigint,
	brand_name character varying(255),
	image_uuid uuid,
	image_type text,
	show_on_web boolean,
	web_unit_price numeric(19,4),
	web_unit_price_currency character(3),
	web_discount_id bigint,
	web_discount_unit character varying(20),
	web_product_case_id bigint,
	uk_vat_fraction numeric(5,4),
	pack_size integer,
	volume_ml numeric(19,4),
	weight_g numeric(19,4),
	shelf_life_days integer,
	is_gluten_free boolean,
	tariff_code character varying(10),
	tariff_code_country character(2),
	units_per_case integer,
	case_barcode character(14),
	cases_per_layer integer,
	layers_per_pallet integer,
	case_price numeric(19,4),
	currency character(3),
	unit_price numeric(19,4),
	moq_cases integer,
	country_of_origin character(2)
);


ALTER TYPE api.product_detail_display OWNER TO postgres;

--
-- Name: TYPE product_detail_display; Type: COMMENT; Schema: api; Owner: postgres
--

COMMENT ON TYPE api.product_detail_display IS 'Product detail type with uk_vat_fraction field added in migration 00033 to fix VAT dropdown display bug';


--
-- Name: product_listing; Type: TYPE; Schema: api; Owner: postgres
--

CREATE TYPE api.product_listing AS (
	id bigint,
	slug character varying(255),
	name character varying(255),
	brand_name character varying(255),
	barcode character(14),
	image_uuid uuid,
	image_type text,
	web_unit_price numeric(19,4),
	web_unit_price_currency character(3),
	web_discount_unit character varying(20),
	web_discount_id bigint,
	pack_size integer,
	volume_ml numeric(19,4),
	weight_g numeric(19,4),
	units_per_case integer,
	cases_per_layer integer,
	layers_per_pallet integer,
	uk_vat_fraction numeric(5,4)
);


ALTER TYPE api.product_listing OWNER TO postgres;

--
-- Name: discount_range; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.discount_range AS (
	qty_range int4range,
	discount_fraction numeric(4,4),
	discount_absolute numeric(19,4)
);


ALTER TYPE dirac.discount_range OWNER TO postgres;

--
-- Name: eu_goods_tier; Type: DOMAIN; Schema: dirac; Owner: postgres
--

CREATE DOMAIN dirac.eu_goods_tier AS integer
	CONSTRAINT eu_goods_tier_check CHECK ((VALUE = ANY (ARRAY[1, 2])));


ALTER DOMAIN dirac.eu_goods_tier OWNER TO postgres;

--
-- Name: image_type; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.image_type AS ENUM (
    'jpeg',
    'png',
    'webp',
    'gif'
);


ALTER TYPE dirac.image_type OWNER TO postgres;

--
-- Name: length_unit; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.length_unit AS ENUM (
    'mm',
    'cm',
    'm',
    'km',
    'in',
    'ft',
    'yd',
    'mi'
);


ALTER TYPE dirac.length_unit OWNER TO postgres;

--
-- Name: length; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.length AS (
	value numeric(19,4),
	unit dirac.length_unit
);


ALTER TYPE dirac.length OWNER TO postgres;

--
-- Name: order_status; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.order_status AS ENUM (
    'basket',
    'placed',
    'confirmed',
    'processing',
    'shipped',
    'delivered',
    'cancelled'
);


ALTER TYPE dirac.order_status OWNER TO postgres;

--
-- Name: pricing_job_status; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.pricing_job_status AS ENUM (
    'pending',
    'processing',
    'completed',
    'failed'
);


ALTER TYPE dirac.pricing_job_status OWNER TO postgres;

--
-- Name: volume_unit; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.volume_unit AS ENUM (
    'ml',
    'l',
    'fl_oz',
    'cup',
    'pt',
    'qt',
    'gal'
);


ALTER TYPE dirac.volume_unit OWNER TO postgres;

--
-- Name: volume; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.volume AS (
	value numeric(19,4),
	unit dirac.volume_unit
);


ALTER TYPE dirac.volume OWNER TO postgres;

--
-- Name: weight_unit; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.weight_unit AS ENUM (
    'mg',
    'g',
    'kg',
    'oz',
    'lb',
    't'
);


ALTER TYPE dirac.weight_unit OWNER TO postgres;

--
-- Name: weight; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.weight AS (
	value numeric(19,4),
	unit dirac.weight_unit
);


ALTER TYPE dirac.weight OWNER TO postgres;

--
-- Name: product_input; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.product_input AS (
	product_id bigint,
	name character varying(255),
	barcode character varying(14),
	image_id bigint,
	brand_id bigint,
	brand_name character varying(255),
	brand_embedding public.vector(768),
	product_embedding public.vector(768),
	pack_size integer,
	volume dirac.volume,
	shelf_life_days integer,
	is_gluten_free boolean,
	tariff_code character varying(10),
	tariff_code_country character(2),
	sku character varying(127),
	supplier_id bigint,
	discount_function_id bigint,
	brand_discount_function_id bigint,
	case_price_base numeric(19,4),
	case_price_currency character(3),
	country_of_origin character(2),
	eu_goods_tier dirac.eu_goods_tier,
	moq_cases integer,
	is_offer_active boolean,
	units_per_case integer,
	case_barcode character varying(14),
	cases_per_layer integer,
	layers_per_pallet integer,
	case_weight dirac.weight,
	case_height dirac.length,
	case_width dirac.length,
	case_length dirac.length,
	uk_vat_fraction numeric(5,4)
);


ALTER TYPE dirac.product_input OWNER TO postgres;

--
-- Name: product_quantity_unit; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.product_quantity_unit AS ENUM (
    'unit',
    'case',
    'pallet',
    'truckload',
    'layer'
);


ALTER TYPE dirac.product_quantity_unit OWNER TO postgres;

--
-- Name: product_quantity; Type: TYPE; Schema: dirac; Owner: postgres
--

CREATE TYPE dirac.product_quantity AS (
	quantity numeric(19,4),
	unit dirac.product_quantity_unit
);


ALTER TYPE dirac.product_quantity OWNER TO postgres;

--
-- Name: url; Type: DOMAIN; Schema: dirac; Owner: postgres
--

CREATE DOMAIN dirac.url AS text
	CONSTRAINT url_check CHECK (((length(VALUE) <= 2047) AND (length(VALUE) >= 10) AND (VALUE ~ '^https?://[^\s]+'::text) AND (VALUE !~ '\s'::text)));


ALTER DOMAIN dirac.url OWNER TO postgres;

--
-- Name: email; Type: DOMAIN; Schema: public; Owner: postgres
--

CREATE DOMAIN public.email AS text
	CONSTRAINT email_check CHECK ((VALUE ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'::text));


ALTER DOMAIN public.email OWNER TO postgres;

--
-- Name: add_customer_store(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.add_customer_store(p_customer_id bigint, p_location_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Validate customer exists
    IF NOT EXISTS (SELECT 1 FROM dirac.customer WHERE id = p_customer_id) THEN
        RAISE EXCEPTION 'Customer with ID % does not exist', p_customer_id
            USING ERRCODE = 'P0004';
    END IF;

    -- Validate location exists
    IF NOT EXISTS (SELECT 1 FROM dirac.location WHERE id = p_location_id) THEN
        RAISE EXCEPTION 'Location with ID % does not exist', p_location_id
            USING ERRCODE = 'P0004';
    END IF;

    -- Insert if not exists
    INSERT INTO dirac.customer_store (customer_id, location_id)
    VALUES (p_customer_id, p_location_id)
    ON CONFLICT (customer_id, location_id) DO NOTHING;
END;
$$;


ALTER FUNCTION admin.add_customer_store(p_customer_id bigint, p_location_id bigint) OWNER TO postgres;

--
-- Name: add_demand_request(bigint, dirac.product_quantity, bigint, character varying, public.vector, integer, bigint, character varying, public.vector, character varying, bigint, character varying, public.vector, text, character varying, numeric, character, dirac.eu_goods_tier, character); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.add_demand_request(p_admin_id bigint, p_quantity dirac.product_quantity, p_customer_id bigint DEFAULT NULL::bigint, p_customer_name character varying DEFAULT NULL::character varying, p_customer_embedding public.vector DEFAULT NULL::public.vector, p_customer_pipedrive_deal_id integer DEFAULT NULL::integer, p_product_id bigint DEFAULT NULL::bigint, p_product_name character varying DEFAULT NULL::character varying, p_product_embedding public.vector DEFAULT NULL::public.vector, p_product_barcode character varying DEFAULT NULL::character varying, p_brand_id bigint DEFAULT NULL::bigint, p_brand_name character varying DEFAULT NULL::character varying, p_brand_embedding public.vector DEFAULT NULL::public.vector, p_notes text DEFAULT NULL::text, p_source character varying DEFAULT 'admin'::character varying, p_target_unit_price numeric DEFAULT NULL::numeric, p_target_unit_price_currency character DEFAULT NULL::bpchar, p_eu_goods_tier dirac.eu_goods_tier DEFAULT NULL::integer, p_country_of_origin character DEFAULT NULL::bpchar) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_request_id BIGINT;
    v_customer_id BIGINT;
    v_brand_id BIGINT;
    v_product_id BIGINT;
BEGIN
    -- Validate admin exists and is active
    IF NOT EXISTS (
        SELECT 1 FROM auth.admin_user
        WHERE id = p_admin_id AND is_active = true
    ) THEN
        RAISE EXCEPTION 'Invalid or inactive admin'
            USING ERRCODE = 'P0002';
    END IF;

    -- Validate target price fields are both provided or both NULL
    IF (p_target_unit_price IS NULL) <> (p_target_unit_price_currency IS NULL) THEN
        RAISE EXCEPTION 'Target unit price and currency must both be provided or both be NULL'
            USING ERRCODE = 'P0004';
    END IF;

    -- Validate country if provided
    IF p_country_of_origin IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM dirac.country WHERE iso_3166_2 = p_country_of_origin) THEN
            RAISE EXCEPTION 'Country not found: %', p_country_of_origin
                USING ERRCODE = 'P0002';
        END IF;
    END IF;

    -- Resolve customer: prefer name over ID
    IF p_customer_name IS NOT NULL THEN
        IF p_customer_embedding IS NULL THEN
            RAISE EXCEPTION 'Must provide customer embedding when providing customer name'
                USING ERRCODE = 'P0004';
        END IF;
        v_customer_id := dirac.upsert_customer(p_customer_name,p_customer_pipedrive_deal_id, p_customer_embedding);
    ELSIF p_customer_id IS NOT NULL THEN
        v_customer_id := p_customer_id;
    ELSE
        RAISE EXCEPTION 'Must provide customer ID or name'
            USING ERRCODE = 'P0004';
    END IF;

    -- Validate customer exists
    IF NOT EXISTS (SELECT 1 FROM dirac.customer WHERE id = v_customer_id) THEN
        RAISE EXCEPTION 'Customer not found (ID: %)', v_customer_id
            USING ERRCODE = 'P0002';
    END IF;

    -- Determine if this is a product or brand request
    IF p_product_id IS NOT NULL OR p_product_name IS NOT NULL THEN
        -- Product request
        IF p_product_id IS NULL AND p_product_name IS NOT NULL THEN
            -- NEW product (no ID, but has name)
            IF p_brand_name IS NOT NULL THEN
                IF p_brand_embedding IS NULL THEN
                    RAISE EXCEPTION 'Must provide brand embedding when providing brand name'
                        USING ERRCODE = 'P0004';
                END IF;
                v_brand_id := dirac.upsert_brand(p_brand_name, p_brand_embedding);
            ELSE
                v_brand_id := p_brand_id;
            END IF;

            IF p_product_embedding IS NULL THEN
                RAISE EXCEPTION 'Must provide product embedding when providing product name'
                    USING ERRCODE = 'P0004';
            END IF;

            PERFORM dirac.bulk_upsert_products(
                ARRAY[
                    ROW(
                        p_product_name, p_product_barcode, NULL,
                        v_brand_id, p_brand_name, p_brand_embedding, p_product_embedding,
                        false, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                        NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                        NULL, NULL, NULL, NULL, NULL
                    )::dirac.product_input
                ]
            );

            SELECT id INTO v_product_id FROM dirac.product WHERE name = p_product_name;
        ELSIF p_product_id IS NOT NULL THEN
            v_product_id := p_product_id;
        END IF;

        v_brand_id := NULL;
    ELSIF p_brand_id IS NOT NULL OR p_brand_name IS NOT NULL THEN
        -- Brand request
        IF p_brand_name IS NOT NULL THEN
            IF p_brand_embedding IS NULL THEN
                RAISE EXCEPTION 'Must provide brand embedding when providing brand name'
                    USING ERRCODE = 'P0004';
            END IF;
            v_brand_id := dirac.upsert_brand(p_brand_name, p_brand_embedding);
        ELSE
            v_brand_id := p_brand_id;
        END IF;
        v_product_id := NULL;
    ELSE
        RAISE EXCEPTION 'Must specify either brand or product'
            USING ERRCODE = 'P0004';
    END IF;

    -- Insert or update demand request
    IF v_product_id IS NOT NULL THEN
        INSERT INTO dirac.demand_request (
            customer_id, brand_id, product_id, quantity, owner_admin_id, notes, source,
            target_unit_price, target_unit_price_currency, eu_goods_tier, country_of_origin
        ) VALUES (
            v_customer_id, v_brand_id, v_product_id, p_quantity, p_admin_id, p_notes, p_source,
            p_target_unit_price, p_target_unit_price_currency, p_eu_goods_tier, p_country_of_origin
        )
        ON CONFLICT (customer_id, product_id) DO UPDATE SET
            quantity = EXCLUDED.quantity, owner_admin_id = EXCLUDED.owner_admin_id,
            notes = EXCLUDED.notes, source = EXCLUDED.source,
            target_unit_price = EXCLUDED.target_unit_price,
            target_unit_price_currency = EXCLUDED.target_unit_price_currency,
            eu_goods_tier = EXCLUDED.eu_goods_tier, country_of_origin = EXCLUDED.country_of_origin,
            created_at = CURRENT_TIMESTAMP
        RETURNING id INTO v_request_id;
    ELSE
        INSERT INTO dirac.demand_request (
            customer_id, brand_id, product_id, quantity, owner_admin_id, notes, source,
            target_unit_price, target_unit_price_currency, eu_goods_tier, country_of_origin
        ) VALUES (
            v_customer_id, v_brand_id, v_product_id, p_quantity, p_admin_id, p_notes, p_source,
            p_target_unit_price, p_target_unit_price_currency, p_eu_goods_tier, p_country_of_origin
        )
        ON CONFLICT (brand_id, customer_id) DO UPDATE SET
            quantity = EXCLUDED.quantity, owner_admin_id = EXCLUDED.owner_admin_id,
            notes = EXCLUDED.notes, source = EXCLUDED.source,
            target_unit_price = EXCLUDED.target_unit_price,
            target_unit_price_currency = EXCLUDED.target_unit_price_currency,
            eu_goods_tier = EXCLUDED.eu_goods_tier, country_of_origin = EXCLUDED.country_of_origin,
            created_at = CURRENT_TIMESTAMP
        RETURNING id INTO v_request_id;
    END IF;

    RETURN v_request_id;
END;
$$;


ALTER FUNCTION admin.add_demand_request(p_admin_id bigint, p_quantity dirac.product_quantity, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_notes text, p_source character varying, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character) OWNER TO postgres;

--
-- Name: add_image(bytea, integer, integer, dirac.image_type); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.add_image(p_blob bytea, p_width_px integer, p_height_px integer, p_image_type dirac.image_type) RETURNS TABLE(image_id bigint, image_uuid uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_id BIGINT;
    v_uuid UUID;
BEGIN
    IF p_width_px <= 0 OR p_height_px <= 0 THEN
        RAISE EXCEPTION 'Image dimensions must be positive'
            USING ERRCODE = 'P0001';
    END IF;

    IF p_blob IS NULL OR length(p_blob) = 0 THEN
        RAISE EXCEPTION 'Image blob cannot be empty'
            USING ERRCODE = 'P0001';
    END IF;

    INSERT INTO dirac.image (blob, width_px, height_px, image_type)
    VALUES (p_blob, p_width_px, p_height_px, p_image_type)
    RETURNING id, uuid INTO v_id, v_uuid;

    RETURN QUERY SELECT v_id, v_uuid;
END;
$$;


ALTER FUNCTION admin.add_image(p_blob bytea, p_width_px integer, p_height_px integer, p_image_type dirac.image_type) OWNER TO postgres;

--
-- Name: add_location(character varying, character, character varying, text, character varying, character varying); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.add_location(p_name character varying, p_country character, p_region character varying DEFAULT NULL::character varying, p_address text DEFAULT NULL::text, p_postcode character varying DEFAULT NULL::character varying, p_google_place_id character varying DEFAULT NULL::character varying) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_location_id BIGINT;
BEGIN
    -- Validate name is not empty
    IF p_name IS NULL OR trim(p_name) = '' THEN
        RAISE EXCEPTION 'Location name cannot be empty'
            USING ERRCODE = 'P0004';
    END IF;

    -- Validate country exists
    IF NOT EXISTS (SELECT 1 FROM dirac.country WHERE iso_3166_2 = p_country) THEN
        RAISE EXCEPTION 'Invalid country code: %', p_country
            USING ERRCODE = 'P0004';
    END IF;

    -- Insert location
    INSERT INTO dirac.location (
        name,
        country,
        region,
        address,
        postcode,
        google_place_id
    ) VALUES (
        trim(p_name),
        p_country,
        NULLIF(trim(p_region), ''),
        NULLIF(trim(p_address), ''),
        NULLIF(trim(p_postcode), ''),
        NULLIF(trim(p_google_place_id), '')
    )
    RETURNING id INTO v_location_id;

    RETURN v_location_id;
END;
$$;


ALTER FUNCTION admin.add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying) OWNER TO postgres;

--
-- Name: add_manufacturer_store(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.add_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Validate manufacturer exists
    IF NOT EXISTS (SELECT 1 FROM dirac.manufacturer WHERE id = p_manufacturer_id) THEN
        RAISE EXCEPTION 'Manufacturer not found: %', p_manufacturer_id;
    END IF;

    -- Validate location exists
    IF NOT EXISTS (SELECT 1 FROM dirac.location WHERE id = p_location_id) THEN
        RAISE EXCEPTION 'Location not found: %', p_location_id;
    END IF;

    -- Check if association already exists
    IF EXISTS (
        SELECT 1 FROM dirac.manufacturer_store
        WHERE manufacturer_id = p_manufacturer_id AND location_id = p_location_id
    ) THEN
        RAISE EXCEPTION 'Manufacturer already linked to this location';
    END IF;

    -- Add the association
    INSERT INTO dirac.manufacturer_store (manufacturer_id, location_id)
    VALUES (p_manufacturer_id, p_location_id);
END;
$$;


ALTER FUNCTION admin.add_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) OWNER TO postgres;

--
-- Name: add_product_tariff_code(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.add_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM dirac.product WHERE id = p_product_id) THEN
        RAISE EXCEPTION 'Product not found (ID: %)', p_product_id
            USING ERRCODE = 'P0002';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM dirac.tariff_code WHERE id = p_tariff_code_id) THEN
        RAISE EXCEPTION 'Tariff code not found (ID: %)', p_tariff_code_id
            USING ERRCODE = 'P0002';
    END IF;

    INSERT INTO dirac.product_tariff_classification (tariff_code_id, product_id)
    VALUES (p_tariff_code_id, p_product_id)
    ON CONFLICT (tariff_code_id, product_id) DO NOTHING;
END;
$$;


ALTER FUNCTION admin.add_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) OWNER TO postgres;

--
-- Name: bulk_upsert_products_json(jsonb); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.bulk_upsert_products_json(products_json jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    products_array dirac.product_input[];
BEGIN
    -- Convert JSONB array to array of composite type
    SELECT ARRAY(
        SELECT ROW(
            (p->>'product_id')::BIGINT,
            (p->>'name')::VARCHAR(255),
            (p->>'barcode')::VARCHAR(14),
            (p->>'image_id')::BIGINT,
            (p->>'brand_id')::BIGINT,
            (p->>'brand_name')::VARCHAR(255),
            (p->>'brand_embedding')::vector(768),
            (p->>'product_embedding')::vector(768),
            -- Product detail fields
            (p->>'pack_size')::INT,
            ROW((p->'volume'->>'value')::DECIMAL(19,4), (p->'volume'->>'unit')::dirac.volume_unit)::dirac.volume,
            (p->>'shelf_life_days')::INT,
            (p->>'is_gluten_free')::BOOL,
            -- Tariff codes
            (p->>'tariff_code')::VARCHAR(10),
            (p->>'tariff_code_country')::CHAR(2),
            -- Product offer fields
            (p->>'sku')::VARCHAR(127),
            (p->>'supplier_id')::BIGINT,
            (p->>'discount_function_id')::BIGINT,
            (p->>'brand_discount_function_id')::BIGINT,
            (p->>'case_price_base')::DECIMAL(19,4),
            (p->>'case_price_currency')::CHAR(3),
            (p->>'country_of_origin')::CHAR(2),
            (p->>'eu_goods_tier')::dirac.eu_goods_tier,
            (p->>'moq_cases')::INT,
            (p->>'is_offer_active')::BOOL,
            -- Product case fields
            (p->>'units_per_case')::INT,
            (p->>'case_barcode')::VARCHAR(14),
            (p->>'cases_per_layer')::INT,
            (p->>'layers_per_pallet')::INT,
            ROW((p->'case_weight'->>'value')::DECIMAL(19,4), (p->'case_weight'->>'unit')::dirac.weight_unit)::dirac.weight,
            ROW((p->'case_height'->>'value')::DECIMAL(19,4), (p->'case_height'->>'unit')::dirac.length_unit)::dirac.length,
            ROW((p->'case_width'->>'value')::DECIMAL(19,4), (p->'case_width'->>'unit')::dirac.length_unit)::dirac.length,
            ROW((p->'case_length'->>'value')::DECIMAL(19,4), (p->'case_length'->>'unit')::dirac.length_unit)::dirac.length,
            (p->>'uk_vat_fraction')::DECIMAL(5,4)
        )::dirac.product_input
        FROM jsonb_array_elements(products_json) AS p
    ) INTO products_array;

    -- Call the original function with the converted array
    PERFORM dirac.bulk_upsert_products(products_array);
END;
$$;


ALTER FUNCTION admin.bulk_upsert_products_json(products_json jsonb) OWNER TO postgres;

--
-- Name: confirm_submission(bigint, bigint, bigint, character varying, public.vector, integer, character varying, character varying, character varying, character varying, character, text, bigint, character varying, public.vector, character varying, bigint, character varying, public.vector, dirac.product_quantity, text, numeric, character); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.confirm_submission(p_admin_id bigint, p_submission_id bigint, p_customer_id bigint DEFAULT NULL::bigint, p_customer_name character varying DEFAULT NULL::character varying, p_customer_embedding public.vector DEFAULT NULL::public.vector, p_customer_pipedrive_deal_id integer DEFAULT NULL::integer, p_email character varying DEFAULT NULL::character varying, p_business_registration_number character varying DEFAULT NULL::character varying, p_website_url character varying DEFAULT NULL::character varying, p_phone_number character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_customer_notes text DEFAULT NULL::text, p_product_id bigint DEFAULT NULL::bigint, p_product_name character varying DEFAULT NULL::character varying, p_product_embedding public.vector DEFAULT NULL::public.vector, p_product_barcode character varying DEFAULT NULL::character varying, p_brand_id bigint DEFAULT NULL::bigint, p_brand_name character varying DEFAULT NULL::character varying, p_brand_embedding public.vector DEFAULT NULL::public.vector, p_quantity dirac.product_quantity DEFAULT NULL::dirac.product_quantity, p_notes text DEFAULT NULL::text, p_target_unit_price numeric DEFAULT NULL::numeric, p_target_unit_price_currency character DEFAULT NULL::bpchar) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_submission RECORD;
	v_customer_id BIGINT;
	v_demand_request_id BIGINT;
	v_final_customer_name VARCHAR(255);
	v_final_quantity dirac.product_quantity;
	v_final_notes TEXT;
BEGIN
	-- Validate admin exists and is active
	IF NOT EXISTS (
		SELECT 1 FROM auth.admin_user
		WHERE id = p_admin_id AND is_active = true
	) THEN
		RAISE EXCEPTION 'Invalid or inactive admin'
			USING ERRCODE = 'P0002';
	END IF;

	-- Get submission
	SELECT * INTO v_submission
	FROM dirac.demand_request_submission
	WHERE id = p_submission_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Submission not found (ID: %)', p_submission_id
			USING ERRCODE = 'P0002';
	END IF;

	IF v_submission.status != 'pending' THEN
		RAISE EXCEPTION 'Submission already processed (status: %)', v_submission.status
			USING ERRCODE = 'P0004';
	END IF;

	-- Determine final values (use overrides if provided, otherwise use submission values)
	v_final_customer_name := COALESCE(p_customer_name, v_submission.customer_name);
	v_final_quantity := COALESCE(p_quantity, v_submission.quantity);
	v_final_notes := COALESCE(p_notes, v_submission.request_notes);

	-- Handle customer: create new or use existing
	IF p_customer_id IS NOT NULL THEN
		v_customer_id := p_customer_id;

		-- Update customer fields if overrides provided
		UPDATE dirac.customer
		SET
			email = COALESCE(p_email, email),
			business_registration_number = COALESCE(p_business_registration_number, business_registration_number),
			website_url = COALESCE(p_website_url, website_url),
			phone_number = COALESCE(p_phone_number, phone_number),
			country_code = COALESCE(p_country_code, country_code),
			customer_notes = COALESCE(p_customer_notes, customer_notes)
		WHERE id = v_customer_id;
	ELSE
		-- Create new customer with submission data
		IF p_customer_embedding IS NULL THEN
			RAISE EXCEPTION 'Must provide customer embedding when creating new customer'
				USING ERRCODE = 'P0004';
		END IF;

		-- First check if customer with this email already exists
		IF v_submission.email IS NOT NULL THEN
			SELECT id INTO v_customer_id
			FROM dirac.customer
			WHERE email = v_submission.email;
		END IF;

		-- If customer with email exists, use that one
		IF v_customer_id IS NOT NULL THEN
			-- Just use the existing customer, don't update anything
			NULL;
		ELSE
			-- Create new customer
			INSERT INTO dirac.customer (
				name,
				embedding,
				pipedrive_deal_id,
				email,
				business_registration_number,
				website_url,
				phone_number,
				country_code,
				customer_notes
			) VALUES (
				v_final_customer_name,
				p_customer_embedding,
				p_customer_pipedrive_deal_id,
				v_submission.email,
				COALESCE(p_business_registration_number, v_submission.business_registration_number),
				COALESCE(p_website_url, v_submission.website_url),
				COALESCE(p_phone_number, v_submission.phone_number),
				COALESCE(p_country_code, v_submission.country_code),
				COALESCE(p_customer_notes, v_submission.customer_notes)
			)
			ON CONFLICT (name) DO UPDATE
			SET
				embedding = EXCLUDED.embedding,
				pipedrive_deal_id = EXCLUDED.pipedrive_deal_id,
				email = COALESCE(EXCLUDED.email, dirac.customer.email),
				business_registration_number = COALESCE(EXCLUDED.business_registration_number, dirac.customer.business_registration_number),
				website_url = COALESCE(EXCLUDED.website_url, dirac.customer.website_url),
				phone_number = COALESCE(EXCLUDED.phone_number, dirac.customer.phone_number),
				country_code = COALESCE(EXCLUDED.country_code, dirac.customer.country_code),
				customer_notes = COALESCE(EXCLUDED.customer_notes, dirac.customer.customer_notes)
			RETURNING id INTO v_customer_id;
		END IF;
	END IF;

	-- Create demand request using existing add_demand_request function
	v_demand_request_id := admin.add_demand_request(
		p_admin_id := p_admin_id,
		p_customer_id := v_customer_id,
		p_quantity := v_final_quantity,
		p_product_id := p_product_id,
		p_product_name := p_product_name,
		p_product_embedding := p_product_embedding,
		p_product_barcode := p_product_barcode,
		p_brand_id := p_brand_id,
		p_brand_name := p_brand_name,
		p_brand_embedding := p_brand_embedding,
		p_notes := v_final_notes,
		p_source := 'public_form',
		p_target_unit_price := p_target_unit_price,
		p_target_unit_price_currency := p_target_unit_price_currency
	);

	-- Update submission status
	UPDATE dirac.demand_request_submission
	SET
		status = 'confirmed',
		processed_at = CURRENT_TIMESTAMP,
		processed_by_admin_id = p_admin_id,
		created_customer_id = v_customer_id,
		created_demand_request_id = v_demand_request_id
	WHERE id = p_submission_id;

	RETURN v_demand_request_id;
END;
$$;


ALTER FUNCTION admin.confirm_submission(p_admin_id bigint, p_submission_id bigint, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character) OWNER TO postgres;

--
-- Name: count_incomplete_margins(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.count_incomplete_margins() RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN (
        SELECT COUNT(*)
        FROM dirac.margin_estimate
        WHERE (p20 IS NULL OR p50 IS NULL OR p80 IS NULL)
          AND ignore = FALSE
    );
END;
$$;


ALTER FUNCTION admin.count_incomplete_margins() OWNER TO postgres;

--
-- Name: delete_margin_estimate(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.delete_margin_estimate(p_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    DELETE FROM dirac.margin_estimate
    WHERE id = p_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Margin estimate with id % not found', p_id USING ERRCODE = 'P0002';
    END IF;
END;
$$;


ALTER FUNCTION admin.delete_margin_estimate(p_id bigint) OWNER TO postgres;

--
-- Name: delete_product_case(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.delete_product_case(p_case_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    IF EXISTS (
        SELECT 1
        FROM dirac.product_offer
        WHERE product_case_id = p_case_id
        AND is_active = TRUE
    ) THEN
        RAISE EXCEPTION 'Cannot delete case: active product offers reference this case'
            USING ERRCODE = 'P0004',
                  HINT = 'Deactivate or delete the product offers first';
    END IF;

    DELETE FROM dirac.product_case
    WHERE id = p_case_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Case not found (ID: %)', p_case_id
            USING ERRCODE = 'P0002';
    END IF;
END;
$$;


ALTER FUNCTION admin.delete_product_case(p_case_id bigint) OWNER TO postgres;

--
-- Name: find_or_create_discount_function(dirac.discount_range[]); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.find_or_create_discount_function(p_discount_tiers dirac.discount_range[]) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_existing_id BIGINT;
    v_new_id BIGINT;
    v_auto_name TEXT;
BEGIN
    -- Validate the discount tiers
    IF NOT dirac.validate_discounts(p_discount_tiers) THEN
        RAISE EXCEPTION 'Invalid discount tiers: must cover [0,âˆž) with no overlaps'
            USING ERRCODE = 'P0004';
    END IF;

    -- Look for existing discount function with identical tiers
    SELECT id INTO v_existing_id
    FROM dirac.discount_function
    WHERE discounts = p_discount_tiers
    LIMIT 1;

    IF v_existing_id IS NOT NULL THEN
        RETURN v_existing_id;
    END IF;

    -- Create new discount function with auto-generated name
    v_auto_name := 'Auto: ' || array_length(p_discount_tiers, 1)::TEXT || ' tier';

    IF (p_discount_tiers[1]).discount_fraction IS NOT NULL THEN
        v_auto_name := v_auto_name || ' percentage discount';
    ELSE
        v_auto_name := v_auto_name || ' fixed discount';
    END IF;

    INSERT INTO dirac.discount_function (name, description, discounts)
    VALUES (
        v_auto_name,
        'Auto-generated discount function',
        p_discount_tiers
    )
    RETURNING id INTO v_new_id;

    RETURN v_new_id;
END;
$$;


ALTER FUNCTION admin.find_or_create_discount_function(p_discount_tiers dirac.discount_range[]) OWNER TO postgres;

--
-- Name: find_similar_products_batch(text[], public.vector[]); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.find_similar_products_batch(product_names text[], product_embeddings public.vector[]) RETURNS TABLE(input_index integer, candidate_product_id bigint, candidate_name text, candidate_barcode text, similarity_score double precision)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    i INT;
    product_name TEXT;
    product_embedding vector;
BEGIN
    -- Validate inputs
    IF product_names IS NULL OR product_embeddings IS NULL THEN
        RAISE EXCEPTION 'Product names and embeddings cannot be null';
    END IF;

    IF array_length(product_names, 1) != array_length(product_embeddings, 1) THEN
        RAISE EXCEPTION 'Product names and embeddings arrays must have the same length';
    END IF;

    -- For each input product, find similar products
    FOR i IN 1..array_length(product_names, 1) LOOP
        product_name := product_names[i];
        product_embedding := product_embeddings[i];

        -- Search for top 5 similar products with similarity >= 0.75
        RETURN QUERY
        SELECT
            i AS input_index,
            p.id AS candidate_product_id,
            p.name AS candidate_name,
            p.barcode AS candidate_barcode,
            (1 - (p.embedding <=> product_embedding)) AS similarity_score
        FROM dirac.product p
        WHERE p.embedding IS NOT NULL
        ORDER BY p.embedding <=> product_embedding
        LIMIT 5;
    END LOOP;
END;
$$;


ALTER FUNCTION admin.find_similar_products_batch(product_names text[], product_embeddings public.vector[]) OWNER TO postgres;

--
-- Name: get_active_admins(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_active_admins() RETURNS TABLE(id bigint, email character varying, is_active boolean)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
	SELECT id, email, is_active
	FROM auth.admin_user
	WHERE is_active = true
	ORDER BY email;
$$;


ALTER FUNCTION admin.get_active_admins() OWNER TO postgres;

--
-- Name: get_admin_from_session(uuid); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_admin_from_session(_session_id uuid) RETURNS TABLE(id bigint, email text, full_name text, created_at timestamp with time zone, last_login timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.id,
        u.email::TEXT,
        u.full_name,
        u.created_at,
        u.last_login
    FROM auth.admin_user u
    JOIN auth.admin_session s ON s.admin_user_id = u.id
    WHERE s.uuid = _session_id
    AND s.expires_at > NOW()
    AND u.is_active = true;
END;
$$;


ALTER FUNCTION admin.get_admin_from_session(_session_id uuid) OWNER TO postgres;

--
-- Name: get_customer_by_email(character varying); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_customer_by_email(p_email character varying) RETURNS TABLE(id bigint, name character varying, embedding public.vector, pipedrive_deal_id integer, email character varying, business_registration_number character varying, website_url character varying, phone_number character varying, country_code character, customer_notes text, created_at timestamp with time zone)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT
        id,
        name,
        embedding,
        pipedrive_deal_id,
        email,
        business_registration_number,
        website_url,
        phone_number,
        country_code,
        customer_notes,
        created_at
    FROM dirac.customer
    WHERE email = p_email;
$$;


ALTER FUNCTION admin.get_customer_by_email(p_email character varying) OWNER TO postgres;

--
-- Name: get_customer_by_id(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_customer_by_id(p_customer_id bigint) RETURNS TABLE(customer_id bigint, name character varying, email character varying, business_registration_number character varying, website_url character varying, phone_number character varying, country_code character, customer_notes text, pipedrive_deal_id integer, created_at timestamp with time zone, total_demand_requests bigint, product_requests bigint, brand_requests bigint, most_recent_request timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id AS customer_id,
        c.name,
        c.email,
        c.business_registration_number,
        c.website_url,
        c.phone_number,
        c.country_code,
        c.customer_notes,
        c.pipedrive_deal_id,
        c.created_at,
        COUNT(dr.id) AS total_demand_requests,
        COUNT(dr.id) FILTER (WHERE dr.product_id IS NOT NULL) AS product_requests,
        COUNT(dr.id) FILTER (WHERE dr.brand_id IS NOT NULL AND dr.product_id IS NULL) AS brand_requests,
        MAX(dr.created_at) AS most_recent_request
    FROM dirac.customer c
    LEFT JOIN dirac.demand_request dr ON dr.customer_id = c.id
    WHERE c.id = p_customer_id
    GROUP BY c.id, c.name, c.email, c.business_registration_number,
             c.website_url, c.phone_number, c.country_code, c.customer_notes,
             c.pipedrive_deal_id, c.created_at;
END;
$$;


ALTER FUNCTION admin.get_customer_by_id(p_customer_id bigint) OWNER TO postgres;

--
-- Name: get_customer_stores(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_customer_stores(p_customer_id bigint) RETURNS TABLE(location_id bigint, location_name character varying, address text, region character varying, postcode character varying, country_code character)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        l.id as location_id,
        l.name as location_name,
        l.address,
        l.region,
        l.postcode,
        l.country as country_code
    FROM dirac.customer_store cs
    JOIN dirac.location l ON l.id = cs.location_id
    WHERE cs.customer_id = p_customer_id
    ORDER BY l.name ASC;
END;
$$;


ALTER FUNCTION admin.get_customer_stores(p_customer_id bigint) OWNER TO postgres;

--
-- Name: get_customers_with_demand_stats(integer, integer, text); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_customers_with_demand_stats(p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_search text DEFAULT NULL::text) RETURNS TABLE(customer_id bigint, customer_name character varying, total_demand_requests bigint, product_requests bigint, brand_requests bigint, most_recent_request timestamp with time zone, pipedrive_deal_id integer)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id as customer_id,
        c.name as customer_name,
        COUNT(dr.id) as total_demand_requests,
        COUNT(dr.id) FILTER (WHERE dr.product_id IS NOT NULL) as product_requests,
        COUNT(dr.id) FILTER (WHERE dr.brand_id IS NOT NULL) as brand_requests,
        MAX(dr.created_at) as most_recent_request,
        c.pipedrive_deal_id
    FROM dirac.customer c
    LEFT JOIN dirac.demand_request dr ON dr.customer_id = c.id
    WHERE
        p_search IS NULL
        OR c.name ILIKE '%' || p_search || '%'
    GROUP BY c.id, c.name, c.pipedrive_deal_id
    HAVING COUNT(dr.id) > 0  -- Only show customers with at least one demand request
    ORDER BY most_recent_request DESC NULLS LAST, c.name
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;


ALTER FUNCTION admin.get_customers_with_demand_stats(p_limit integer, p_offset integer, p_search text) OWNER TO postgres;

--
-- Name: get_demand_request_by_id(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_demand_request_by_id(p_request_id bigint) RETURNS TABLE(request_id bigint, customer_id bigint, customer_name character varying, brand_id bigint, brand_name character varying, product_id bigint, product_name character varying, product_slug character varying, product_barcode character, quantity dirac.product_quantity, created_at timestamp with time zone, owner_admin_id bigint, admin_name text, notes text, source character varying, target_unit_price numeric, target_unit_price_currency character, eu_goods_tier dirac.eu_goods_tier, country_of_origin character)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        dr.id as request_id,
        dr.customer_id,
        c.name as customer_name,
        dr.brand_id,
        b.name as brand_name,
        dr.product_id,
        p.name as product_name,
        p.slug as product_slug,
        p.barcode as product_barcode,
        dr.quantity,
        dr.created_at,
        dr.owner_admin_id,
        au.full_name as admin_name,
        dr.notes,
        dr.source,
        dr.target_unit_price,
        dr.target_unit_price_currency,
        dr.eu_goods_tier,
        dr.country_of_origin
    FROM dirac.demand_request dr
    JOIN dirac.customer c ON c.id = dr.customer_id
    LEFT JOIN dirac.brand b ON b.id = dr.brand_id
    LEFT JOIN dirac.product p ON p.id = dr.product_id
    LEFT JOIN auth.admin_user au ON au.id = dr.owner_admin_id
    WHERE dr.id = p_request_id;
END;
$$;


ALTER FUNCTION admin.get_demand_request_by_id(p_request_id bigint) OWNER TO postgres;

--
-- Name: get_demand_requests(integer, integer, bigint, text); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_demand_requests(p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_customer_id bigint DEFAULT NULL::bigint, p_search text DEFAULT NULL::text) RETURNS TABLE(request_id bigint, customer_id bigint, customer_name character varying, brand_id bigint, brand_name character varying, product_id bigint, product_name character varying, product_slug character varying, product_barcode character, quantity dirac.product_quantity, created_at timestamp with time zone, owner_admin_id bigint, admin_name text, notes text, source character varying, target_unit_price numeric, target_unit_price_currency character, eu_goods_tier dirac.eu_goods_tier, country_of_origin character)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        dr.id as request_id,
        dr.customer_id,
        c.name as customer_name,
        dr.brand_id,
        b.name as brand_name,
        dr.product_id,
        p.name as product_name,
        p.slug as product_slug,
        p.barcode as product_barcode,
        dr.quantity,
        dr.created_at,
        dr.owner_admin_id,
        au.full_name as admin_name,
        dr.notes,
        dr.source,
        dr.target_unit_price,
        dr.target_unit_price_currency,
        dr.eu_goods_tier,
        dr.country_of_origin
    FROM dirac.demand_request dr
    JOIN dirac.customer c ON c.id = dr.customer_id
    LEFT JOIN dirac.brand b ON b.id = dr.brand_id
    LEFT JOIN dirac.product p ON p.id = dr.product_id
    LEFT JOIN auth.admin_user au ON au.id = dr.owner_admin_id
    WHERE
        (p_customer_id IS NULL OR dr.customer_id = p_customer_id)
        AND (
            p_search IS NULL
            OR c.name ILIKE '%' || p_search || '%'
            OR b.name ILIKE '%' || p_search || '%'
            OR p.name ILIKE '%' || p_search || '%'
            OR dr.notes ILIKE '%' || p_search || '%'
        )
    ORDER BY dr.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;


ALTER FUNCTION admin.get_demand_requests(p_limit integer, p_offset integer, p_customer_id bigint, p_search text) OWNER TO postgres;

--
-- Name: get_demand_stats(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_demand_stats() RETURNS TABLE(total_requests bigint, unique_customers bigint, top_requested_brands jsonb, top_requested_products jsonb, requests_by_source jsonb)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    WITH brand_stats AS (
        SELECT
            b.name,
            COUNT(*) as request_count,
            SUM((dr.quantity).quantity) as total_quantity
        FROM dirac.demand_request dr
        JOIN dirac.brand b ON b.id = dr.brand_id
        WHERE dr.brand_id IS NOT NULL
        GROUP BY b.name
        ORDER BY request_count DESC
        LIMIT 10
    ),
    product_stats AS (
        SELECT
            p.name,
            COUNT(*) as request_count,
            SUM((dr.quantity).quantity) as total_quantity
        FROM dirac.demand_request dr
        JOIN dirac.product p ON p.id = dr.product_id
        WHERE dr.product_id IS NOT NULL
        GROUP BY p.name
        ORDER BY request_count DESC
        LIMIT 10
    ),
    source_stats AS (
        SELECT
            source,
            COUNT(*) as count
        FROM dirac.demand_request
        GROUP BY source
    )
    SELECT
        (SELECT COUNT(*) FROM dirac.demand_request),
        (SELECT COUNT(DISTINCT customer_id) FROM dirac.demand_request),
        (SELECT jsonb_agg(row_to_json(brand_stats)) FROM brand_stats),
        (SELECT jsonb_agg(row_to_json(product_stats)) FROM product_stats),
        (SELECT jsonb_object_agg(source, count) FROM source_stats);
END;
$$;


ALTER FUNCTION admin.get_demand_stats() OWNER TO postgres;

--
-- Name: get_discount_function(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_discount_function(p_discount_function_id bigint) RETURNS TABLE(id bigint, name character varying, description text, discounts dirac.discount_range[])
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT df.id, df.name, df.description, df.discounts
    FROM dirac.discount_function df
    WHERE df.id = p_discount_function_id;
END;
$$;


ALTER FUNCTION admin.get_discount_function(p_discount_function_id bigint) OWNER TO postgres;

--
-- Name: get_locations(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_locations() RETURNS TABLE(location_id bigint, location_name character varying, full_address text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        l.id AS location_id,
        l.name AS location_name,
        CONCAT_WS(', ',
            l.address,
            l.region,
            l.postcode,
            c.name
        ) AS full_address
    FROM dirac.location l
    LEFT JOIN dirac.country c ON c.iso_3166_2 = l.country
    ORDER BY l.name ASC;
END;
$$;


ALTER FUNCTION admin.get_locations() OWNER TO postgres;

--
-- Name: get_manufacturer_by_id(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_manufacturer_by_id(p_manufacturer_id bigint) RETURNS TABLE(manufacturer_id bigint, name character varying, embedding public.vector, default_moq numeric, default_moq_currency character, credit_terms_days integer, created_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        m.id AS manufacturer_id,
        m.name,
        m.embedding,
        m.default_moq,
        m.default_moq_currency,
        m.credit_terms_days,
        m.created_at
    FROM dirac.manufacturer m
    WHERE m.id = p_manufacturer_id;
END;
$$;


ALTER FUNCTION admin.get_manufacturer_by_id(p_manufacturer_id bigint) OWNER TO postgres;

--
-- Name: get_manufacturer_stores(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_manufacturer_stores(p_manufacturer_id bigint) RETURNS TABLE(location_id bigint, location_name character varying, address text, region character varying, postcode character varying, country_code character)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        l.id AS location_id,
        l.name AS location_name,
        l.address,
        l.region,
        l.postcode,
        l.country
    FROM dirac.manufacturer_store ms
    JOIN dirac.location l ON l.id = ms.location_id
    WHERE ms.manufacturer_id = p_manufacturer_id
    ORDER BY l.name ASC;
END;
$$;


ALTER FUNCTION admin.get_manufacturer_stores(p_manufacturer_id bigint) OWNER TO postgres;

--
-- Name: get_manufacturers(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_manufacturers() RETURNS TABLE(id bigint, name character varying)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        m.id,
        m.name
    FROM dirac.manufacturer m
    ORDER BY m.name;
END;
$$;


ALTER FUNCTION admin.get_manufacturers() OWNER TO postgres;

--
-- Name: get_manufacturers_with_stats(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_manufacturers_with_stats() RETURNS TABLE(manufacturer_id bigint, manufacturer_name character varying, total_product_offers bigint, active_product_offers bigint, total_stores bigint, created_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        m.id AS manufacturer_id,
        m.name AS manufacturer_name,
        COUNT(DISTINCT po.id) AS total_product_offers,
        COUNT(DISTINCT po.id) FILTER (WHERE po.is_active = TRUE) AS active_product_offers,
        COUNT(DISTINCT ms.location_id) AS total_stores,
        m.created_at
    FROM dirac.manufacturer m
    LEFT JOIN dirac.product_offer po ON po.manufacturer_id = m.id
    LEFT JOIN dirac.manufacturer_store ms ON ms.manufacturer_id = m.id
    GROUP BY m.id, m.name, m.created_at
    ORDER BY m.name ASC;
END;
$$;


ALTER FUNCTION admin.get_manufacturers_with_stats() OWNER TO postgres;

--
-- Name: get_margin_estimates(character varying[], character varying[]); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_margin_estimates(p_company_names character varying[] DEFAULT NULL::character varying[], p_company_domains character varying[] DEFAULT NULL::character varying[]) RETURNS TABLE(id bigint, company_name character varying, company_domain character varying, p20 numeric, p50 numeric, p80 numeric, ignore boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        me.id,
        me.company_name,
        me.company_domain,
        me.p20,
        me.p50,
        me.p80,
        me.ignore,
        me.created_at,
        me.updated_at
    FROM dirac.margin_estimate me
    WHERE
        (p_company_names IS NULL OR me.company_name = ANY(p_company_names))
        OR (p_company_domains IS NOT NULL AND me.company_domain = ANY(p_company_domains))
    ORDER BY me.company_name;
END;
$$;


ALTER FUNCTION admin.get_margin_estimates(p_company_names character varying[], p_company_domains character varying[]) OWNER TO postgres;

--
-- Name: get_order_admin_details(uuid); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_order_admin_details(p_order_uuid uuid) RETURNS TABLE(order_id bigint, order_uuid uuid, status dirac.order_status, created_at timestamp with time zone, updated_at timestamp with time zone, placed_at timestamp with time zone, confirmed_at timestamp with time zone, shipped_at timestamp with time zone, delivered_at timestamp with time zone, cancelled_at timestamp with time zone, total_amount numeric, currency character, notes text, shipping_cost_amount numeric, shipping_cost_currency character, shipping_pallets integer, shipping_cost_calculated_at timestamp with time zone, customer_id bigint, customer_name character varying, customer_email character varying, customer_phone character varying, customer_vat_number character varying, shipping_address_id bigint, shipping_name character varying, shipping_address text, shipping_region character varying, shipping_postcode character varying, shipping_country character, billing_address_id bigint, billing_name character varying, billing_address text, billing_region character varying, billing_postcode character varying, billing_country character)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		-- Order info
		o.id,
		o.uuid,
		o.status,
		o.created_at,
		o.updated_at,
		o.placed_at,
		o.confirmed_at,
		o.shipped_at,
		o.delivered_at,
		o.cancelled_at,
		o.total_amount_incl_vat,
		o.currency,
		o.notes,
		-- Shipping cost info
		o.shipping_cost_amount,
		o.shipping_cost_currency,
		o.shipping_pallets,
		o.shipping_cost_calculated_at,
		-- Customer info
		c.id,
		c.name,
		u.email::VARCHAR(255),
		c.phone_number,
		c.vat_number,
		-- Shipping address
		sl.id,
		sl.name,
		sl.address,
		sl.region,
		sl.postcode,
		sl.country,
		-- Billing address
		bl.id,
		bl.name,
		bl.address,
		bl.region,
		bl.postcode,
		bl.country
	FROM dirac.order o
	INNER JOIN auth.user u ON u.id = o.user_id
	LEFT JOIN dirac.customer c ON c.id = u.customer_id
	LEFT JOIN dirac.location sl ON sl.id = o.shipping_address_id
	LEFT JOIN dirac.location bl ON bl.id = o.billing_address_id
	WHERE o.uuid = p_order_uuid;
END;
$$;


ALTER FUNCTION admin.get_order_admin_details(p_order_uuid uuid) OWNER TO postgres;

--
-- Name: get_order_items(uuid); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_order_items(p_order_uuid uuid) RETURNS TABLE(item_id bigint, product_id bigint, product_name character varying, product_slug character varying, product_barcode character, brand_name character varying, image_uuid uuid, image_type text, case_id bigint, case_barcode character, case_quantity numeric, units_per_case integer, case_price numeric, currency character, line_total numeric, uk_vat_fraction numeric, vat_amount numeric, line_total_with_vat numeric)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		oi.id,
		p.id,
		p.name,
		p.slug,
		p.barcode,
		b.name,
		img.uuid,
		img.image_type::TEXT,
		pc.id,
		pc.case_barcode,
		oi.case_quantity,
		pc.units_per_case,
		oi.case_price,
		oi.currency,
		totals.line_total,
		oi.uk_vat_fraction::DECIMAL(5,4),
		totals.vat_amount,
		totals.line_total_with_vat
	FROM dirac.order o
	INNER JOIN dirac.order_item oi ON oi.order_id = o.id
	INNER JOIN dirac.product_case pc ON pc.id = oi.product_case_id
	INNER JOIN dirac.product p ON p.id = pc.product_id
	LEFT JOIN dirac.brand b ON b.id = p.brand_id
	LEFT JOIN dirac.image img ON img.id = p.image_id
	CROSS JOIN LATERAL dirac.calculate_line_item_totals(
		oi.case_quantity,
		oi.case_price,
		oi.discount_applied,
		oi.uk_vat_fraction
	) AS totals
	WHERE o.uuid = p_order_uuid
	ORDER BY oi.created_at;
END;
$$;


ALTER FUNCTION admin.get_order_items(p_order_uuid uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_order_items(p_order_uuid uuid); Type: COMMENT; Schema: admin; Owner: postgres
--

COMMENT ON FUNCTION admin.get_order_items(p_order_uuid uuid) IS 'Returns order items with calculated totals. No permission checks - callers must validate access. Used by api.get_order_items (with user check) and admin directly.';


--
-- Name: get_order_items_admin(uuid); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_order_items_admin(p_order_uuid uuid) RETURNS TABLE(order_item_id bigint, product_id bigint, product_name text, product_slug text, product_barcode text, case_id bigint, case_barcode text, units_per_case integer, case_quantity numeric, case_price numeric, line_total numeric, currency character, brand_name text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		oi.id,
		p.id,
		p.name,
		p.slug,
		p.barcode,
		pc.id,
		pc.case_barcode,
		pc.units_per_case,
		oi.case_quantity,
		oi.case_price,
		(oi.case_quantity * oi.case_price - COALESCE(oi.discount_applied, 0))::DECIMAL(19,4),
		oi.currency,
		b.name
	FROM dirac.order o
	INNER JOIN dirac.order_item oi ON oi.order_id = o.id
	INNER JOIN dirac.product_case pc ON pc.id = oi.product_case_id
	INNER JOIN dirac.product p ON p.id = pc.product_id
	LEFT JOIN dirac.brand b ON b.id = p.brand_id
	WHERE o.uuid = p_order_uuid
	ORDER BY oi.id;
END;
$$;


ALTER FUNCTION admin.get_order_items_admin(p_order_uuid uuid) OWNER TO postgres;

--
-- Name: get_order_stats(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_order_stats() RETURNS TABLE(total_orders bigint, pending_orders bigint, processing_orders bigint, shipped_orders bigint, total_revenue numeric, orders_today bigint, currency character)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		COUNT(*) FILTER (WHERE status != 'basket'),
		COUNT(*) FILTER (WHERE status IN ('placed', 'confirmed')),
		COUNT(*) FILTER (WHERE status = 'processing'),
		COUNT(*) FILTER (WHERE status = 'shipped'),
		SUM(total_amount_incl_vat) FILTER (WHERE status NOT IN ('basket', 'cancelled')),
		COUNT(*) FILTER (WHERE created_at::DATE = CURRENT_DATE AND status != 'basket'),
		'GBP'::CHAR(3)  -- Default currency, could make this dynamic
	FROM dirac.order;
END;
$$;


ALTER FUNCTION admin.get_order_stats() OWNER TO postgres;

--
-- Name: get_pending_submissions(integer, integer, character varying); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_pending_submissions(p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_status character varying DEFAULT 'pending'::character varying) RETURNS TABLE(submission_id bigint, customer_name character varying, email character varying, business_registration_number character varying, website_url character varying, phone_number character varying, country_code character, customer_notes text, request_type character varying, item_name character varying, barcode character varying, brand_name character varying, quantity dirac.product_quantity, request_notes text, target_unit_price numeric, target_unit_price_currency character, status character varying, created_at timestamp with time zone, processed_at timestamp with time zone, processed_by_admin_id bigint, admin_name text, rejection_reason text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		s.id as submission_id,
		s.customer_name,
		s.email,
		s.business_registration_number,
		s.website_url,
		s.phone_number,
		s.country_code,
		s.customer_notes,
		s.request_type,
		s.item_name,
		s.barcode,
		s.brand_name,
		s.quantity,
		s.request_notes,
		s.target_unit_price,
		s.target_unit_price_currency,
		s.status,
		s.created_at,
		s.processed_at,
		s.processed_by_admin_id,
		au.full_name as admin_name,
		s.rejection_reason
	FROM dirac.demand_request_submission s
	LEFT JOIN auth.admin_user au ON au.id = s.processed_by_admin_id
	WHERE s.status = p_status OR p_status IS NULL
	ORDER BY s.created_at DESC
	LIMIT p_limit
	OFFSET p_offset;
END;
$$;


ALTER FUNCTION admin.get_pending_submissions(p_limit integer, p_offset integer, p_status character varying) OWNER TO postgres;

--
-- Name: get_pending_submissions_count(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_pending_submissions_count() RETURNS bigint
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN (SELECT COUNT(*) FROM dirac.demand_request_submission WHERE status = 'pending');
END;
$$;


ALTER FUNCTION admin.get_pending_submissions_count() OWNER TO postgres;

--
-- Name: get_pricing_constants(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_pricing_constants() RETURNS TABLE(min_margin numeric, margin_below_competitors numeric, competitive_price_metric character varying, competitive_price_percentile character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT pc.min_margin, pc.margin_below_competitors, pc.competitive_price_metric, pc.competitive_price_percentile
    FROM dirac.pricing_constants pc
    ORDER BY pc.id DESC
    LIMIT 1;
END;
$$;


ALTER FUNCTION admin.get_pricing_constants() OWNER TO postgres;

--
-- Name: get_pricing_job(character varying); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_pricing_job(p_job_id character varying) RETURNS TABLE(id character varying, admin_id bigint, status dirac.pricing_job_status, products_count integer, created_at timestamp with time zone, started_at timestamp with time zone, completed_at timestamp with time zone, error_message text, results jsonb)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		pj.id,
		pj.admin_id,
		pj.status,
		pj.products_count,
		pj.created_at,
		pj.started_at,
		pj.completed_at,
		pj.error_message,
		pj.results
	FROM dirac.pricing_job pj
	WHERE pj.id = p_job_id;
END;
$$;


ALTER FUNCTION admin.get_pricing_job(p_job_id character varying) OWNER TO postgres;

--
-- Name: get_product_basic_info(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_basic_info(p_product_id bigint) RETURNS TABLE(id bigint, name character varying, slug character varying)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.name,
        p.slug
    FROM dirac.product p
    WHERE p.id = p_product_id;
END;
$$;


ALTER FUNCTION admin.get_product_basic_info(p_product_id bigint) OWNER TO postgres;

--
-- Name: get_product_cases(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_cases(p_product_id bigint) RETURNS TABLE(case_id bigint, case_barcode character, units_per_case integer, cases_per_layer integer, layers_per_pallet integer, weight_kg numeric, height_cm numeric, width_cm numeric, length_cm numeric, offer_count integer, supplier_names text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        pc.id as case_id,
        pc.case_barcode,
        pc.units_per_case,
        pc.cases_per_layer,
        pc.layers_per_pallet,
        pc.weight_kg,
        pc.height_cm,
        pc.width_cm,
        pc.length_cm,
        COUNT(po.id)::INT as offer_count,
        STRING_AGG(s.name, ', ' ORDER BY s.name) as supplier_names
    FROM dirac.product_case pc
    LEFT JOIN dirac.product_offer po ON po.product_case_id = pc.id AND po.is_active = TRUE
    LEFT JOIN dirac.supplier s ON s.id = po.supplier_id
    WHERE pc.product_id = p_product_id
    GROUP BY pc.id
    ORDER BY pc.id DESC;
END;
$$;


ALTER FUNCTION admin.get_product_cases(p_product_id bigint) OWNER TO postgres;

--
-- Name: get_product_detail(character varying); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_detail(product_slug character varying) RETURNS api.product_detail_display
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    result api.product_detail_display;
BEGIN
    WITH best_offer AS (
        SELECT
            pc.units_per_case,
            po.case_price_base,
            po.case_price_currency,
            pc.case_barcode,
            pc.cases_per_layer * pc.layers_per_pallet AS cases_per_pallet,
            po.moq_cases,
            po.country_of_origin,
            CASE
                WHEN pc.units_per_case > 0 THEN (po.case_price_base / pc.units_per_case)::DECIMAL(19,4)
                ELSE NULL
            END AS unit_price
        FROM dirac.product_offer po
        JOIN dirac.product p ON p.id = po.product_id
        JOIN dirac.product_case pc ON pc.id = po.product_case_id
        WHERE p.slug = product_slug
          AND po.is_active = TRUE
        ORDER BY po.case_price_base ASC
        LIMIT 1
    )
    SELECT
        p.id,
        p.slug,
        p.name,
        CASE WHEN p.barcode IS NOT NULL THEN dirac.to_gtin_14(p.barcode) ELSE NULL END as barcode,
        p.brand_id,
        b.name AS brand_name,
        img.uuid AS image_uuid,
        img.image_type::TEXT AS image_type,
        p.show_on_web,
        -- Web pricing fields
        p.web_unit_price,
        p.web_unit_price_currency,
        p.web_discount AS web_discount_id,
        p.web_discount_unit::VARCHAR(20),
        p.web_product_case_id,
        -- VAT field (ADDED)
        p.uk_vat_fraction,
        -- Product details
        pd.pack_size,
        pd.volume_ml,
        pd.weight_g,
        pd.shelf_life_days,
        pd.is_gluten_free,
        -- Tariff code (pick first one)
        tc.code AS tariff_code,
        tc.country AS tariff_code_country,
        -- Case information from web_product_case_id
        pc.units_per_case,
        pc.case_barcode,
        pc.cases_per_layer,
        pc.layers_per_pallet,
        -- Offer details from best offer
        bo.case_price_base AS case_price,
        bo.case_price_currency AS currency,
        bo.unit_price,
        bo.moq_cases,
        bo.country_of_origin
    INTO result
    FROM dirac.product p
    LEFT JOIN dirac.brand b ON p.brand_id = b.id
    LEFT JOIN dirac.image img ON img.id = p.image_id
    LEFT JOIN dirac.product_detail pd ON pd.product_id = p.id
    LEFT JOIN dirac.product_case pc ON pc.id = p.web_product_case_id
    LEFT JOIN dirac.product_tariff_classification ptc ON ptc.product_id = p.id
    LEFT JOIN dirac.tariff_code tc ON tc.id = ptc.tariff_code_id
    LEFT JOIN best_offer bo ON TRUE
    WHERE p.slug = product_slug
    LIMIT 1;

    RETURN result;
END;
$$;


ALTER FUNCTION admin.get_product_detail(product_slug character varying) OWNER TO postgres;

--
-- Name: FUNCTION get_product_detail(product_slug character varying); Type: COMMENT; Schema: admin; Owner: postgres
--

COMMENT ON FUNCTION admin.get_product_detail(product_slug character varying) IS 'Returns product detail including uk_vat_fraction for admin product edit page';


--
-- Name: get_product_id_by_slug(character varying); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_id_by_slug(p_slug character varying) RETURNS bigint
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    v_product_id BIGINT;
BEGIN
    SELECT id INTO v_product_id
    FROM dirac.product
    WHERE slug = p_slug;

    RETURN v_product_id;
END;
$$;


ALTER FUNCTION admin.get_product_id_by_slug(p_slug character varying) OWNER TO postgres;

--
-- Name: get_product_listing(integer, integer, character varying, character varying, character varying, public.vector); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_listing(limit_val integer DEFAULT 100, offset_val integer DEFAULT 0, brand_name_filter character varying DEFAULT NULL::character varying, search_term character varying DEFAULT NULL::character varying, order_by character varying DEFAULT 'name'::character varying, search_embedding public.vector DEFAULT NULL::public.vector) RETURNS SETOF api.product_listing
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    -- If search_embedding is provided, use vector similarity search
    IF search_embedding IS NOT NULL THEN
        RETURN QUERY
        SELECT
            p.id,
            p.slug,
            p.name,
            b.name AS brand_name,
            p.barcode,
            img.uuid AS image_uuid,
            img.image_type::TEXT AS image_type,
            p.web_unit_price,
            p.web_unit_price_currency,
            p.web_discount_unit::VARCHAR(20),
            p.web_discount AS web_discount_id,
            pd.pack_size,
            pd.volume_ml,
            pd.weight_g,
            pc.units_per_case,
            pc.cases_per_layer,
            pc.layers_per_pallet,
            p.uk_vat_fraction
        FROM dirac.product p
        LEFT JOIN dirac.brand b ON p.brand_id = b.id
        LEFT JOIN dirac.image img ON img.id = p.image_id
        LEFT JOIN dirac.product_detail pd ON pd.product_id = p.id
        LEFT JOIN dirac.product_case pc ON pc.id = p.web_product_case_id
        WHERE
            (brand_name_filter IS NULL OR b.name = brand_name_filter)
        ORDER BY p.embedding <=> search_embedding  -- Cosine distance (ascending = most similar first)
        LIMIT limit_val
        OFFSET offset_val;
    ELSE
        -- Fallback to text search
        RETURN QUERY
        SELECT
            p.id,
            p.slug,
            p.name,
            b.name AS brand_name,
            p.barcode,
            img.uuid AS image_uuid,
            img.image_type::TEXT AS image_type,
            p.web_unit_price,
            p.web_unit_price_currency,
            p.web_discount_unit::VARCHAR(20),
            p.web_discount AS web_discount_id,
            pd.pack_size,
            pd.volume_ml,
            pd.weight_g,
            pc.units_per_case,
            pc.cases_per_layer,
            pc.layers_per_pallet,
            p.uk_vat_fraction
        FROM dirac.product p
        LEFT JOIN dirac.brand b ON p.brand_id = b.id
        LEFT JOIN dirac.image img ON img.id = p.image_id
        LEFT JOIN dirac.product_detail pd ON pd.product_id = p.id
        LEFT JOIN dirac.product_case pc ON pc.id = p.web_product_case_id
        WHERE
            (brand_name_filter IS NULL OR b.name = brand_name_filter)
            AND (search_term IS NULL OR
                 p.name ILIKE '%' || search_term || '%' OR
                 b.name ILIKE '%' || search_term || '%')
        ORDER BY
            CASE
                WHEN order_by = 'name' THEN p.name
                WHEN order_by = 'brand_name' THEN b.name || ' ' || p.name
                WHEN order_by = 'created_at' THEN p.created_at::TEXT
                ELSE p.name  -- default fallback
            END
        LIMIT limit_val
        OFFSET offset_val;
    END IF;
END;
$$;


ALTER FUNCTION admin.get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector) OWNER TO postgres;

--
-- Name: get_product_offer(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_offer(p_offer_id bigint) RETURNS TABLE(offer_id bigint, supplier_id bigint, supplier_name character varying, product_id bigint, product_name character varying, product_barcode character, sku character varying, product_case_id bigint, units_per_case integer, case_price_base numeric, case_price_currency character, case_barcode character, cases_per_layer integer, layers_per_pallet integer, moq_cases integer, country_of_origin character, eu_goods_tier dirac.eu_goods_tier, is_active boolean, added_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        po.id as offer_id,
        po.supplier_id,
        s.name as supplier_name,
        po.product_id,
        p.name as product_name,
        p.barcode as product_barcode,
        po.sku,
        po.product_case_id,
        pc.units_per_case,
        po.case_price_base,
        po.case_price_currency,
        pc.case_barcode,
        pc.cases_per_layer,
        pc.layers_per_pallet,
        po.moq_cases,
        po.country_of_origin,
        po.eu_goods_tier,
        po.is_active,
        po.added_at,
        po.updated_at
    FROM dirac.product_offer po
    JOIN dirac.supplier s ON s.id = po.supplier_id
    JOIN dirac.product p ON p.id = po.product_id
    JOIN dirac.product_case pc ON pc.id = po.product_case_id
    WHERE po.id = p_offer_id;
END;
$$;


ALTER FUNCTION admin.get_product_offer(p_offer_id bigint) OWNER TO postgres;

--
-- Name: get_product_offers_by_manufacturer(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_offers_by_manufacturer(p_manufacturer_id bigint) RETURNS TABLE(offer_id bigint, product_id bigint, product_name character varying, product_slug character varying, product_barcode character, sku character varying, case_size integer, case_price_base numeric, case_price_currency character, case_barcode character, moq_cases integer, cases_per_pallet integer, country_of_origin character, eu_goods_tier dirac.eu_goods_tier, is_active boolean, added_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        po.id as offer_id,
        po.product_id,
        p.name as product_name,
        p.slug as product_slug,
        p.barcode as product_barcode,
        po.sku,
        po.case_size,
        po.case_price_base,
        po.case_price_currency,
        po.case_barcode,
        po.moq_cases,
        po.cases_per_pallet,
        po.country_of_origin,
        po.eu_goods_tier,
        po.is_active,
        po.added_at,
        po.updated_at
    FROM dirac.product_offer po
    JOIN dirac.product p ON p.id = po.product_id
    WHERE po.manufacturer_id = p_manufacturer_id
    ORDER BY po.is_active DESC, po.added_at DESC;
END;
$$;


ALTER FUNCTION admin.get_product_offers_by_manufacturer(p_manufacturer_id bigint) OWNER TO postgres;

--
-- Name: get_product_offers_by_product(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_offers_by_product(p_product_id bigint) RETURNS TABLE(offer_id bigint, supplier_id bigint, supplier_name character varying, sku character varying, units_per_case integer, case_price_base numeric, case_price_currency character, case_barcode character, moq_cases integer, cases_per_layer integer, country_of_origin character, eu_goods_tier dirac.eu_goods_tier, is_active boolean, added_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        po.id as offer_id,
        po.supplier_id,
        s.name as supplier_name,
        po.sku,
        pc.units_per_case,
        po.case_price_base,
        po.case_price_currency,
        pc.case_barcode,
        po.moq_cases,
        pc.cases_per_layer,
        po.country_of_origin,
        po.eu_goods_tier,
        po.is_active,
        po.added_at,
        po.updated_at
    FROM dirac.product_offer po
    JOIN dirac.product_case pc ON pc.id = po.product_case_id
    JOIN dirac.supplier s ON s.id = po.supplier_id
    WHERE po.product_id = p_product_id
    ORDER BY po.is_active DESC, po.added_at DESC;
END;
$$;


ALTER FUNCTION admin.get_product_offers_by_product(p_product_id bigint) OWNER TO postgres;

--
-- Name: get_product_offers_by_supplier(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_offers_by_supplier(p_supplier_id bigint) RETURNS TABLE(offer_id bigint, product_id bigint, product_name character varying, product_slug character varying, product_barcode character, sku character varying, units_per_case integer, case_price_base numeric, case_price_currency character, case_barcode character, moq_cases integer, cases_per_layer integer, country_of_origin character, eu_goods_tier dirac.eu_goods_tier, is_active boolean, added_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        po.id as offer_id,
        po.product_id,
        p.name as product_name,
        p.slug as product_slug,
        p.barcode as product_barcode,
        po.sku,
        pc.units_per_case,
        po.case_price_base,
        po.case_price_currency,
        pc.case_barcode,
        po.moq_cases,
        pc.cases_per_layer,
        po.country_of_origin,
        po.eu_goods_tier,
        po.is_active,
        po.added_at,
        po.updated_at
    FROM dirac.product_offer po
    JOIN dirac.product_case pc ON pc.id = po.product_case_id
    JOIN dirac.product p ON p.id = po.product_id
    WHERE po.supplier_id = p_supplier_id
    ORDER BY po.is_active DESC, po.added_at DESC;
END;
$$;


ALTER FUNCTION admin.get_product_offers_by_supplier(p_supplier_id bigint) OWNER TO postgres;

--
-- Name: get_product_offers_for_demand_request(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_offers_for_demand_request(p_demand_request_id bigint) RETURNS TABLE(offer_id bigint, manufacturer_id bigint, manufacturer_name character varying, sku character varying, case_size integer, case_price_base numeric, case_price_currency character, unit_price numeric, case_barcode character, moq_cases integer, cases_per_pallet integer, country_of_origin character, eu_goods_tier dirac.eu_goods_tier, is_active boolean, added_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    v_product_id BIGINT;
    v_demand_country CHAR(2);
    v_demand_tier dirac.eu_goods_tier;
BEGIN
    -- Get demand request details
    SELECT dr.product_id, dr.country_of_origin, dr.eu_goods_tier
    INTO v_product_id, v_demand_country, v_demand_tier
    FROM dirac.demand_request dr
    WHERE dr.id = p_demand_request_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Demand request not found (ID: %)', p_demand_request_id
            USING ERRCODE = 'P0002';
    END IF;

    -- For brand requests (product_id is NULL), return empty result
    IF v_product_id IS NULL THEN
        RETURN;
    END IF;

    -- Return all active offers for the product that match the constraints
    RETURN QUERY
    SELECT
        po.id as offer_id,
        po.supplier_id as manufacturer_id,
        s.name as manufacturer_name,
        po.sku,
        pc.units_per_case as case_size,
        po.case_price_base,
        po.case_price_currency,
        CASE WHEN pc.units_per_case > 0 THEN po.case_price_base / pc.units_per_case ELSE NULL END as unit_price,
        pc.case_barcode,
        po.moq_cases,
        (pc.cases_per_layer * pc.layers_per_pallet) as cases_per_pallet,
        po.country_of_origin,
        po.eu_goods_tier,
        po.is_active,
        po.added_at,
        po.updated_at
    FROM dirac.product_offer po
    JOIN dirac.supplier s ON s.id = po.supplier_id
    JOIN dirac.product_case pc ON pc.id = po.product_case_id
    WHERE po.product_id = v_product_id
      AND po.is_active = TRUE
      -- Country must match if demand request specifies it, or offer's country must be NULL (unspecified)
      AND (v_demand_country IS NULL OR po.country_of_origin IS NULL OR po.country_of_origin = v_demand_country)
      -- EU goods tier must match if demand request specifies it, or offer's tier must be NULL (unspecified)
      AND (v_demand_tier IS NULL OR po.eu_goods_tier IS NULL OR po.eu_goods_tier = v_demand_tier)
    ORDER BY po.case_price_base ASC, po.added_at DESC;
END;
$$;


ALTER FUNCTION admin.get_product_offers_for_demand_request(p_demand_request_id bigint) OWNER TO postgres;

--
-- Name: get_product_slug_by_id(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_slug_by_id(p_product_id bigint) RETURNS character varying
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    v_slug VARCHAR(255);
BEGIN
    SELECT slug INTO v_slug
    FROM dirac.product
    WHERE id = p_product_id;

    RETURN v_slug;
END;
$$;


ALTER FUNCTION admin.get_product_slug_by_id(p_product_id bigint) OWNER TO postgres;

--
-- Name: get_product_tariff_codes(bigint, character, character varying, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_product_tariff_codes(product_id bigint, country_filter character DEFAULT NULL::bpchar, customs_territory_filter character varying DEFAULT NULL::character varying, depth_filter integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, code character varying, country character, customs_territory_code character varying, depth integer, description text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        tc.id,
        tc.code,
        tc.country,
        tc.customs_territory_code,
        tc.depth,
        tc.description
    FROM dirac.product_tariff_classification ptc
    JOIN dirac.tariff_code tc ON ptc.tariff_code_id = tc.id
    WHERE
        ptc.product_id = get_product_tariff_codes.product_id
        AND (country_filter IS NULL OR tc.country = country_filter)
        AND (customs_territory_filter IS NULL OR tc.customs_territory_code = customs_territory_filter)
        AND (depth_filter IS NULL OR tc.depth = depth_filter)
    ORDER BY tc.code, tc.country NULLS LAST;
END;
$$;


ALTER FUNCTION admin.get_product_tariff_codes(product_id bigint, country_filter character, customs_territory_filter character varying, depth_filter integer) OWNER TO postgres;

--
-- Name: get_products_with_discounts(text, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_products_with_discounts(p_search text DEFAULT NULL::text, p_limit integer DEFAULT 20) RETURNS TABLE(product_slug character varying, product_name character varying, brand_name character varying, web_unit_price numeric, web_unit_price_currency character, discount_function_id bigint, discount_tiers dirac.discount_range[])
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.slug,
        p.name,
        b.name AS brand_name,
        p.web_unit_price,
        p.web_unit_price_currency,
        df.id AS discount_function_id,
        df.discounts AS discount_tiers
    FROM dirac.product p
    LEFT JOIN dirac.brand b ON b.id = p.brand_id
    INNER JOIN dirac.discount_function df ON df.id = p.web_discount
    WHERE
        p.web_discount IS NOT NULL
        AND (
            p_search IS NULL
            OR p.name ILIKE '%' || p_search || '%'
            OR b.name ILIKE '%' || p_search || '%'
        )
    ORDER BY p.name
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION admin.get_products_with_discounts(p_search text, p_limit integer) OWNER TO postgres;

--
-- Name: get_supplier_by_id(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_supplier_by_id(p_supplier_id bigint) RETURNS TABLE(supplier_id bigint, name character varying, embedding public.vector, default_moq numeric, default_moq_currency character, credit_terms_days integer, created_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        m.id AS supplier_id,
        m.name,
        m.embedding,
        m.default_moq,
        m.default_moq_currency,
        m.credit_terms_days,
        m.created_at
    FROM dirac.supplier m
    WHERE m.id = p_supplier_id;
END;
$$;


ALTER FUNCTION admin.get_supplier_by_id(p_supplier_id bigint) OWNER TO postgres;

--
-- Name: get_supplier_stores(bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_supplier_stores(p_supplier_id bigint) RETURNS TABLE(location_id bigint, location_name character varying, address text, region character varying, postcode character varying, country_code character)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        l.id AS location_id,
        l.name AS location_name,
        l.address,
        l.region,
        l.postcode,
        l.country
    FROM dirac.supplier_store ms
    JOIN dirac.location l ON l.id = ms.location_id
    WHERE ms.supplier_id = p_supplier_id
    ORDER BY l.name ASC;
END;
$$;


ALTER FUNCTION admin.get_supplier_stores(p_supplier_id bigint) OWNER TO postgres;

--
-- Name: get_suppliers(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_suppliers() RETURNS TABLE(id bigint, name character varying)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        m.id,
        m.name
    FROM dirac.supplier m
    ORDER BY m.name;
END;
$$;


ALTER FUNCTION admin.get_suppliers() OWNER TO postgres;

--
-- Name: get_suppliers_with_stats(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.get_suppliers_with_stats() RETURNS TABLE(supplier_id bigint, supplier_name character varying, total_product_offers bigint, active_product_offers bigint, total_stores bigint, created_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.id AS supplier_id,
        s.name AS supplier_name,
        COUNT(DISTINCT po.id) AS total_product_offers,
        COUNT(DISTINCT po.id) FILTER (WHERE po.is_active = TRUE) AS active_product_offers,
        COUNT(DISTINCT ss.location_id) AS total_stores,
        s.created_at
    FROM dirac.supplier s
    LEFT JOIN dirac.product_offer po ON po.supplier_id = s.id
    LEFT JOIN dirac.supplier_store ss ON ss.supplier_id = s.id
    GROUP BY s.id, s.name, s.created_at
    ORDER BY s.name ASC;
END;
$$;


ALTER FUNCTION admin.get_suppliers_with_stats() OWNER TO postgres;

--
-- Name: is_session_valid(uuid, inet, text); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.is_session_valid(_session_id uuid, _ip inet, _user_agent text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_valid BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM auth.admin_session s
        JOIN auth.admin_user u ON u.id = s.admin_user_id
        WHERE s.uuid = _session_id
        AND s.ip = _ip
        AND s.user_agent = _user_agent
        AND s.expires_at > NOW()
        AND u.is_active = true
    ) INTO v_valid;

    -- Extend session if valid
    IF v_valid THEN
        UPDATE auth.admin_session
        SET expires_at = NOW() + INTERVAL '2 hours'
        WHERE uuid = _session_id;
    END IF;

    RETURN v_valid;
END;
$$;


ALTER FUNCTION admin.is_session_valid(_session_id uuid, _ip inet, _user_agent text) OWNER TO postgres;

--
-- Name: list_all_orders(dirac.order_status, text, timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.list_all_orders(p_status dirac.order_status DEFAULT NULL::dirac.order_status, p_customer_search text DEFAULT NULL::text, p_date_from timestamp with time zone DEFAULT NULL::timestamp with time zone, p_date_to timestamp with time zone DEFAULT NULL::timestamp with time zone, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0) RETURNS TABLE(order_id bigint, order_uuid uuid, customer_id bigint, customer_name character varying, customer_email character varying, status dirac.order_status, created_at timestamp with time zone, placed_at timestamp with time zone, confirmed_at timestamp with time zone, shipped_at timestamp with time zone, delivered_at timestamp with time zone, cancelled_at timestamp with time zone, total_amount_incl_vat numeric, currency character, item_count bigint, shipping_address text, notes text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		o.id,
		o.uuid,
		c.id,
		c.name,
		u.email::VARCHAR(255),
		o.status,
		o.created_at,
		o.placed_at,
		o.confirmed_at,
		o.shipped_at,
		o.delivered_at,
		o.cancelled_at,
		o.total_amount_incl_vat,
		o.currency,
		COUNT(oi.id),
		CASE
			WHEN l.id IS NOT NULL THEN
				CONCAT_WS(', ',
					l.name,
					l.address,
					l.region,
					l.postcode,
					l.country
				)
			ELSE NULL
		END,
		o.notes
	FROM dirac.order o
	INNER JOIN auth.user u ON u.id = o.user_id
	LEFT JOIN dirac.customer c ON c.id = u.customer_id
	LEFT JOIN dirac.order_item oi ON oi.order_id = o.id
	LEFT JOIN dirac.location l ON l.id = o.shipping_address_id
	WHERE o.status != 'basket'  -- Don't show baskets in admin
		AND (p_status IS NULL OR o.status = p_status)
		AND (p_customer_search IS NULL OR
			c.name ILIKE '%' || p_customer_search || '%' OR
			u.email ILIKE '%' || p_customer_search || '%')
		AND (p_date_from IS NULL OR o.created_at >= p_date_from)
		AND (p_date_to IS NULL OR o.created_at <= p_date_to)
	GROUP BY o.id, o.uuid, c.id, c.name, u.email, o.status, o.created_at,
		o.placed_at, o.confirmed_at, o.shipped_at, o.delivered_at,
		o.cancelled_at, o.total_amount_incl_vat, o.currency, l.id, o.notes
	ORDER BY o.created_at DESC
	LIMIT p_limit
	OFFSET p_offset;
END;
$$;


ALTER FUNCTION admin.list_all_orders(p_status dirac.order_status, p_customer_search text, p_date_from timestamp with time zone, p_date_to timestamp with time zone, p_limit integer, p_offset integer) OWNER TO postgres;

--
-- Name: list_margin_estimates(integer, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.list_margin_estimates(p_limit integer DEFAULT 50, p_offset integer DEFAULT 0) RETURNS TABLE(id bigint, company_name character varying, company_domain character varying, p20 numeric, p50 numeric, p80 numeric, ignore boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        me.id,
        me.company_name,
        me.company_domain,
        me.p20,
        me.p50,
        me.p80,
        me.ignore,
        me.created_at,
        me.updated_at
    FROM dirac.margin_estimate me
    ORDER BY me.company_name
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;


ALTER FUNCTION admin.list_margin_estimates(p_limit integer, p_offset integer) OWNER TO postgres;

--
-- Name: list_pricing_jobs(bigint, dirac.pricing_job_status, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.list_pricing_jobs(p_admin_id bigint DEFAULT NULL::bigint, p_status dirac.pricing_job_status DEFAULT NULL::dirac.pricing_job_status, p_limit integer DEFAULT 50) RETURNS TABLE(id character varying, admin_id bigint, status dirac.pricing_job_status, products_count integer, created_at timestamp with time zone, completed_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		pj.id,
		pj.admin_id,
		pj.status,
		pj.products_count,
		pj.created_at,
		pj.completed_at
	FROM dirac.pricing_job pj
	WHERE (p_admin_id IS NULL OR pj.admin_id = p_admin_id)
	  AND (p_status IS NULL OR pj.status = p_status)
	ORDER BY pj.created_at DESC
	LIMIT p_limit;
END;
$$;


ALTER FUNCTION admin.list_pricing_jobs(p_admin_id bigint, p_status dirac.pricing_job_status, p_limit integer) OWNER TO postgres;

--
-- Name: login(text, character varying, inet, text); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.login(_email text, _google_id character varying, _ip inet, _user_agent text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_google_id VARCHAR(255);
    v_is_active BOOLEAN;
    v_session_uuid UUID;
BEGIN
    -- if google id & email then both must match, otherwise just email must match
    SELECT id,is_active,google_id
    INTO v_admin_id, v_is_active,v_google_id
    FROM auth.admin_user
    WHERE email = _email
    AND (google_id IS NULL OR google_id=_google_id);

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid admin credentials'
            USING ERRCODE = 'P0001'; -- RaiseError: business logic error
    END IF;

    -- Check if account is active
    IF NOT v_is_active THEN
        RAISE EXCEPTION 'Admin account is disabled'
            USING ERRCODE = 'P0001'; -- RaiseError: business logic error
    END IF;

    -- Add the google id if it is null
    IF v_google_id IS NULL THEN
        UPDATE auth.admin_user
        SET google_id=_google_id
        WHERE id=v_admin_id;
        RAISE NOTICE 'Added google id  % for user with email %',_google_id,_email;
    END IF;

    -- Create session
    v_session_uuid := gen_random_uuid();

    INSERT INTO auth.admin_session (uuid, admin_user_id, ip, user_agent, expires_at)
    VALUES (v_session_uuid, v_admin_id, _ip, _user_agent, NOW() + INTERVAL '2 hours');

    -- Update last login
    UPDATE auth.admin_user SET last_login = NOW() WHERE id = v_admin_id;

    RETURN v_session_uuid;
END;
$$;


ALTER FUNCTION admin.login(_email text, _google_id character varying, _ip inet, _user_agent text) OWNER TO postgres;

--
-- Name: reject_submission(bigint, bigint, text); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.reject_submission(p_admin_id bigint, p_submission_id bigint, p_rejection_reason text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
	-- Validate admin
	IF NOT EXISTS (
		SELECT 1 FROM auth.admin_user
		WHERE id = p_admin_id AND is_active = true
	) THEN
		RAISE EXCEPTION 'Invalid or inactive admin'
			USING ERRCODE = 'P0002';
	END IF;

	-- Check submission exists and is pending
	IF NOT EXISTS (
		SELECT 1 FROM dirac.demand_request_submission
		WHERE id = p_submission_id AND status = 'pending'
	) THEN
		RAISE EXCEPTION 'Submission not found or already processed (ID: %)', p_submission_id
			USING ERRCODE = 'P0002';
	END IF;

	-- Update submission status
	UPDATE dirac.demand_request_submission
	SET
		status = 'rejected',
		processed_at = CURRENT_TIMESTAMP,
		processed_by_admin_id = p_admin_id,
		rejection_reason = p_rejection_reason
	WHERE id = p_submission_id;
END;
$$;


ALTER FUNCTION admin.reject_submission(p_admin_id bigint, p_submission_id bigint, p_rejection_reason text) OWNER TO postgres;

--
-- Name: remove_customer_store(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.remove_customer_store(p_customer_id bigint, p_location_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    DELETE FROM dirac.customer_store
    WHERE customer_id = p_customer_id AND location_id = p_location_id;
END;
$$;


ALTER FUNCTION admin.remove_customer_store(p_customer_id bigint, p_location_id bigint) OWNER TO postgres;

--
-- Name: remove_demand_request(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.remove_demand_request(p_admin_id bigint, p_request_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Validate admin
    IF NOT EXISTS (
        SELECT 1 FROM auth.admin_user
        WHERE id = p_admin_id AND is_active = true
    ) THEN
        RAISE EXCEPTION 'Invalid or inactive admin'
            USING ERRCODE = 'P0002'; -- NoDataFoundError: admin not found
    END IF;

    -- Check if request exists
    IF NOT EXISTS (SELECT 1 FROM dirac.demand_request WHERE id = p_request_id) THEN
        RAISE EXCEPTION 'Demand request not found'
            USING ERRCODE = 'P0002'; -- NoDataFoundError: request not found
    END IF;

    -- Delete the request
    DELETE FROM dirac.demand_request WHERE id = p_request_id;
END;
$$;


ALTER FUNCTION admin.remove_demand_request(p_admin_id bigint, p_request_id bigint) OWNER TO postgres;

--
-- Name: remove_manufacturer_store(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.remove_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    DELETE FROM dirac.manufacturer_store
    WHERE manufacturer_id = p_manufacturer_id
      AND location_id = p_location_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Manufacturer store association not found';
    END IF;
END;
$$;


ALTER FUNCTION admin.remove_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) OWNER TO postgres;

--
-- Name: remove_product_tariff_code(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.remove_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    DELETE FROM dirac.product_tariff_classification
    WHERE product_id = p_product_id
      AND tariff_code_id = p_tariff_code_id;
END;
$$;


ALTER FUNCTION admin.remove_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) OWNER TO postgres;

--
-- Name: search_brands(public.vector, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.search_brands(p_embedding public.vector, p_limit integer DEFAULT 10) RETURNS TABLE(id bigint, name character varying, owner_manufacturer_id bigint, similarity double precision)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        b.id,
        b.name,
        b.owner_manufacturer_id,
        1 - (b.embedding <=> p_embedding) as similarity  -- Cosine similarity (1 - cosine distance)
    FROM dirac.brand b
    ORDER BY b.embedding <=> p_embedding  -- Order by cosine distance (ascending)
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION admin.search_brands(p_embedding public.vector, p_limit integer) OWNER TO postgres;

--
-- Name: search_customers(public.vector, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.search_customers(p_embedding public.vector, p_limit integer DEFAULT 10) RETURNS TABLE(id bigint, name character varying, pipedrive_deal_id integer, similarity double precision)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id,
        c.name,
        c.pipedrive_deal_id,
        1 - (c.embedding <=> p_embedding) as similarity  -- Cosine similarity (1 - cosine distance)
    FROM dirac.customer c
    ORDER BY c.embedding <=> p_embedding  -- Order by cosine distance (ascending)
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION admin.search_customers(p_embedding public.vector, p_limit integer) OWNER TO postgres;

--
-- Name: search_manufacturers(public.vector, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.search_manufacturers(p_embedding public.vector, p_limit integer DEFAULT 10) RETURNS TABLE(id bigint, name character varying, similarity double precision)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        m.id,
        m.name,
        1 - (m.embedding <=> p_embedding) as similarity
    FROM dirac.manufacturer m
    WHERE m.embedding IS NOT NULL
    ORDER BY m.embedding <=> p_embedding
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION admin.search_manufacturers(p_embedding public.vector, p_limit integer) OWNER TO postgres;

--
-- Name: search_products(public.vector, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.search_products(p_embedding public.vector, p_limit integer DEFAULT 10) RETURNS TABLE(id bigint, name character varying, brand_id bigint, brand_name character varying, similarity double precision)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.name,
        p.brand_id,
        b.name as brand_name,
        1 - (p.embedding <=> p_embedding) as similarity  -- Cosine similarity (1 - cosine distance)
    FROM dirac.product p
    LEFT JOIN dirac.brand b ON p.brand_id = b.id
    ORDER BY p.embedding <=> p_embedding  -- Order by cosine distance (ascending)
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION admin.search_products(p_embedding public.vector, p_limit integer) OWNER TO postgres;

--
-- Name: set_brand_owner(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.set_brand_owner(p_brand_id bigint, p_manufacturer_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Validate brand exists
    IF NOT EXISTS (SELECT 1 FROM dirac.brand WHERE id = p_brand_id) THEN
        RAISE EXCEPTION 'Brand not found (ID: %)', p_brand_id
            USING ERRCODE = 'P0002';
    END IF;

    -- Validate manufacturer exists
    IF NOT EXISTS (SELECT 1 FROM dirac.manufacturer WHERE id = p_manufacturer_id) THEN
        RAISE EXCEPTION 'Manufacturer not found (ID: %)', p_manufacturer_id
            USING ERRCODE = 'P0002';
    END IF;

    -- Update brand owner
    UPDATE dirac.brand
    SET owner_manufacturer_id = p_manufacturer_id
    WHERE id = p_brand_id;
END;
$$;


ALTER FUNCTION admin.set_brand_owner(p_brand_id bigint, p_manufacturer_id bigint) OWNER TO postgres;

--
-- Name: test_search_customers(); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.test_search_customers() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_embedding1 vector(768);
    v_embedding2 vector(768);
    v_embedding3 vector(768);
    v_search_embedding vector(768);
    v_customer_id1 BIGINT;
    v_customer_id2 BIGINT;
    v_customer_id3 BIGINT;
    v_result_count INT;
    v_first_result_id BIGINT;
    v_first_similarity FLOAT;
BEGIN
    -- Create test embeddings with different similarity levels
    -- embedding1 will be most similar to search_embedding
    v_embedding1 := array_fill(0.9::float4, ARRAY[768])::vector(768);
    v_embedding2 := array_fill(0.5::float4, ARRAY[768])::vector(768);
    v_embedding3 := array_fill(0.1::float4, ARRAY[768])::vector(768);
    v_search_embedding := array_fill(0.85::float4, ARRAY[768])::vector(768);

    -- Create test customers with different embeddings
    v_customer_id1 := dirac.upsert_customer('Similar Customer', v_embedding1);
    v_customer_id2 := dirac.upsert_customer('Medium Customer', v_embedding2);
    v_customer_id3 := dirac.upsert_customer('Different Customer', v_embedding3);

    -- Test 1: Search returns results ordered by similarity
    SELECT COUNT(*) INTO v_result_count
    FROM admin.search_customers(v_search_embedding, 10);

    RETURN NEXT ok(v_result_count >= 3, 'Should return at least the 3 test customers');

    -- Test 2: Most similar customer is returned first
    SELECT id, similarity INTO v_first_result_id, v_first_similarity
    FROM admin.search_customers(v_search_embedding, 1)
    LIMIT 1;

    RETURN NEXT is(v_first_result_id, v_customer_id1, 'Most similar customer should be returned first');

    -- Test 3: Similarity score is between 0 and 1
    RETURN NEXT ok(v_first_similarity >= 0 AND v_first_similarity <= 1,
                   'Similarity score should be between 0 and 1');

    -- Test 4: Limit parameter works correctly
    SELECT COUNT(*) INTO v_result_count
    FROM admin.search_customers(v_search_embedding, 2);

    RETURN NEXT is(v_result_count, 2, 'Should respect limit parameter');

    -- Test 5: Returns expected columns
    RETURN NEXT results_eq(
        'SELECT COUNT(*) FROM (
            SELECT id, name, pipedrive_deal_id, similarity
            FROM admin.search_customers(' || quote_literal(v_search_embedding::text) || '::vector(768), 1)
        ) t',
        'SELECT 1::BIGINT',
        'Should return all expected columns'
    );

    -- Test 6: Search with different embedding returns different order
    v_search_embedding := array_fill(0.15::float4, ARRAY[768])::vector(768);

    SELECT id INTO v_first_result_id
    FROM admin.search_customers(v_search_embedding, 1)
    LIMIT 1;

    RETURN NEXT is(v_first_result_id, v_customer_id3,
                   'Different search embedding should return different customer first');
END;
$$;


ALTER FUNCTION admin.test_search_customers() OWNER TO postgres;

--
-- Name: update_customer(bigint, character varying, character varying, character varying, character varying, character, text, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_customer(p_customer_id bigint, p_email character varying DEFAULT NULL::character varying, p_business_registration_number character varying DEFAULT NULL::character varying, p_website_url character varying DEFAULT NULL::character varying, p_phone_number character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_customer_notes text DEFAULT NULL::text, p_pipedrive_deal_id integer DEFAULT NULL::integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
BEGIN
    -- Validate customer exists
    IF NOT EXISTS (SELECT 1 FROM dirac.customer WHERE id = p_customer_id) THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0002',
            MESSAGE = 'Customer not found';
    END IF;

    -- Validate email format if provided
    IF p_email IS NOT NULL AND p_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0004',
            MESSAGE = 'Invalid email format';
    END IF;

    -- Validate country code if provided
    IF p_country_code IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM dirac.country WHERE code = p_country_code
    ) THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0004',
            MESSAGE = 'Invalid country code';
    END IF;

    -- Validate URL format if provided
    IF p_website_url IS NOT NULL AND p_website_url !~ '^https?://' THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0004',
            MESSAGE = 'Website URL must start with http:// or https://';
    END IF;

    -- Update customer
    UPDATE dirac.customer
    SET
        email = p_email,
        business_registration_number = p_business_registration_number,
        website_url = p_website_url,
        phone_number = p_phone_number,
        country_code = p_country_code,
        customer_notes = p_customer_notes,
        pipedrive_deal_id = p_pipedrive_deal_id
    WHERE id = p_customer_id;
END;
$_$;


ALTER FUNCTION admin.update_customer(p_customer_id bigint, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer) OWNER TO postgres;

--
-- Name: update_customer(bigint, character varying, public.vector, character varying, character varying, character varying, character varying, character, text, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_customer(p_customer_id bigint, p_name character varying DEFAULT NULL::character varying, p_embedding public.vector DEFAULT NULL::public.vector, p_email character varying DEFAULT NULL::character varying, p_business_registration_number character varying DEFAULT NULL::character varying, p_website_url character varying DEFAULT NULL::character varying, p_phone_number character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_customer_notes text DEFAULT NULL::text, p_pipedrive_deal_id integer DEFAULT NULL::integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    v_current_name VARCHAR(255);
BEGIN
    -- Validate customer exists and get current name
    SELECT name INTO v_current_name
    FROM dirac.customer
    WHERE id = p_customer_id;

    IF v_current_name IS NULL THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0002',
            MESSAGE = 'Customer not found';
    END IF;

    -- Validate name if being changed
    IF p_name IS NOT NULL THEN
        -- Trim and validate name
        p_name := trim(p_name);

        IF p_name = '' THEN
            RAISE EXCEPTION USING
                ERRCODE = 'P0004',
                MESSAGE = 'Customer name cannot be empty';
        END IF;

        -- If name is changing, require embedding
        IF p_name != v_current_name THEN
            IF p_embedding IS NULL THEN
                RAISE EXCEPTION USING
                    ERRCODE = 'P0004',
                    MESSAGE = 'Embedding is required when changing customer name';
            END IF;

            -- Check if new name already exists
            IF EXISTS (SELECT 1 FROM dirac.customer WHERE name = p_name AND id != p_customer_id) THEN
                RAISE EXCEPTION USING
                    ERRCODE = 'P0004',
                    MESSAGE = 'Customer name already exists';
            END IF;
        END IF;
    END IF;

    -- Validate email format if provided
    IF p_email IS NOT NULL AND p_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0004',
            MESSAGE = 'Invalid email format';
    END IF;

    -- Validate country code if provided
    IF p_country_code IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM dirac.country WHERE iso_3166_2 = p_country_code
    ) THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0004',
            MESSAGE = 'Invalid country code';
    END IF;

    -- Validate URL format if provided
    IF p_website_url IS NOT NULL AND p_website_url !~ '^https?://' THEN
        RAISE EXCEPTION USING
            ERRCODE = 'P0004',
            MESSAGE = 'Website URL must start with http:// or https://';
    END IF;

    -- Update customer
    UPDATE dirac.customer
    SET
        name = COALESCE(p_name, name),
        embedding = COALESCE(p_embedding, embedding),
        email = p_email,
        business_registration_number = p_business_registration_number,
        website_url = p_website_url,
        phone_number = p_phone_number,
        country_code = p_country_code,
        customer_notes = p_customer_notes,
        pipedrive_deal_id = p_pipedrive_deal_id
    WHERE id = p_customer_id;
END;
$_$;


ALTER FUNCTION admin.update_customer(p_customer_id bigint, p_name character varying, p_embedding public.vector, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer) OWNER TO postgres;

--
-- Name: update_demand_request(bigint, bigint, dirac.product_quantity, text, numeric, character, dirac.eu_goods_tier, character); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_demand_request(p_admin_id bigint, p_request_id bigint, p_quantity dirac.product_quantity, p_notes text DEFAULT NULL::text, p_target_unit_price numeric DEFAULT NULL::numeric, p_target_unit_price_currency character DEFAULT NULL::bpchar, p_eu_goods_tier dirac.eu_goods_tier DEFAULT NULL::integer, p_country_of_origin character DEFAULT NULL::bpchar) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_existing_demand RECORD;
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM auth.admin_user
        WHERE id = p_admin_id AND is_active = true
    ) THEN
        RAISE EXCEPTION 'Invalid or inactive admin'
            USING ERRCODE = 'P0002';
    END IF;

    IF (p_target_unit_price IS NULL) <> (p_target_unit_price_currency IS NULL) THEN
        RAISE EXCEPTION 'Target unit price and currency must both be provided or both be NULL'
            USING ERRCODE = 'P0004';
    END IF;

    IF p_country_of_origin IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM dirac.country WHERE iso_3166_2 = p_country_of_origin) THEN
            RAISE EXCEPTION 'Country not found: %', p_country_of_origin
                USING ERRCODE = 'P0002';
        END IF;
    END IF;

    SELECT * INTO v_existing_demand
    FROM dirac.demand_request WHERE id = p_request_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Demand request not found (ID: %)', p_request_id
            USING ERRCODE = 'P0002';
    END IF;

    UPDATE dirac.demand_request
    SET
        quantity = p_quantity, notes = p_notes,
        target_unit_price = p_target_unit_price,
        target_unit_price_currency = p_target_unit_price_currency,
        eu_goods_tier = p_eu_goods_tier, country_of_origin = p_country_of_origin,
        owner_admin_id = p_admin_id, created_at = CURRENT_TIMESTAMP
    WHERE id = p_request_id;
END;
$$;


ALTER FUNCTION admin.update_demand_request(p_admin_id bigint, p_request_id bigint, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character) OWNER TO postgres;

--
-- Name: update_manufacturer(bigint, numeric, character, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_default_moq numeric DEFAULT NULL::numeric, p_default_moq_currency character DEFAULT NULL::bpchar, p_credit_terms_days integer DEFAULT NULL::integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Validate currency if provided
    IF p_default_moq_currency IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM dirac.currency WHERE iso_4217 = p_default_moq_currency) THEN
            RAISE EXCEPTION 'Invalid currency code: %', p_default_moq_currency;
        END IF;
    END IF;

    -- Validate non-negative values
    IF p_default_moq IS NOT NULL AND p_default_moq < 0 THEN
        RAISE EXCEPTION 'Default MOQ must be non-negative';
    END IF;

    IF p_credit_terms_days IS NOT NULL AND p_credit_terms_days < 0 THEN
        RAISE EXCEPTION 'Credit terms days must be non-negative';
    END IF;

    -- Update manufacturer
    UPDATE dirac.manufacturer
    SET
        default_moq = COALESCE(p_default_moq, default_moq),
        default_moq_currency = COALESCE(p_default_moq_currency, default_moq_currency),
        credit_terms_days = COALESCE(p_credit_terms_days, credit_terms_days)
    WHERE id = p_manufacturer_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Manufacturer not found: %', p_manufacturer_id;
    END IF;
END;
$$;


ALTER FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer) OWNER TO postgres;

--
-- Name: update_manufacturer(bigint, character varying, public.vector, numeric, character, integer); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_name character varying DEFAULT NULL::character varying, p_embedding public.vector DEFAULT NULL::public.vector, p_default_moq numeric DEFAULT NULL::numeric, p_default_moq_currency character DEFAULT NULL::bpchar, p_credit_terms_days integer DEFAULT NULL::integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Validate currency if provided
    IF p_default_moq_currency IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM dirac.currency WHERE iso_4217 = p_default_moq_currency) THEN
            RAISE EXCEPTION 'Invalid currency code: %', p_default_moq_currency;
        END IF;
    END IF;

    -- Validate non-negative values
    IF p_default_moq IS NOT NULL AND p_default_moq < 0 THEN
        RAISE EXCEPTION 'Default MOQ must be non-negative';
    END IF;

    IF p_credit_terms_days IS NOT NULL AND p_credit_terms_days < 0 THEN
        RAISE EXCEPTION 'Credit terms days must be non-negative';
    END IF;

    -- Update manufacturer
    UPDATE dirac.manufacturer
    SET
        name = COALESCE(p_name, name),
        embedding = COALESCE(p_embedding, embedding),
        default_moq = COALESCE(p_default_moq, default_moq),
        default_moq_currency = COALESCE(p_default_moq_currency, default_moq_currency),
        credit_terms_days = COALESCE(p_credit_terms_days, credit_terms_days)
    WHERE id = p_manufacturer_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Manufacturer not found: %', p_manufacturer_id;
    END IF;
END;
$$;


ALTER FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_name character varying, p_embedding public.vector, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer) OWNER TO postgres;

--
-- Name: update_order_status(uuid, dirac.order_status, text); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_order_status(p_order_uuid uuid, p_new_status dirac.order_status, p_notes text DEFAULT NULL::text) RETURNS TABLE(success boolean, message text, order_id bigint, new_status dirac.order_status)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_order_id BIGINT;
	v_current_status dirac.order_status;
	v_updated_at TIMESTAMPTZ := CURRENT_TIMESTAMP;
BEGIN
	-- Get current order info
	SELECT o.id, o.status
	INTO v_order_id, v_current_status
	FROM dirac.order o
	WHERE o.uuid = p_order_uuid;

	-- Check if order exists
	IF v_order_id IS NULL THEN
		RETURN QUERY SELECT FALSE, 'Order not found', NULL::BIGINT, NULL::dirac.order_status;
		RETURN;
	END IF;

	-- Check if status is already set
	IF v_current_status = p_new_status THEN
		RETURN QUERY SELECT FALSE, 'Order already has this status', v_order_id, v_current_status;
		RETURN;
	END IF;

	-- Validate status transitions
	-- Can't move from cancelled to anything else
	IF v_current_status = 'cancelled' THEN
		RETURN QUERY SELECT FALSE, 'Cannot change status of cancelled order', v_order_id, v_current_status;
		RETURN;
	END IF;

	-- Can't move delivered order to processing/shipped
	IF v_current_status = 'delivered' AND p_new_status IN ('processing', 'shipped') THEN
		RETURN QUERY SELECT FALSE, 'Cannot move delivered order backwards', v_order_id, v_current_status;
		RETURN;
	END IF;

	-- Update the order with appropriate timestamp
	UPDATE dirac.order
	SET
		status = p_new_status,
		updated_at = v_updated_at,
		confirmed_at = CASE WHEN p_new_status = 'confirmed' THEN v_updated_at ELSE confirmed_at END,
		shipped_at = CASE WHEN p_new_status = 'shipped' THEN v_updated_at ELSE shipped_at END,
		delivered_at = CASE WHEN p_new_status = 'delivered' THEN v_updated_at ELSE delivered_at END,
		cancelled_at = CASE WHEN p_new_status = 'cancelled' THEN v_updated_at ELSE cancelled_at END,
		notes = CASE WHEN p_notes IS NOT NULL THEN
			CONCAT_WS(E'\n---\n', notes, CONCAT('[', v_updated_at::TEXT, '] ', p_notes))
		ELSE notes END
	WHERE id = v_order_id;

	RETURN QUERY SELECT TRUE, 'Order status updated successfully', v_order_id, p_new_status;
END;
$$;


ALTER FUNCTION admin.update_order_status(p_order_uuid uuid, p_new_status dirac.order_status, p_notes text) OWNER TO postgres;

--
-- Name: update_pricing_constants(numeric, numeric, boolean); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_margin_below_competitors_is_percentage boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    IF p_min_margin < 0 OR p_min_margin > 1 THEN
        RAISE EXCEPTION 'min_margin must be between 0 and 1' USING ERRCODE = 'P0004';
    END IF;

    INSERT INTO dirac.pricing_constants (min_margin, margin_below_competitors, margin_below_competitors_is_percentage)
    VALUES (p_min_margin, p_margin_below_competitors, p_margin_below_competitors_is_percentage);
END;
$$;


ALTER FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_margin_below_competitors_is_percentage boolean) OWNER TO postgres;

--
-- Name: update_pricing_constants(numeric, numeric, character varying, character varying); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_competitive_price_metric character varying DEFAULT 'median'::character varying, p_competitive_price_percentile character varying DEFAULT 'p50'::character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    IF p_min_margin < 0 OR p_min_margin > 1 THEN
        RAISE EXCEPTION 'min_margin must be between 0 and 1' USING ERRCODE = 'P0004';
    END IF;

    INSERT INTO dirac.pricing_constants (min_margin, margin_below_competitors, competitive_price_metric, competitive_price_percentile)
    VALUES (p_min_margin, p_margin_below_competitors, p_competitive_price_metric, p_competitive_price_percentile);
END;
$$;


ALTER FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_competitive_price_metric character varying, p_competitive_price_percentile character varying) OWNER TO postgres;

--
-- Name: update_product_image(bigint, bigint); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_product_image(p_product_id bigint, p_image_id bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE dirac.product
    SET image_id = p_image_id
    WHERE id = p_product_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Product not found'
            USING ERRCODE = 'P0002';
    END IF;
END;
$$;


ALTER FUNCTION admin.update_product_image(p_product_id bigint, p_image_id bigint) OWNER TO postgres;

--
-- Name: update_product_web_pricing(bigint, numeric, character, bigint, character varying, bigint, boolean); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.update_product_web_pricing(p_product_id bigint, p_web_unit_price numeric, p_web_unit_price_currency character, p_web_discount bigint, p_web_discount_unit character varying, p_web_product_case_id bigint DEFAULT NULL::bigint, p_show_on_web boolean DEFAULT NULL::boolean) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_show_on_web BOOLEAN;
    v_final_show_on_web BOOLEAN;
    v_units_per_case INT;
    v_layers_per_pallet INT;
BEGIN
    -- Get current show_on_web status
    SELECT show_on_web INTO v_show_on_web
    FROM dirac.product
    WHERE id = p_product_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Product not found'
            USING ERRCODE = 'P0002';
    END IF;

    -- Determine final show_on_web state (new value if provided, otherwise keep current)
    v_final_show_on_web := COALESCE(p_show_on_web, v_show_on_web);

    -- If product will be shown on web, validate web_product_case_id requirements
    IF v_final_show_on_web THEN
        IF p_web_product_case_id IS NULL THEN
            RAISE EXCEPTION 'Products shown on web must have a web case size selected'
                USING ERRCODE = 'P0004';
        END IF;

        -- Validate the selected case has required fields
        SELECT units_per_case, layers_per_pallet
        INTO v_units_per_case, v_layers_per_pallet
        FROM dirac.product_case
        WHERE id = p_web_product_case_id
          AND product_id = p_product_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Selected case does not exist or does not belong to this product'
                USING ERRCODE = 'P0004';
        END IF;

        IF v_units_per_case IS NULL THEN
            RAISE EXCEPTION 'Web case must have units_per_case specified'
                USING ERRCODE = 'P0004';
        END IF;

        IF v_layers_per_pallet IS NULL THEN
            RAISE EXCEPTION 'Web case must have layers_per_pallet specified'
                USING ERRCODE = 'P0004';
        END IF;
    END IF;

    -- Update product web pricing and show_on_web status
    UPDATE dirac.product
    SET web_unit_price = p_web_unit_price,
        web_unit_price_currency = p_web_unit_price_currency,
        web_discount = p_web_discount,
        web_discount_unit = CASE
            WHEN p_web_discount_unit IS NOT NULL
            THEN p_web_discount_unit::dirac.product_quantity_unit
            ELSE NULL
        END,
        web_product_case_id = p_web_product_case_id,
        show_on_web = v_final_show_on_web
    WHERE id = p_product_id;
END;
$$;


ALTER FUNCTION admin.update_product_web_pricing(p_product_id bigint, p_web_unit_price numeric, p_web_unit_price_currency character, p_web_discount bigint, p_web_discount_unit character varying, p_web_product_case_id bigint, p_show_on_web boolean) OWNER TO postgres;

--
-- Name: upsert_margin_estimate(character varying, character varying, numeric, numeric, numeric, boolean); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.upsert_margin_estimate(p_company_name character varying, p_company_domain character varying, p_p20 numeric, p_p50 numeric, p_p80 numeric, p_ignore boolean DEFAULT false) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_margin_id BIGINT;
BEGIN
    -- Validate inputs
    IF p_company_name IS NULL OR trim(p_company_name) = '' THEN
        RAISE EXCEPTION 'Company name cannot be null or empty' USING ERRCODE = 'P0004';
    END IF;

    IF p_p20 IS NOT NULL AND (p_p20 < 0 OR p_p20 > 1) THEN
        RAISE EXCEPTION 'p20 must be between 0 and 1' USING ERRCODE = 'P0004';
    END IF;

    IF p_p50 IS NOT NULL AND (p_p50 < 0 OR p_p50 > 1) THEN
        RAISE EXCEPTION 'p50 must be between 0 and 1' USING ERRCODE = 'P0004';
    END IF;

    IF p_p80 IS NOT NULL AND (p_p80 < 0 OR p_p80 > 1) THEN
        RAISE EXCEPTION 'p80 must be between 0 and 1' USING ERRCODE = 'P0004';
    END IF;

    -- Insert or update
    INSERT INTO dirac.margin_estimate (company_name, company_domain, p20, p50, p80, ignore, updated_at)
    VALUES (trim(p_company_name), p_company_domain, p_p20, p_p50, p_p80, p_ignore, CURRENT_TIMESTAMP)
    ON CONFLICT (company_name) DO UPDATE
        SET company_domain = COALESCE(EXCLUDED.company_domain, dirac.margin_estimate.company_domain),
            p20 = COALESCE(EXCLUDED.p20, dirac.margin_estimate.p20),
            p50 = COALESCE(EXCLUDED.p50, dirac.margin_estimate.p50),
            p80 = COALESCE(EXCLUDED.p80, dirac.margin_estimate.p80),
            ignore = COALESCE(EXCLUDED.ignore, dirac.margin_estimate.ignore),
            updated_at = CURRENT_TIMESTAMP
    RETURNING id INTO v_margin_id;

    RETURN v_margin_id;
END;
$$;


ALTER FUNCTION admin.upsert_margin_estimate(p_company_name character varying, p_company_domain character varying, p_p20 numeric, p_p50 numeric, p_p80 numeric, p_ignore boolean) OWNER TO postgres;

--
-- Name: upsert_product_case(bigint, bigint, character varying, integer, integer, integer, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.upsert_product_case(p_case_id bigint DEFAULT NULL::bigint, p_product_id bigint DEFAULT NULL::bigint, p_case_barcode character varying DEFAULT NULL::character varying, p_units_per_case integer DEFAULT NULL::integer, p_cases_per_layer integer DEFAULT NULL::integer, p_layers_per_pallet integer DEFAULT NULL::integer, p_weight_kg numeric DEFAULT NULL::numeric, p_height_cm numeric DEFAULT NULL::numeric, p_width_cm numeric DEFAULT NULL::numeric, p_length_cm numeric DEFAULT NULL::numeric) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_case_id BIGINT;
    v_barcode CHAR(14);
BEGIN
    IF p_case_id IS NULL AND p_product_id IS NULL THEN
        RAISE EXCEPTION 'Must provide either case_id (for update) or product_id (for insert)'
            USING ERRCODE = 'P0004';
    END IF;

    IF p_case_id IS NULL AND p_units_per_case IS NULL THEN
        RAISE EXCEPTION 'units_per_case is required when creating a new case'
            USING ERRCODE = 'P0004';
    END IF;

    IF p_case_barcode IS NOT NULL THEN
        v_barcode := dirac.to_gtin_14(p_case_barcode);
        INSERT INTO dirac.barcode (gtin_14)
        VALUES (v_barcode)
        ON CONFLICT (gtin_14) DO NOTHING;
    END IF;

    IF p_case_id IS NOT NULL THEN
        UPDATE dirac.product_case
        SET
            case_barcode = COALESCE(v_barcode, case_barcode),
            units_per_case = COALESCE(p_units_per_case, units_per_case),
            cases_per_layer = COALESCE(p_cases_per_layer, cases_per_layer),
            layers_per_pallet = COALESCE(p_layers_per_pallet, layers_per_pallet),
            weight_kg = COALESCE(p_weight_kg, weight_kg),
            height_cm = COALESCE(p_height_cm, height_cm),
            width_cm = COALESCE(p_width_cm, width_cm),
            length_cm = COALESCE(p_length_cm, length_cm)
        WHERE id = p_case_id
        RETURNING id INTO v_case_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Case not found (ID: %)', p_case_id
                USING ERRCODE = 'P0002';
        END IF;
    ELSE
        INSERT INTO dirac.product_case (
            product_id,
            case_barcode,
            units_per_case,
            cases_per_layer,
            layers_per_pallet,
            weight_kg,
            height_cm,
            width_cm,
            length_cm
        )
        VALUES (
            p_product_id,
            v_barcode,
            p_units_per_case,
            p_cases_per_layer,
            p_layers_per_pallet,
            p_weight_kg,
            p_height_cm,
            p_width_cm,
            p_length_cm
        )
        ON CONFLICT (product_id, units_per_case) DO UPDATE
        SET
            case_barcode = COALESCE(EXCLUDED.case_barcode, product_case.case_barcode),
            cases_per_layer = COALESCE(EXCLUDED.cases_per_layer, product_case.cases_per_layer),
            layers_per_pallet = COALESCE(EXCLUDED.layers_per_pallet, product_case.layers_per_pallet),
            weight_kg = COALESCE(EXCLUDED.weight_kg, product_case.weight_kg),
            height_cm = COALESCE(EXCLUDED.height_cm, product_case.height_cm),
            width_cm = COALESCE(EXCLUDED.width_cm, product_case.width_cm),
            length_cm = COALESCE(EXCLUDED.length_cm, product_case.length_cm)
        RETURNING id INTO v_case_id;
    END IF;

    RETURN v_case_id;
END;
$$;


ALTER FUNCTION admin.upsert_product_case(p_case_id bigint, p_product_id bigint, p_case_barcode character varying, p_units_per_case integer, p_cases_per_layer integer, p_layers_per_pallet integer, p_weight_kg numeric, p_height_cm numeric, p_width_cm numeric, p_length_cm numeric) OWNER TO postgres;

--
-- Name: upsert_product_offer(bigint, bigint, integer, numeric, character, character varying, character, integer, integer, integer, character, dirac.eu_goods_tier, boolean); Type: FUNCTION; Schema: admin; Owner: postgres
--

CREATE FUNCTION admin.upsert_product_offer(p_supplier_id bigint, p_product_id bigint, p_units_per_case integer, p_case_price_base numeric, p_case_price_currency character, p_sku character varying DEFAULT NULL::character varying, p_case_barcode character DEFAULT NULL::bpchar, p_cases_per_layer integer DEFAULT NULL::integer, p_layers_per_pallet integer DEFAULT NULL::integer, p_moq_cases integer DEFAULT NULL::integer, p_country_of_origin character DEFAULT NULL::bpchar, p_eu_goods_tier dirac.eu_goods_tier DEFAULT NULL::integer, p_is_active boolean DEFAULT true) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_offer_id BIGINT;
    v_product_case_id BIGINT;
BEGIN
    -- Validate supplier exists
    IF NOT EXISTS (SELECT 1 FROM dirac.supplier WHERE id = p_supplier_id) THEN
        RAISE EXCEPTION 'Supplier not found (ID: %)', p_supplier_id
            USING ERRCODE = 'P0002';
    END IF;

    -- Validate product exists
    IF NOT EXISTS (SELECT 1 FROM dirac.product WHERE id = p_product_id) THEN
        RAISE EXCEPTION 'Product not found (ID: %)', p_product_id
            USING ERRCODE = 'P0002';
    END IF;

    -- Validate currency exists
    IF NOT EXISTS (SELECT 1 FROM dirac.currency WHERE iso_4217 = p_case_price_currency) THEN
        RAISE EXCEPTION 'Currency not found: %', p_case_price_currency
            USING ERRCODE = 'P0002';
    END IF;

    -- Validate country if provided
    IF p_country_of_origin IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM dirac.country WHERE iso_3166_2 = p_country_of_origin) THEN
            RAISE EXCEPTION 'Country not found: %', p_country_of_origin
                USING ERRCODE = 'P0002';
        END IF;
    END IF;

    -- Validate units_per_case is positive
    IF p_units_per_case <= 0 THEN
        RAISE EXCEPTION 'Units per case must be positive'
            USING ERRCODE = 'P0004';
    END IF;

    -- Validate case_price is positive
    IF p_case_price_base <= 0 THEN
        RAISE EXCEPTION 'Case price must be positive'
            USING ERRCODE = 'P0004';
    END IF;

    -- Find or create product_case
    SELECT id INTO v_product_case_id
    FROM dirac.product_case
    WHERE product_id = p_product_id
      AND units_per_case = p_units_per_case
      AND (case_barcode = p_case_barcode OR (case_barcode IS NULL AND p_case_barcode IS NULL))
    LIMIT 1;

    -- If no matching product_case exists, create it
    IF v_product_case_id IS NULL THEN
        INSERT INTO dirac.product_case (
            product_id,
            case_barcode,
            units_per_case,
            cases_per_layer,
            layers_per_pallet
        ) VALUES (
            p_product_id,
            p_case_barcode,
            p_units_per_case,
            p_cases_per_layer,
            p_layers_per_pallet
        )
        RETURNING id INTO v_product_case_id;
    END IF;

    -- Insert product offer (or update if already exists)
    INSERT INTO dirac.product_offer (
        supplier_id,
        product_id,
        product_case_id,
        sku,
        case_price_base,
        case_price_currency,
        moq_cases,
        country_of_origin,
        eu_goods_tier,
        is_active
    ) VALUES (
        p_supplier_id,
        p_product_id,
        v_product_case_id,
        p_sku,
        p_case_price_base,
        p_case_price_currency,
        p_moq_cases,
        p_country_of_origin,
        p_eu_goods_tier,
        p_is_active
    )
    ON CONFLICT (supplier_id, product_id) DO UPDATE SET
        sku = EXCLUDED.sku,
        product_case_id = EXCLUDED.product_case_id,
        case_price_base = EXCLUDED.case_price_base,
        case_price_currency = EXCLUDED.case_price_currency,
        moq_cases = EXCLUDED.moq_cases,
        country_of_origin = EXCLUDED.country_of_origin,
        eu_goods_tier = EXCLUDED.eu_goods_tier,
        is_active = EXCLUDED.is_active,
        updated_at = CURRENT_TIMESTAMP
    RETURNING id INTO v_offer_id;

    RETURN v_offer_id;
END;
$$;


ALTER FUNCTION admin.upsert_product_offer(p_supplier_id bigint, p_product_id bigint, p_units_per_case integer, p_case_price_base numeric, p_case_price_currency character, p_sku character varying, p_case_barcode character, p_cases_per_layer integer, p_layers_per_pallet integer, p_moq_cases integer, p_country_of_origin character, p_eu_goods_tier dirac.eu_goods_tier, p_is_active boolean) OWNER TO postgres;

--
-- Name: add_location(character varying, character, character varying, text, character varying, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.add_location(p_name character varying, p_country character, p_region character varying DEFAULT NULL::character varying, p_address text DEFAULT NULL::text, p_postcode character varying DEFAULT NULL::character varying, p_google_place_id character varying DEFAULT NULL::character varying) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_location_id BIGINT;
BEGIN
    -- Validate name is not empty
    IF p_name IS NULL OR trim(p_name) = '' THEN
        RAISE EXCEPTION 'Location name cannot be empty'
            USING ERRCODE = 'P0004';
    END IF;

    -- Validate country exists
    IF NOT EXISTS (SELECT 1 FROM dirac.country WHERE iso_3166_2 = p_country) THEN
        RAISE EXCEPTION 'Invalid country code: %', p_country
            USING ERRCODE = 'P0004';
    END IF;

    -- Try to find existing location by address (most specific identifier)
    IF p_address IS NOT NULL AND trim(p_address) != '' THEN
        SELECT id INTO v_location_id
        FROM dirac.location
        WHERE address = trim(p_address);

        IF v_location_id IS NOT NULL THEN
            RETURN v_location_id;
        END IF;
    END IF;

    -- Insert location if not found
    INSERT INTO dirac.location (
        name,
        country,
        region,
        address,
        postcode,
        google_place_id
    ) VALUES (
        trim(p_name),
        p_country,
        NULLIF(trim(p_region), ''),
        NULLIF(trim(p_address), ''),
        NULLIF(trim(p_postcode), ''),
        NULLIF(trim(p_google_place_id), '')
    )
    ON CONFLICT (address) DO UPDATE SET
        name = EXCLUDED.name,
        country = EXCLUDED.country,
        region = EXCLUDED.region,
        postcode = EXCLUDED.postcode,
        google_place_id = EXCLUDED.google_place_id
    RETURNING id INTO v_location_id;

    RETURN v_location_id;
END;
$$;


ALTER FUNCTION api.add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying) OWNER TO postgres;

--
-- Name: add_to_basket(bigint, character varying, numeric); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.add_to_basket(p_user_id bigint, p_product_slug character varying, p_case_quantity numeric) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_order_uuid UUID;
	v_order_id BIGINT;
	v_item_id BIGINT;
	v_product_case_id BIGINT;
	v_web_unit_price DECIMAL(19,4);
	v_currency CHAR(3);
	v_units_per_case INT;
	v_case_price DECIMAL(19,4);
	v_uk_vat_fraction DECIMAL(5,4);
	v_basket_currency CHAR(3);
BEGIN
	-- Get product case and validate it exists and is available on web
	SELECT
		p.web_product_case_id,
		p.web_unit_price,
		p.web_unit_price_currency,
		pc.units_per_case,
		p.uk_vat_fraction
	INTO
		v_product_case_id,
		v_web_unit_price,
		v_currency,
		v_units_per_case,
		v_uk_vat_fraction
	FROM dirac.product p
	LEFT JOIN dirac.product_case pc ON pc.id = p.web_product_case_id
	WHERE p.slug = p_product_slug AND p.show_on_web = TRUE;

	IF v_product_case_id IS NULL THEN
		RAISE EXCEPTION 'Product not found or not available'
			USING ERRCODE = 'P0002';
	END IF;

	IF v_web_unit_price IS NULL THEN
		RAISE EXCEPTION 'Product does not have web pricing set'
			USING ERRCODE = 'P0004';
	END IF;

	IF v_units_per_case IS NULL THEN
		RAISE EXCEPTION 'Product does not have case size configured'
			USING ERRCODE = 'P0004';
	END IF;

	-- Calculate case price from unit price
	v_case_price := v_web_unit_price * v_units_per_case;

	-- Get or create basket
	SELECT order_uuid, id INTO v_order_uuid, v_order_id
	FROM api.get_or_create_basket(p_user_id);

	-- Check if basket already has items with a different currency
	SELECT currency INTO v_basket_currency
	FROM dirac.order_item
	WHERE order_id = v_order_id
	LIMIT 1;

	-- If basket has items and currency doesn't match, reject
	IF v_basket_currency IS NOT NULL AND v_basket_currency != v_currency THEN
		RAISE EXCEPTION 'Cannot add product with currency % to basket. Basket already contains items in %',
			v_currency, v_basket_currency
			USING ERRCODE = 'P0004';
	END IF;

	-- Insert or update order item (VAT calculated on the fly by trigger)
	INSERT INTO dirac.order_item (
		order_id,
		product_case_id,
		case_quantity,
		case_price,
		currency,
		uk_vat_fraction
	)
	VALUES (
		v_order_id,
		v_product_case_id,
		p_case_quantity,
		v_case_price,
		v_currency,
		v_uk_vat_fraction
	)
	ON CONFLICT (order_id, product_case_id)
	DO UPDATE SET
		case_quantity = dirac.order_item.case_quantity + EXCLUDED.case_quantity
	RETURNING dirac.order_item.id INTO v_item_id;

	RETURN v_item_id;
END;
$$;


ALTER FUNCTION api.add_to_basket(p_user_id bigint, p_product_slug character varying, p_case_quantity numeric) OWNER TO postgres;

--
-- Name: calculate_checkout_total(uuid); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.calculate_checkout_total(p_order_uuid uuid) RETURNS TABLE(subtotal_excl_vat numeric, total_vat numeric, total_incl_vat numeric, shipping_cost numeric, num_pallets integer, total numeric, currency character, is_uk boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_subtotal_excl_vat DECIMAL(19,4);
	v_total_vat DECIMAL(19,4);
	v_total_incl_vat DECIMAL(19,4);
	v_currency CHAR(3);
	v_num_pallets INTEGER;
	v_shipping_cost DECIMAL(19,4);
	v_shipping_currency CHAR(3);
	v_is_uk BOOLEAN;
	v_total DECIMAL(19,4);
BEGIN
	-- Get order totals
	SELECT
		o.total_amount_excl_vat,
		o.total_vat_amount,
		o.total_amount_incl_vat,
		o.currency
	INTO
		v_subtotal_excl_vat,
		v_total_vat,
		v_total_incl_vat,
		v_currency
	FROM dirac.order o
	WHERE o.uuid = p_order_uuid;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Order not found' USING ERRCODE = 'P0002';
	END IF;

	-- Calculate shipping cost using helper function
	SELECT
		s.num_pallets,
		s.shipping_cost_amount,
		s.shipping_cost_currency,
		s.is_uk
	INTO
		v_num_pallets,
		v_shipping_cost,
		v_shipping_currency,
		v_is_uk
	FROM dirac.calculate_shipping_cost(p_order_uuid) AS s;

	-- Store shipping values in order table
	UPDATE dirac.order
	SET
		shipping_pallets = v_num_pallets,
		shipping_cost_amount = v_shipping_cost,
		shipping_cost_currency = v_shipping_currency,
		shipping_cost_calculated_at = CURRENT_TIMESTAMP
	WHERE uuid = p_order_uuid;

	-- Calculate total: order total (inc VAT) + shipping
	v_total := COALESCE(v_total_incl_vat, 0) + COALESCE(v_shipping_cost, 0);

	RETURN QUERY
	SELECT
		v_subtotal_excl_vat,
		v_total_vat,
		v_total_incl_vat,
		v_shipping_cost,
		v_num_pallets,
		v_total,
		v_currency,
		v_is_uk;
END;
$$;


ALTER FUNCTION api.calculate_checkout_total(p_order_uuid uuid) OWNER TO postgres;

--
-- Name: FUNCTION calculate_checkout_total(p_order_uuid uuid); Type: COMMENT; Schema: api; Owner: postgres
--

COMMENT ON FUNCTION api.calculate_checkout_total(p_order_uuid uuid) IS 'Calculate the total for checkout including shipping. Calculates and stores shipping cost, then returns all breakdown values. This is the single source of truth for the amount to charge via Stripe.';


--
-- Name: change_password(uuid, text, inet, text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.change_password(_session_id uuid, _new_password text, _ip inet, _user_agent text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	_user_id BIGINT;
	_hash TEXT;
BEGIN
	-- always hash the password to prevent timing attack
	_hash = auth.hash_password(_new_password);

	-- we could use get_user_from_session here but we want to check the ip and user agent match so lets use is_session_valid
	IF NOT api.is_session_valid(_session_id, _ip, _user_agent) THEN
		RAISE EXCEPTION 'Session is invalid'
			USING ERRCODE = 'P0001'; --RaiseError: business logic
	END IF;

	SELECT user_id INTO _user_id
	FROM auth.web_session
	WHERE uuid = _session_id
	FOR UPDATE;

	IF _user_id IS NULL THEN
		RAISE EXCEPTION 'Session not found'
			USING ERRCODE = 'P0001';
	END IF;

	UPDATE auth.user
	SET password_hash = _hash
	WHERE id = _user_id;
END;
$$;


ALTER FUNCTION api.change_password(_session_id uuid, _new_password text, _ip inet, _user_agent text) OWNER TO postgres;

--
-- Name: create_account(text, text, inet, text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.create_account(_email text, _password text, _ip inet, _user_agent text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  _uid          BIGINT;
  _hash         TEXT;
  _uuid         UUID;
BEGIN
	IF _email IS NULL OR NOT check_email(_email) THEN
		RAISE EXCEPTION 'Invalid email'
			USING ERRCODE = 'P0004'; -- AssertError: input validation
	END IF;
	_hash = auth.hash_password(_password);
	BEGIN
		INSERT INTO auth.user (email, password_hash)
		VALUES (_email, _hash)
		RETURNING id INTO _uid;
	EXCEPTION
		WHEN unique_violation THEN
		RAISE EXCEPTION 'Email % already exists', _email
			USING ERRCODE = 'P0001'; -- RaiseError: business logic error
	END;
	-- email is unique
	IF _uid IS NULL THEN
		RAISE EXCEPTION 'Failed to create user account'
			USING ERRCODE = 'P0001'; -- RaiseError: business logic error
	END IF;

	_uuid := gen_random_uuid();
	INSERT INTO auth.web_session (uuid, user_id,ip, user_agent,expires_at)
	VALUES (_uuid,_uid,_ip, _user_agent,NOW() + INTERVAL '5 hours');
	RETURN _uuid;
END;
$$;


ALTER FUNCTION api.create_account(_email text, _password text, _ip inet, _user_agent text) OWNER TO postgres;

--
-- Name: create_payment_record(uuid, character varying, numeric, character, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.create_payment_record(p_order_uuid uuid, p_stripe_payment_intent_id character varying, p_amount numeric, p_currency character, p_status character varying) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_payment_id BIGINT;
    v_order_id BIGINT;
BEGIN
    -- Get order ID from UUID
    SELECT id INTO v_order_id
    FROM dirac.order
    WHERE uuid = p_order_uuid;

    IF v_order_id IS NULL THEN
        RAISE EXCEPTION 'Order not found' USING ERRCODE = 'P0002';
    END IF;

    INSERT INTO dirac.payment (
        order_id,
        stripe_payment_intent_id,
        amount,
        currency,
        status
    ) VALUES (
        v_order_id,
        p_stripe_payment_intent_id,
        p_amount,
        p_currency,
        p_status
    )
    RETURNING id INTO v_payment_id;

    RETURN v_payment_id;
END;
$$;


ALTER FUNCTION api.create_payment_record(p_order_uuid uuid, p_stripe_payment_intent_id character varying, p_amount numeric, p_currency character, p_status character varying) OWNER TO postgres;

--
-- Name: generate_email_verification_token(text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.generate_email_verification_token(_email text) RETURNS TABLE(token uuid, expires_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  _user_id BIGINT;
  _existing_token UUID;
  _token_updated_at TIMESTAMPTZ;
  _new_token UUID;
  _expires TIMESTAMPTZ;
  _wait_seconds INT;
BEGIN
  -- Get user and existing token info
  SELECT id, email_verification_token, updated_at
  INTO _user_id, _existing_token, _token_updated_at
  FROM auth.user
  WHERE email = _email;

  IF _user_id IS NULL THEN
    RAISE EXCEPTION 'User not found' USING ERRCODE = 'P0001';
  END IF;

  -- Check if token was updated less than 10 minutes ago
  IF _existing_token IS NOT NULL
     AND _token_updated_at > NOW() - INTERVAL '10 minutes' THEN
    _wait_seconds := EXTRACT(EPOCH FROM (
      (_token_updated_at + INTERVAL '10 minutes') - NOW()
    ))::INT;

    RAISE EXCEPTION 'Please wait % seconds before requesting a new verification email',
      _wait_seconds
      USING ERRCODE = 'P0001'; -- RaiseError
  END IF;

  -- Generate new token
  _new_token := gen_random_uuid();
  _expires := NOW() + INTERVAL '24 hours';

  -- Update user record
  UPDATE auth.user
  SET email_verification_token = _new_token,
      email_verification_expires_at = _expires,
      updated_at = NOW()
  WHERE id = _user_id;

  RETURN QUERY SELECT _new_token, _expires;
END;
$$;


ALTER FUNCTION api.generate_email_verification_token(_email text) OWNER TO postgres;

--
-- Name: get_basket_items(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_basket_items(p_user_id bigint) RETURNS TABLE(item_id bigint, product_id bigint, product_name character varying, product_slug character varying, brand_name character varying, image_uuid uuid, image_type text, case_quantity numeric, units_per_case integer, case_price numeric, currency character, line_total numeric, uk_vat_fraction numeric, vat_amount numeric, line_total_with_vat numeric)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
	v_order_uuid UUID;
BEGIN
	-- Get active basket's UUID
	SELECT o.uuid INTO v_order_uuid
	FROM dirac.order o
	WHERE o.user_id = p_user_id
	  AND o.status = 'basket'
	ORDER BY o.created_at DESC
	LIMIT 1;

	IF v_order_uuid IS NULL THEN
		RETURN;  -- Empty result set
	END IF;

	-- Delegate to get_order_items (single source of truth)
	RETURN QUERY
	SELECT * FROM api.get_order_items(p_user_id, v_order_uuid);
END;
$$;


ALTER FUNCTION api.get_basket_items(p_user_id bigint) OWNER TO postgres;

--
-- Name: get_brands(); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_brands() RETURNS TABLE(name text)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT DISTINCT b.name
    FROM dirac.brand b
    JOIN dirac.product p ON p.brand_id = b.id
    WHERE p.show_on_web = TRUE
    ORDER BY b.name;
$$;


ALTER FUNCTION api.get_brands() OWNER TO postgres;

--
-- Name: get_countries(); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_countries() RETURNS TABLE(iso_3166_2 character, name character varying)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
	SELECT iso_3166_2, name
	FROM dirac.country
	ORDER BY
		CASE iso_3166_2
			WHEN 'GB' THEN 1
			WHEN 'US' THEN 2
			ELSE 3
		END,
		name;
$$;


ALTER FUNCTION api.get_countries() OWNER TO postgres;

--
-- Name: get_currencies(); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_currencies() RETURNS TABLE(iso_4217 character, name character varying)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
	SELECT iso_4217, name
	FROM dirac.currency
	ORDER BY
		CASE iso_4217
			WHEN 'GBP' THEN 1
			WHEN 'EUR' THEN 2
			WHEN 'USD' THEN 3
			ELSE 4
		END,
		iso_4217;
$$;


ALTER FUNCTION api.get_currencies() OWNER TO postgres;

--
-- Name: get_customer_data_for_stripe(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_customer_data_for_stripe(p_user_id bigint) RETURNS TABLE(customer_id bigint, email public.email, name character varying, vat_number character varying, stripe_customer_id character varying, billing_address jsonb, shipping_address jsonb)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id AS customer_id,
        u.email,
        COALESCE(c.name, u.email::TEXT)::VARCHAR(255) AS name,
        c.vat_number,
        c.stripe_customer_id,
        -- Billing address as JSONB
        CASE WHEN bl.id IS NOT NULL THEN
            jsonb_build_object(
                'name', bl.name,
                'address', bl.address,
                'postcode', bl.postcode,
                'region', bl.region,
                'country', bl.country
            )
        ELSE NULL END AS billing_address,
        -- Shipping address as JSONB
        CASE WHEN sl.id IS NOT NULL THEN
            jsonb_build_object(
                'name', sl.name,
                'address', sl.address,
                'postcode', sl.postcode,
                'region', sl.region,
                'country', sl.country
            )
        ELSE NULL END AS shipping_address
    FROM auth.user u
    LEFT JOIN dirac.customer c ON u.customer_id = c.id
    LEFT JOIN dirac.location bl ON c.billing_location_id = bl.id
    LEFT JOIN dirac.location sl ON c.shipping_location_id = sl.id
    WHERE u.id = p_user_id;
END;
$$;


ALTER FUNCTION api.get_customer_data_for_stripe(p_user_id bigint) OWNER TO postgres;

--
-- Name: get_customer_info(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_customer_info(p_customer_id bigint) RETURNS TABLE(id bigint, name character varying, email character varying, shipping_location_id bigint, billing_location_id bigint, vat_number character varying, stripe_customer_id character varying)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id,
        c.name,
        c.email,
        c.shipping_location_id,
        c.billing_location_id,
        c.vat_number,
        c.stripe_customer_id
    FROM dirac.customer c
    WHERE c.id = p_customer_id;
END;
$$;


ALTER FUNCTION api.get_customer_info(p_customer_id bigint) OWNER TO postgres;

--
-- Name: get_discount_function(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_discount_function(p_discount_function_id bigint) RETURNS TABLE(id bigint, name character varying, description text, discounts dirac.discount_range[])
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT df.id, df.name, df.description, df.discounts
    FROM dirac.discount_function df
    WHERE df.id = p_discount_function_id;
END;
$$;


ALTER FUNCTION api.get_discount_function(p_discount_function_id bigint) OWNER TO postgres;

--
-- Name: get_location_by_id(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_location_by_id(p_location_id bigint) RETURNS TABLE(id bigint, name character varying, country character, region character varying, address text, postcode character varying, google_place_id character varying)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		l.id,
		l.name,
		l.country,
		l.region,
		l.address,
		l.postcode,
		l.google_place_id
	FROM dirac.location l
	WHERE l.id = p_location_id;
END;
$$;


ALTER FUNCTION api.get_location_by_id(p_location_id bigint) OWNER TO postgres;

--
-- Name: get_or_create_basket(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_or_create_basket(p_user_id bigint) RETURNS TABLE(id bigint, order_uuid uuid, status dirac.order_status, created_at timestamp with time zone, total_amount_excl_vat numeric, total_vat_amount numeric, total_amount_incl_vat numeric, currency character, shipping_cost_amount numeric, shipping_cost_currency character)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_order_id BIGINT;
BEGIN
	-- Temporary stub - will be replaced below
	SELECT o.id INTO v_order_id
	FROM dirac.order o
	WHERE o.user_id = p_user_id
	  AND o.status = 'basket'
	ORDER BY o.created_at DESC
	LIMIT 1;

	IF v_order_id IS NULL THEN
		INSERT INTO dirac.order (user_id, status)
		VALUES (p_user_id, 'basket')
		RETURNING dirac.order.id INTO v_order_id;
	END IF;

	RETURN QUERY
	SELECT
		o.id,
		o.uuid,
		o.status,
		o.created_at,
		o.total_amount_excl_vat,
		o.total_vat_amount,
		o.total_amount_incl_vat,
		o.currency,
		o.shipping_cost_amount,
		o.shipping_cost_currency
	FROM dirac.order o
	WHERE o.id = v_order_id;
END;
$$;


ALTER FUNCTION api.get_or_create_basket(p_user_id bigint) OWNER TO postgres;

--
-- Name: get_order_details(bigint, uuid); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_order_details(p_user_id bigint, p_order_uuid uuid) RETURNS TABLE(order_uuid uuid, status dirac.order_status, created_at timestamp with time zone, placed_at timestamp with time zone, confirmed_at timestamp with time zone, shipped_at timestamp with time zone, delivered_at timestamp with time zone, cancelled_at timestamp with time zone, paid_at timestamp with time zone, total_amount_excl_vat numeric, total_vat_amount numeric, total_amount_incl_vat numeric, stripe_checkout_session_id character varying, currency character, notes text, shipping_address_id bigint, billing_address_id bigint, delivery_instructions text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	-- Verify order belongs to user
	IF NOT EXISTS (
		SELECT 1 FROM dirac.order
		WHERE uuid = p_order_uuid AND user_id = p_user_id
	) THEN
		RAISE EXCEPTION 'Order not found or access denied'
			USING ERRCODE = 'P0002';
	END IF;

	RETURN QUERY
	SELECT
		o.uuid,
		o.status,
		o.created_at,
		o.placed_at,
		o.confirmed_at,
		o.shipped_at,
		o.delivered_at,
		o.cancelled_at,
		o.paid_at,
		o.total_amount_excl_vat,
		o.total_vat_amount,
		o.total_amount_incl_vat,
		o.stripe_checkout_session_id,
		o.currency,
		o.notes,
		o.shipping_address_id,
		o.billing_address_id,
		o.delivery_instructions
	FROM dirac.order o
	WHERE o.uuid = p_order_uuid;
END;
$$;


ALTER FUNCTION api.get_order_details(p_user_id bigint, p_order_uuid uuid) OWNER TO postgres;

--
-- Name: get_order_items(bigint, uuid); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_order_items(p_user_id bigint, p_order_uuid uuid) RETURNS TABLE(item_id bigint, product_id bigint, product_name character varying, product_slug character varying, brand_name character varying, image_uuid uuid, image_type text, case_quantity numeric, units_per_case integer, case_price numeric, currency character, line_total numeric, uk_vat_fraction numeric, vat_amount numeric, line_total_with_vat numeric)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	-- Verify order belongs to user (permission check)
	IF NOT EXISTS (
		SELECT 1 FROM dirac.order
		WHERE uuid = p_order_uuid AND user_id = p_user_id
	) THEN
		RAISE EXCEPTION 'Order not found or access denied'
			USING ERRCODE = 'P0002';
	END IF;

	-- Delegate to admin function (excludes barcode fields for API)
	RETURN QUERY
	SELECT
		items.item_id,
		items.product_id,
		items.product_name,
		items.product_slug,
		items.brand_name,
		items.image_uuid,
		items.image_type,
		items.case_quantity,
		items.units_per_case,
		items.case_price,
		items.currency,
		items.line_total,
		items.uk_vat_fraction,
		items.vat_amount,
		items.line_total_with_vat
	FROM admin.get_order_items(p_order_uuid) AS items;
END;
$$;


ALTER FUNCTION api.get_order_items(p_user_id bigint, p_order_uuid uuid) OWNER TO postgres;

--
-- Name: get_order_uuid_by_session_id(character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_order_uuid_by_session_id(p_session_id character varying) RETURNS uuid
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    v_order_uuid UUID;
BEGIN
    SELECT uuid INTO v_order_uuid
    FROM dirac.order
    WHERE stripe_checkout_session_id = p_session_id;

    RETURN v_order_uuid;
END;
$$;


ALTER FUNCTION api.get_order_uuid_by_session_id(p_session_id character varying) OWNER TO postgres;

--
-- Name: get_pallets_for_order(uuid); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_pallets_for_order(order_uuid uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    _pallet_fraction_remaining NUMERIC := 0;
    _num_pallets_used INTEGER := 0;
    _num_layers INTEGER;
    _num_pallets INTEGER;
    _num_layers_remaining NUMERIC;
    row RECORD;
BEGIN
    FOR row IN
        SELECT
            oi.case_quantity,
            pc.cases_per_layer,
            pc.layers_per_pallet,
            pc.id as product_case_id
        FROM dirac.order_item oi
        JOIN dirac.product_case pc ON pc.id = oi.product_case_id
        JOIN dirac.order o ON oi.order_id = o.id
        WHERE o.uuid = order_uuid
    LOOP
        -- Validate pallet configuration
        IF row.cases_per_layer IS NULL OR row.cases_per_layer <= 0 THEN
            RAISE EXCEPTION 'Invalid cases_per_layer (%) for product_case_id: %',
                row.cases_per_layer, row.product_case_id;
        END IF;

        IF row.layers_per_pallet IS NULL OR row.layers_per_pallet <= 0 THEN
            RAISE EXCEPTION 'Invalid layers_per_pallet (%) for product_case_id: %',
                row.layers_per_pallet, row.product_case_id;
        END IF;

        _num_layers := CEILING(row.case_quantity::NUMERIC / row.cases_per_layer);
        _num_pallets := FLOOR(_num_layers / row.layers_per_pallet);
        _num_layers_remaining := _num_layers % row.layers_per_pallet;
        _num_pallets_used := _num_pallets_used + _num_pallets;
        _pallet_fraction_remaining := _pallet_fraction_remaining + (_num_layers_remaining::NUMERIC / row.layers_per_pallet);

        IF _pallet_fraction_remaining >= 1 THEN
            _num_pallets_used := _num_pallets_used + FLOOR(_pallet_fraction_remaining);
            _pallet_fraction_remaining := _pallet_fraction_remaining - FLOOR(_pallet_fraction_remaining);
        END IF;
    END LOOP;

    -- Account for any remaining partial pallet
    IF _pallet_fraction_remaining > 0 THEN
        _num_pallets_used := _num_pallets_used + 1;
    END IF;

    RETURN _num_pallets_used;
END;

$$;


ALTER FUNCTION api.get_pallets_for_order(order_uuid uuid) OWNER TO postgres;

--
-- Name: get_product_by_slug(character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_product_by_slug(product_slug character varying) RETURNS api.product_detail_display
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN (SELECT * FROM api.get_product_detail(product_slug));
END;
$$;


ALTER FUNCTION api.get_product_by_slug(product_slug character varying) OWNER TO postgres;

--
-- Name: get_product_detail(character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_product_detail(product_slug character varying) RETURNS api.product_detail_display
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    result api.product_detail_display;
BEGIN
    WITH best_offer AS (
        SELECT
            pc.units_per_case,
            po.case_price_base,
            po.case_price_currency,
            pc.case_barcode,
            pc.cases_per_layer * pc.layers_per_pallet AS cases_per_pallet,
            po.moq_cases,
            po.country_of_origin,
            CASE
                WHEN pc.units_per_case > 0 THEN (po.case_price_base / pc.units_per_case)::DECIMAL(19,4)
                ELSE NULL
            END AS unit_price
        FROM dirac.product_offer po
        JOIN dirac.product p ON p.id = po.product_id
        JOIN dirac.product_case pc ON pc.id = po.product_case_id
        WHERE p.slug = product_slug
          AND po.is_active = TRUE
          AND p.show_on_web = TRUE
        ORDER BY po.case_price_base ASC
        LIMIT 1
    )
    SELECT
        p.id,
        p.slug,
        p.name,
        CASE WHEN p.barcode IS NOT NULL THEN dirac.to_gtin_14(p.barcode) ELSE NULL END as barcode,
        p.brand_id,
        b.name AS brand_name,
        img.uuid AS image_uuid,
        img.image_type::TEXT AS image_type,
        p.show_on_web,
        -- Web pricing fields
        p.web_unit_price,
        p.web_unit_price_currency,
        p.web_discount AS web_discount_id,
        p.web_discount_unit::VARCHAR(20),
        p.web_product_case_id,
        -- VAT field (ADDED)
        p.uk_vat_fraction,
        -- Product details
        pd.pack_size,
        pd.volume_ml,
        pd.weight_g,
        pd.shelf_life_days,
        pd.is_gluten_free,
        -- Tariff code (pick first one)
        tc.code AS tariff_code,
        tc.country AS tariff_code_country,
        -- Case information from web_product_case_id
        pc.units_per_case,
        pc.case_barcode,
        pc.cases_per_layer,
        pc.layers_per_pallet,
        -- Offer details from best offer
        bo.case_price_base AS case_price,
        bo.case_price_currency AS currency,
        bo.unit_price,
        bo.moq_cases,
        bo.country_of_origin
    INTO result
    FROM dirac.product p
    LEFT JOIN dirac.brand b ON p.brand_id = b.id
    LEFT JOIN dirac.image img ON img.id = p.image_id
    LEFT JOIN dirac.product_detail pd ON pd.product_id = p.id
    LEFT JOIN dirac.product_case pc ON pc.id = p.web_product_case_id
    LEFT JOIN dirac.product_tariff_classification ptc ON ptc.product_id = p.id
    LEFT JOIN dirac.tariff_code tc ON tc.id = ptc.tariff_code_id
    LEFT JOIN best_offer bo ON TRUE
    WHERE p.slug = product_slug
      AND p.show_on_web = TRUE
    LIMIT 1;

    RETURN result;
END;
$$;


ALTER FUNCTION api.get_product_detail(product_slug character varying) OWNER TO postgres;

--
-- Name: FUNCTION get_product_detail(product_slug character varying); Type: COMMENT; Schema: api; Owner: postgres
--

COMMENT ON FUNCTION api.get_product_detail(product_slug character varying) IS 'Returns product detail including uk_vat_fraction for API consumers (filters by show_on_web=TRUE)';


--
-- Name: get_product_listing(integer, integer, character varying, character varying, character varying, public.vector); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_product_listing(limit_val integer DEFAULT 100, offset_val integer DEFAULT 0, brand_name_filter character varying DEFAULT NULL::character varying, search_term character varying DEFAULT NULL::character varying, order_by character varying DEFAULT 'name'::character varying, search_embedding public.vector DEFAULT NULL::public.vector) RETURNS SETOF api.product_listing
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    -- If search_embedding is provided, use vector similarity search
    IF search_embedding IS NOT NULL THEN
        RETURN QUERY
        SELECT
            p.id,
            p.slug,
            p.name,
            b.name AS brand_name,
            p.barcode,
            img.uuid AS image_uuid,
            img.image_type::TEXT AS image_type,
            p.web_unit_price,
            p.web_unit_price_currency,
            p.web_discount_unit::VARCHAR(20),
            p.web_discount AS web_discount_id,
            pd.pack_size,
            pd.volume_ml,
            pd.weight_g,
            pc.units_per_case,
            pc.cases_per_layer,
            pc.layers_per_pallet,
            p.uk_vat_fraction
        FROM dirac.product p
        LEFT JOIN dirac.brand b ON p.brand_id = b.id
        LEFT JOIN dirac.image img ON img.id = p.image_id
        LEFT JOIN dirac.product_detail pd ON pd.product_id = p.id
        LEFT JOIN dirac.product_case pc ON pc.id = p.web_product_case_id
        WHERE
            p.show_on_web = TRUE
            AND (brand_name_filter IS NULL OR b.name = brand_name_filter)
        ORDER BY p.embedding <=> search_embedding  -- Cosine distance (ascending = most similar first)
        LIMIT limit_val
        OFFSET offset_val;
    ELSE
        -- Fallback to text search
        RETURN QUERY
        SELECT
            p.id,
            p.slug,
            p.name,
            b.name AS brand_name,
            p.barcode,
            img.uuid AS image_uuid,
            img.image_type::TEXT AS image_type,
            p.web_unit_price,
            p.web_unit_price_currency,
            p.web_discount_unit::VARCHAR(20),
            p.web_discount AS web_discount_id,
            pd.pack_size,
            pd.volume_ml,
            pd.weight_g,
            pc.units_per_case,
            pc.cases_per_layer,
            pc.layers_per_pallet,
            p.uk_vat_fraction
        FROM dirac.product p
        LEFT JOIN dirac.brand b ON p.brand_id = b.id
        LEFT JOIN dirac.image img ON img.id = p.image_id
        LEFT JOIN dirac.product_detail pd ON pd.product_id = p.id
        LEFT JOIN dirac.product_case pc ON pc.id = p.web_product_case_id
        WHERE
            p.show_on_web = TRUE
            AND (brand_name_filter IS NULL OR b.name = brand_name_filter)
            AND (search_term IS NULL OR
                 p.name ILIKE '%' || search_term || '%' OR
                 b.name ILIKE '%' || search_term || '%')
        ORDER BY
            CASE
                WHEN order_by = 'name' THEN p.name
                WHEN order_by = 'brand_name' THEN b.name || ' ' || p.name
                WHEN order_by = 'created_at' THEN p.created_at::TEXT
                ELSE p.name  -- default fallback
            END
        LIMIT limit_val
        OFFSET offset_val;
    END IF;
END;
$$;


ALTER FUNCTION api.get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector) OWNER TO postgres;

--
-- Name: get_stripe_customer_id(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_stripe_customer_id(p_user_id bigint) RETURNS character varying
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    v_stripe_customer_id VARCHAR(255);
BEGIN
    SELECT c.stripe_customer_id INTO v_stripe_customer_id
    FROM dirac.customer c
    JOIN auth.user u ON u.customer_id = c.id
    WHERE u.id = p_user_id;

    RETURN v_stripe_customer_id;
END;
$$;


ALTER FUNCTION api.get_stripe_customer_id(p_user_id bigint) OWNER TO postgres;

--
-- Name: get_tariff_codes(integer, integer, character, character varying, character varying, integer); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_tariff_codes(limit_val integer DEFAULT 100, offset_val integer DEFAULT 0, country_filter character DEFAULT NULL::bpchar, customs_territory_filter character varying DEFAULT NULL::character varying, search_term character varying DEFAULT NULL::character varying, depth_filter integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, code character varying, country character, customs_territory_code character varying, depth integer, description text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        tc.id,
        tc.code,
        tc.country,
        tc.customs_territory_code,
        tc.depth,
        tc.description
    FROM dirac.tariff_code tc
    WHERE
        (country_filter IS NULL OR tc.country = country_filter)
        AND (customs_territory_filter IS NULL OR tc.customs_territory_code = customs_territory_filter)
        AND (depth_filter IS NULL OR tc.depth = depth_filter)
        AND (search_term IS NULL OR
             tc.code ILIKE '%' || search_term || '%' OR
             tc.description ILIKE '%' || search_term || '%')
    ORDER BY tc.code, tc.country NULLS LAST
    LIMIT limit_val
    OFFSET offset_val;
END;
$$;


ALTER FUNCTION api.get_tariff_codes(limit_val integer, offset_val integer, country_filter character, customs_territory_filter character varying, search_term character varying, depth_filter integer) OWNER TO postgres;

--
-- Name: get_user_from_session(uuid); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_user_from_session(p_session_id uuid) RETURNS TABLE(id bigint, email text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		u.id,
		u.email::TEXT
	FROM auth.user u
	JOIN auth.web_session s ON s.user_id = u.id
	WHERE s.uuid = p_session_id
	  AND s.expires_at > NOW();
END;
$$;


ALTER FUNCTION api.get_user_from_session(p_session_id uuid) OWNER TO postgres;

--
-- Name: get_user_orders(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_user_orders(p_user_id bigint) RETURNS TABLE(order_uuid uuid, status dirac.order_status, created_at timestamp with time zone, placed_at timestamp with time zone, total_amount_excl_vat numeric, total_vat_amount numeric, total_amount_incl_vat numeric, currency character, item_count bigint)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		o.uuid,
		o.status,
		o.created_at,
		o.placed_at,
		o.total_amount_excl_vat,
		o.total_vat_amount,
		o.total_amount_incl_vat,
		o.currency,
		COUNT(oi.id)
	FROM dirac.order o
	LEFT JOIN dirac.order_item oi ON oi.order_id = o.id
	WHERE o.user_id = p_user_id
	  AND o.status != 'basket'  -- Don't show basket in order history
	GROUP BY o.id, o.uuid, o.status, o.created_at, o.placed_at, o.total_amount_excl_vat, o.total_vat_amount, o.total_amount_incl_vat, o.currency
	ORDER BY o.created_at DESC;
END;
$$;


ALTER FUNCTION api.get_user_orders(p_user_id bigint) OWNER TO postgres;

--
-- Name: get_user_profile(bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_user_profile(p_user_id bigint) RETURNS TABLE(id bigint, email text, customer_id bigint, created_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT
		u.id,
		u.email::TEXT,
		u.customer_id,
		u.created_at
	FROM auth.user u
	WHERE u.id = p_user_id;
END;
$$;


ALTER FUNCTION api.get_user_profile(p_user_id bigint) OWNER TO postgres;

--
-- Name: get_user_verification_status(text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_user_verification_status(_email text) RETURNS TABLE(verified boolean, has_pending_token boolean, can_resend boolean, wait_seconds integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  _verified BOOLEAN;
  _token UUID;
  _token_updated TIMESTAMPTZ;
  _can_resend BOOLEAN;
  _wait INT;
BEGIN
  SELECT email_verified, email_verification_token, updated_at
  INTO _verified, _token, _token_updated
  FROM auth.user
  WHERE email = _email;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'User not found' USING ERRCODE = 'P0001';
  END IF;

  -- Calculate if can resend (10 minutes passed)
  IF _token IS NOT NULL AND _token_updated > NOW() - INTERVAL '10 minutes' THEN
    _can_resend := FALSE;
    _wait := EXTRACT(EPOCH FROM (
      (_token_updated + INTERVAL '10 minutes') - NOW()
    ))::INT;
  ELSE
    _can_resend := TRUE;
    _wait := 0;
  END IF;

  RETURN QUERY SELECT
    _verified,
    _token IS NOT NULL,
    _can_resend,
    _wait;
END;
$$;


ALTER FUNCTION api.get_user_verification_status(_email text) OWNER TO postgres;

--
-- Name: get_vat_rates(); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.get_vat_rates() RETURNS TABLE(fraction numeric, name character varying, description text, stripe_tax_rate_id character varying)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
	RETURN QUERY
	SELECT vr.fraction, vr.name, vr.description, vr.stripe_tax_rate_id
	FROM dirac.vat_rate vr
	ORDER BY vr.fraction DESC;  -- 20%, 5%, 0% (descending for admin UI)
END;
$$;


ALTER FUNCTION api.get_vat_rates() OWNER TO postgres;

--
-- Name: FUNCTION get_vat_rates(); Type: COMMENT; Schema: api; Owner: postgres
--

COMMENT ON FUNCTION api.get_vat_rates() IS 'Returns all VAT rates with descriptions and Stripe tax rate IDs. Used by admin UI for dropdowns and Stripe integration for checkout.';


--
-- Name: is_session_valid(uuid, inet, text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.is_session_valid(_uuid uuid, _ip inet, _user_agent text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
  DECLARE
      _session_valid BOOLEAN;
  BEGIN
      SELECT EXISTS (
          SELECT 1
          FROM auth.web_session
          WHERE uuid = _uuid
          AND ip = _ip
          AND user_agent = _user_agent
          AND expires_at > NOW()
      ) INTO _session_valid;

      RETURN _session_valid;
  END;
$$;


ALTER FUNCTION api.is_session_valid(_uuid uuid, _ip inet, _user_agent text) OWNER TO postgres;

--
-- Name: login(text, text, inet, text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.login(_email text, _password text, _ip inet, _user_agent text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  _uid          BIGINT;
  _hash         TEXT;
  _ok           BOOLEAN;
  _uuid         UUID;
  _dummy_hash   TEXT := '$argon2id$v=19$m=65536,t=3,p=4$p1xepijE7AcFb1mAUkn7wA$gXH7+03YO9EE9uVJ/i6VzSEk5GjhznJEiwAQRCtHNJE';
BEGIN

	-- email is unique
	SELECT id,password_hash INTO _uid,_hash FROM auth.user WHERE email=_email;

	-- Always perform password verification to prevent timing attacks
	IF _uid IS NULL THEN
		_ok := auth.verify_password(_password, _dummy_hash);
		RAISE EXCEPTION 'Invalid credentials'
			USING ERRCODE = 'P0001'; -- RaiseError: business logic error
	END IF;
	_ok := auth.verify_password(_password, _hash);
	IF NOT _ok THEN
		RAISE EXCEPTION 'Invalid credentials'
			USING ERRCODE = 'P0001'; -- RaiseError: business logic error
	END IF;

	_uuid := gen_random_uuid();
	INSERT INTO auth.web_session (uuid, user_id,ip, user_agent,expires_at)
	VALUES (_uuid,_uid,_ip, _user_agent,NOW() + INTERVAL '5 hours');

	-- Update last_login timestamp using clock_timestamp() for real-time accuracy
	UPDATE auth.user SET last_login = clock_timestamp() WHERE id = _uid;
	RETURN _uuid;
END;
$_$;


ALTER FUNCTION api.login(_email text, _password text, _ip inet, _user_agent text) OWNER TO postgres;

--
-- Name: mark_order_as_paid(uuid, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.mark_order_as_paid(p_order_uuid uuid, p_session_id character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE dirac.order
    SET status = 'placed',
        stripe_checkout_session_id = p_session_id,
        paid_at = NOW(),
        placed_at = NOW()
    WHERE uuid = p_order_uuid
      AND status = 'basket';  -- Idempotent: only update if still in basket
END;
$$;


ALTER FUNCTION api.mark_order_as_paid(p_order_uuid uuid, p_session_id character varying) OWNER TO postgres;

--
-- Name: remove_from_basket(bigint, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.remove_from_basket(p_user_id bigint, p_product_slug character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_order_id BIGINT;
	v_product_case_id BIGINT;
BEGIN
	-- Get product case ID from web product case
	SELECT web_product_case_id INTO v_product_case_id
	FROM dirac.product
	WHERE slug = p_product_slug AND show_on_web = TRUE;

	IF v_product_case_id IS NULL THEN
		RAISE EXCEPTION 'Product not found or not available'
			USING ERRCODE = 'P0002';
	END IF;

	-- Get active basket
	SELECT o.id INTO v_order_id
	FROM dirac.order o
	WHERE o.user_id = p_user_id
	  AND o.status = 'basket'
	ORDER BY o.created_at DESC
	LIMIT 1;

	IF v_order_id IS NULL THEN
		RAISE EXCEPTION 'No active basket found'
			USING ERRCODE = 'P0002';
	END IF;

	DELETE FROM dirac.order_item
	WHERE order_id = v_order_id
	  AND product_case_id = v_product_case_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Product not in basket'
			USING ERRCODE = 'P0002';
	END IF;
END;
$$;


ALTER FUNCTION api.remove_from_basket(p_user_id bigint, p_product_slug character varying) OWNER TO postgres;

--
-- Name: save_customer_shipping_info(bigint, bigint, bigint, character varying, text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.save_customer_shipping_info(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint, p_vat_number character varying DEFAULT NULL::character varying, p_delivery_instructions text DEFAULT NULL::text) RETURNS TABLE(customer_id bigint, email text, vat_number character varying, stripe_customer_id character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_customer_id BIGINT;
    v_user_email TEXT;
    v_vat_number VARCHAR(50);
    v_stripe_customer_id VARCHAR(255);
BEGIN
    -- Get customer ID and email from user
    SELECT u.customer_id, u.email INTO v_customer_id, v_user_email
    FROM auth.user u
    WHERE u.id = p_user_id;

    -- Auto-create customer if user doesn't have one
    IF v_customer_id IS NULL THEN
        -- Check if customer already exists with this email
        SELECT c.id INTO v_customer_id
        FROM dirac.customer c
        WHERE c.email = v_user_email;

        -- Create customer if doesn't exist
        IF v_customer_id IS NULL THEN
            INSERT INTO dirac.customer (name, email, embedding)
            VALUES (v_user_email, v_user_email, array_fill(0, ARRAY[768])::vector(768))
            RETURNING id INTO v_customer_id;
        END IF;

        -- Link customer to user
        UPDATE auth.user
        SET customer_id = v_customer_id
        WHERE id = p_user_id;
    END IF;

    -- Update customer addresses, VAT, and default delivery instructions
    UPDATE dirac.customer c
    SET
        shipping_location_id = COALESCE(p_shipping_location_id, c.shipping_location_id),
        billing_location_id = COALESCE(p_billing_location_id, c.billing_location_id),
        vat_number = COALESCE(p_vat_number, c.vat_number),
        default_delivery_instructions = COALESCE(p_delivery_instructions, c.default_delivery_instructions)
    WHERE c.id = v_customer_id
    RETURNING c.vat_number, c.stripe_customer_id
    INTO v_vat_number, v_stripe_customer_id;

    -- Update basket order with shipping/billing addresses and delivery instructions
    UPDATE dirac.order o
    SET
        shipping_address_id = COALESCE(p_shipping_location_id, o.shipping_address_id),
        billing_address_id = COALESCE(p_billing_location_id, o.billing_address_id),
        delivery_instructions = COALESCE(p_delivery_instructions, o.delivery_instructions),
        updated_at = CURRENT_TIMESTAMP
    WHERE o.user_id = p_user_id
      AND o.status = 'basket';

    -- Return all the data needed for Stripe sync
    RETURN QUERY
    SELECT v_customer_id, v_user_email, v_vat_number, v_stripe_customer_id;
END;
$$;


ALTER FUNCTION api.save_customer_shipping_info(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint, p_vat_number character varying, p_delivery_instructions text) OWNER TO postgres;

--
-- Name: search_brands(public.vector, integer); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.search_brands(p_embedding public.vector, p_limit integer DEFAULT 10) RETURNS TABLE(id bigint, name character varying, owner_supplier_id bigint, similarity double precision)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        b.id,
        b.name,
        b.owner_supplier_id,
        1 - (b.embedding <=> p_embedding) as similarity  -- Cosine similarity (1 - cosine distance)
    FROM dirac.brand b
    ORDER BY b.embedding <=> p_embedding  -- Order by cosine distance (ascending)
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION api.search_brands(p_embedding public.vector, p_limit integer) OWNER TO postgres;

--
-- Name: store_stripe_session_id(uuid, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.store_stripe_session_id(p_order_uuid uuid, p_session_id character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE dirac.order
    SET stripe_checkout_session_id = p_session_id
    WHERE uuid = p_order_uuid;
END;
$$;


ALTER FUNCTION api.store_stripe_session_id(p_order_uuid uuid, p_session_id character varying) OWNER TO postgres;

--
-- Name: submit_demand_request(character varying, character varying, character varying, dirac.product_quantity, character varying, character varying, character varying, character, text, character varying, text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_business_registration_number character varying DEFAULT NULL::character varying, p_website_url character varying DEFAULT NULL::character varying, p_phone_number character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_customer_notes text DEFAULT NULL::text, p_brand_name character varying DEFAULT NULL::character varying, p_request_notes text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_submission_id BIGINT;
BEGIN
	-- Validate inputs
	IF p_customer_name IS NULL OR trim(p_customer_name) = '' THEN
		RAISE EXCEPTION 'Customer name is required'
			USING ERRCODE = 'P0004';
	END IF;

	IF p_request_type NOT IN ('product', 'brand') THEN
		RAISE EXCEPTION 'Request type must be "product" or "brand"'
			USING ERRCODE = 'P0004';
	END IF;

	IF p_item_name IS NULL OR trim(p_item_name) = '' THEN
		RAISE EXCEPTION 'Item name is required'
			USING ERRCODE = 'P0004';
	END IF;

	-- Insert submission
	INSERT INTO dirac.demand_request_submission (
		customer_name,
		business_registration_number,
		website_url,
		phone_number,
		country_code,
		customer_notes,
		request_type,
		item_name,
		brand_name,
		quantity,
		request_notes,
		status
	) VALUES (
		trim(p_customer_name),
		NULLIF(trim(p_business_registration_number), ''),
		NULLIF(trim(p_website_url), ''),
		NULLIF(trim(p_phone_number), ''),
		p_country_code,
		NULLIF(trim(p_customer_notes), ''),
		p_request_type,
		trim(p_item_name),
		NULLIF(trim(p_brand_name), ''),
		p_quantity,
		NULLIF(trim(p_request_notes), ''),
		'pending'
	)
	RETURNING id INTO v_submission_id;

	RETURN v_submission_id;
END;
$$;


ALTER FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) OWNER TO postgres;

--
-- Name: submit_demand_request(character varying, character varying, character varying, dirac.product_quantity, character varying, character varying, character varying, character varying, character, text, character varying, text); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying DEFAULT NULL::character varying, p_business_registration_number character varying DEFAULT NULL::character varying, p_website_url character varying DEFAULT NULL::character varying, p_phone_number character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_customer_notes text DEFAULT NULL::text, p_brand_name character varying DEFAULT NULL::character varying, p_request_notes text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_submission_id BIGINT;
BEGIN
	-- Validate inputs
	IF p_customer_name IS NULL OR trim(p_customer_name) = '' THEN
		RAISE EXCEPTION 'Customer name is required'
			USING ERRCODE = 'P0004';
	END IF;

	IF p_request_type NOT IN ('product', 'brand') THEN
		RAISE EXCEPTION 'Request type must be "product" or "brand"'
			USING ERRCODE = 'P0004';
	END IF;

	IF p_item_name IS NULL OR trim(p_item_name) = '' THEN
		RAISE EXCEPTION 'Item name is required'
			USING ERRCODE = 'P0004';
	END IF;

	-- Insert submission
	INSERT INTO dirac.demand_request_submission (
		customer_name,
		email,
		business_registration_number,
		website_url,
		phone_number,
		country_code,
		customer_notes,
		request_type,
		item_name,
		brand_name,
		quantity,
		request_notes,
		status
	) VALUES (
		trim(p_customer_name),
		NULLIF(trim(p_email), ''),
		NULLIF(trim(p_business_registration_number), ''),
		NULLIF(trim(p_website_url), ''),
		NULLIF(trim(p_phone_number), ''),
		p_country_code,
		NULLIF(trim(p_customer_notes), ''),
		p_request_type,
		trim(p_item_name),
		NULLIF(trim(p_brand_name), ''),
		p_quantity,
		NULLIF(trim(p_request_notes), ''),
		'pending'
	)
	RETURNING id INTO v_submission_id;

	RETURN v_submission_id;
END;
$$;


ALTER FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) OWNER TO postgres;

--
-- Name: submit_demand_request(character varying, character varying, character varying, dirac.product_quantity, character varying, character varying, character varying, character varying, character, text, character varying, character varying, text, numeric, character); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying DEFAULT NULL::character varying, p_business_registration_number character varying DEFAULT NULL::character varying, p_website_url character varying DEFAULT NULL::character varying, p_phone_number character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_customer_notes text DEFAULT NULL::text, p_brand_name character varying DEFAULT NULL::character varying, p_barcode character varying DEFAULT NULL::character varying, p_request_notes text DEFAULT NULL::text, p_target_unit_price numeric DEFAULT NULL::numeric, p_target_unit_price_currency character DEFAULT NULL::bpchar) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_submission_id BIGINT;
BEGIN
	-- Validate inputs
	IF p_customer_name IS NULL OR trim(p_customer_name) = '' THEN
		RAISE EXCEPTION 'Customer name is required'
			USING ERRCODE = 'P0004';
	END IF;

	IF p_request_type NOT IN ('product', 'brand') THEN
		RAISE EXCEPTION 'Request type must be "product" or "brand"'
			USING ERRCODE = 'P0004';
	END IF;

	IF p_item_name IS NULL OR trim(p_item_name) = '' THEN
		RAISE EXCEPTION 'Item name is required'
			USING ERRCODE = 'P0004';
	END IF;

	-- Insert submission
	INSERT INTO dirac.demand_request_submission (
		customer_name,
		email,
		business_registration_number,
		website_url,
		phone_number,
		country_code,
		customer_notes,
		request_type,
		item_name,
		brand_name,
		barcode,
		quantity,
		request_notes,
		target_unit_price,
		target_unit_price_currency,
		status
	) VALUES (
		trim(p_customer_name),
		NULLIF(trim(p_email), ''),
		NULLIF(trim(p_business_registration_number), ''),
		NULLIF(trim(p_website_url), ''),
		NULLIF(trim(p_phone_number), ''),
		p_country_code,
		NULLIF(trim(p_customer_notes), ''),
		p_request_type,
		trim(p_item_name),
		NULLIF(trim(p_brand_name), ''),
		NULLIF(trim(p_barcode), ''),
		p_quantity,
		NULLIF(trim(p_request_notes), ''),
		p_target_unit_price,
		p_target_unit_price_currency,
		'pending'
	)
	RETURNING id INTO v_submission_id;

	RETURN v_submission_id;
END;
$$;


ALTER FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_barcode character varying, p_request_notes text, p_target_unit_price numeric, p_target_unit_price_currency character) OWNER TO postgres;

--
-- Name: update_basket_item_quantity(bigint, character varying, numeric); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.update_basket_item_quantity(p_user_id bigint, p_product_slug character varying, p_new_case_quantity numeric) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_order_id BIGINT;
	v_product_case_id BIGINT;
BEGIN
	IF p_new_case_quantity <= 0 THEN
		RAISE EXCEPTION 'Case quantity must be positive'
			USING ERRCODE = 'P0004';
	END IF;

	-- Get product case ID from web product case
	SELECT web_product_case_id INTO v_product_case_id
	FROM dirac.product
	WHERE slug = p_product_slug AND show_on_web = TRUE;

	IF v_product_case_id IS NULL THEN
		RAISE EXCEPTION 'Product not found or not available'
			USING ERRCODE = 'P0002';
	END IF;

	-- Get active basket
	SELECT o.id INTO v_order_id
	FROM dirac.order o
	WHERE o.user_id = p_user_id
	  AND o.status = 'basket'
	ORDER BY o.created_at DESC
	LIMIT 1;

	IF v_order_id IS NULL THEN
		RAISE EXCEPTION 'No active basket found'
			USING ERRCODE = 'P0002';
	END IF;

	UPDATE dirac.order_item
	SET case_quantity = p_new_case_quantity
	WHERE order_id = v_order_id
	  AND product_case_id = v_product_case_id;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Product not in basket'
			USING ERRCODE = 'P0002';
	END IF;
END;
$$;


ALTER FUNCTION api.update_basket_item_quantity(p_user_id bigint, p_product_slug character varying, p_new_case_quantity numeric) OWNER TO postgres;

--
-- Name: update_customer_addresses(bigint, bigint, bigint); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.update_customer_addresses(p_user_id bigint, p_shipping_location_id bigint DEFAULT NULL::bigint, p_billing_location_id bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_customer_id BIGINT;
	v_user_email TEXT;
BEGIN
	-- Get customer ID and email from user
	SELECT customer_id, email INTO v_customer_id, v_user_email
	FROM auth.user
	WHERE id = p_user_id;

	-- Auto-create customer if user doesn't have one
	IF v_customer_id IS NULL THEN
		-- Check if customer already exists with this email
		SELECT id INTO v_customer_id
		FROM dirac.customer
		WHERE email = v_user_email;

		-- Create customer if doesn't exist
		IF v_customer_id IS NULL THEN
			INSERT INTO dirac.customer (name, email, embedding)
			VALUES (v_user_email, v_user_email, array_fill(0, ARRAY[768])::vector(768))
			RETURNING id INTO v_customer_id;
		END IF;

		-- Link customer to user
		UPDATE auth.user
		SET customer_id = v_customer_id
		WHERE id = p_user_id;
	END IF;

	-- Validate shipping location exists if provided
	IF p_shipping_location_id IS NOT NULL THEN
		IF NOT EXISTS (
			SELECT 1 FROM dirac.location WHERE id = p_shipping_location_id
		) THEN
			RAISE EXCEPTION 'Invalid shipping location ID'
				USING ERRCODE = 'P0002';
		END IF;
	END IF;

	-- Validate billing location exists if provided
	IF p_billing_location_id IS NOT NULL THEN
		IF NOT EXISTS (
			SELECT 1 FROM dirac.location WHERE id = p_billing_location_id
		) THEN
			RAISE EXCEPTION 'Invalid billing location ID'
				USING ERRCODE = 'P0002';
		END IF;
	END IF;

	-- Update customer addresses
	UPDATE dirac.customer
	SET
		shipping_location_id = COALESCE(p_shipping_location_id, shipping_location_id),
		billing_location_id = COALESCE(p_billing_location_id, billing_location_id)
	WHERE id = v_customer_id;
END;
$$;


ALTER FUNCTION api.update_customer_addresses(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint) OWNER TO postgres;

--
-- Name: update_customer_vat_number(bigint, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.update_customer_vat_number(p_customer_id bigint, p_vat_number character varying) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE dirac.customer
    SET vat_number = p_vat_number
    WHERE id = p_customer_id;

    RETURN FOUND;
END;
$$;


ALTER FUNCTION api.update_customer_vat_number(p_customer_id bigint, p_vat_number character varying) OWNER TO postgres;

--
-- Name: update_order_status_after_payment(uuid, dirac.order_status); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.update_order_status_after_payment(p_order_uuid uuid, p_new_status dirac.order_status) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_order_id BIGINT;
BEGIN
    -- Get order ID from UUID
    SELECT id INTO v_order_id
    FROM dirac.order
    WHERE uuid = p_order_uuid;

    IF v_order_id IS NULL THEN
        RAISE EXCEPTION 'Order not found' USING ERRCODE = 'P0002';
    END IF;

    UPDATE dirac.order
    SET
        status = p_new_status,
        placed_at = CASE WHEN p_new_status = 'placed' THEN CURRENT_TIMESTAMP ELSE placed_at END,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = v_order_id;
END;
$$;


ALTER FUNCTION api.update_order_status_after_payment(p_order_uuid uuid, p_new_status dirac.order_status) OWNER TO postgres;

--
-- Name: update_payment_status(character varying, character varying, character varying, character varying, text, jsonb); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.update_payment_status(p_stripe_payment_intent_id character varying, p_status character varying, p_payment_method character varying DEFAULT NULL::character varying, p_stripe_status character varying DEFAULT NULL::character varying, p_failure_reason text DEFAULT NULL::text, p_metadata jsonb DEFAULT NULL::jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE dirac.payment
    SET
        status = p_status,
        payment_method = COALESCE(p_payment_method, payment_method),
        stripe_status = COALESCE(p_stripe_status, stripe_status),
        failure_reason = p_failure_reason,
        metadata = COALESCE(p_metadata, metadata),
        updated_at = CURRENT_TIMESTAMP
    WHERE stripe_payment_intent_id = p_stripe_payment_intent_id;
END;
$$;


ALTER FUNCTION api.update_payment_status(p_stripe_payment_intent_id character varying, p_status character varying, p_payment_method character varying, p_stripe_status character varying, p_failure_reason text, p_metadata jsonb) OWNER TO postgres;

--
-- Name: upsert_stripe_customer_id(bigint, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.upsert_stripe_customer_id(p_user_id bigint, p_stripe_customer_id character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE dirac.customer c
    SET stripe_customer_id = p_stripe_customer_id,
        stripe_sync_status = 'synced',
        stripe_synced_at = NOW()
    FROM auth.user u
    WHERE u.customer_id = c.id
      AND u.id = p_user_id;
END;
$$;


ALTER FUNCTION api.upsert_stripe_customer_id(p_user_id bigint, p_stripe_customer_id character varying) OWNER TO postgres;

--
-- Name: upsert_stripe_tax_rate_id(numeric, character varying); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
	UPDATE dirac.vat_rate
	SET stripe_tax_rate_id = p_stripe_tax_rate_id,
	    updated_at = CURRENT_TIMESTAMP
	WHERE fraction = p_fraction;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'VAT rate with fraction % not found', p_fraction
			USING ERRCODE = 'P0002';
	END IF;
END;
$$;


ALTER FUNCTION api.upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying) OWNER TO postgres;

--
-- Name: FUNCTION upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying); Type: COMMENT; Schema: api; Owner: postgres
--

COMMENT ON FUNCTION api.upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying) IS 'Updates the Stripe tax rate ID for a given VAT fraction after creating it in Stripe';


--
-- Name: verify_email_token(uuid); Type: FUNCTION; Schema: api; Owner: postgres
--

CREATE FUNCTION api.verify_email_token(_token uuid) RETURNS TABLE(success boolean, email text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  _user_id BIGINT;
  _user_email TEXT;
  _expires_at TIMESTAMPTZ;
BEGIN
  -- Find user by token
  SELECT id, auth.user.email, email_verification_expires_at
  INTO _user_id, _user_email, _expires_at
  FROM auth.user
  WHERE email_verification_token = _token;

  -- Token not found
  IF _user_id IS NULL THEN
    RETURN QUERY SELECT FALSE, NULL::TEXT;
    RETURN;
  END IF;

  -- Token expired
  IF _expires_at < NOW() THEN
    RETURN QUERY SELECT FALSE, _user_email;
    RETURN;
  END IF;

  -- Mark as verified and clear token
  UPDATE auth.user
  SET email_verified = TRUE,
      email_verification_token = NULL,
      email_verification_expires_at = NULL,
      updated_at = NOW()
  WHERE id = _user_id;

  RETURN QUERY SELECT TRUE, _user_email;
END;
$$;


ALTER FUNCTION api.verify_email_token(_token uuid) OWNER TO postgres;

--
-- Name: hash_password(text); Type: FUNCTION; Schema: auth; Owner: postgres
--

CREATE FUNCTION auth.hash_password(password text) RETURNS text
    LANGUAGE plpython3u STRICT
    AS $$
	# strict does null checks

	# use SD for from argon2 import PasswordHasher
	imports = ['PasswordHasher']
	if any(k not in SD for k in imports):
		from argon2 import PasswordHasher
		SD['PasswordHasher'] = PasswordHasher

	return SD['PasswordHasher']().hash(password)
$$;


ALTER FUNCTION auth.hash_password(password text) OWNER TO postgres;

--
-- Name: verify_password(text, text); Type: FUNCTION; Schema: auth; Owner: postgres
--

CREATE FUNCTION auth.verify_password(password text, hash text) RETURNS boolean
    LANGUAGE plpython3u IMMUTABLE STRICT
    AS $$
	# strict does null checks

	# use SD for from argon2.exceptions import VerifyMismatchError, InvalidHashError
	# use SD for from argon2 import PasswordHasher
	imports = ['PasswordHasher','VerifyMismatchError','InvalidHashError']
	if any(k not in SD for k in imports):
		from argon2 import PasswordHasher
		SD['PasswordHasher'] = PasswordHasher
		from argon2.exceptions import VerifyMismatchError, InvalidHashError
		SD['VerifyMismatchError'] = VerifyMismatchError
		SD['InvalidHashError'] = InvalidHashError
	try:
		SD['PasswordHasher']().verify(hash=hash,password=password)
	except (SD['VerifyMismatchError'], SD['InvalidHashError']):
		return False
	return True
$$;


ALTER FUNCTION auth.verify_password(password text, hash text) OWNER TO postgres;

--
-- Name: add_manufacturer(character varying); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.add_manufacturer(manufacturer_name character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    manufacturer_id BIGINT;
BEGIN
    INSERT INTO dirac.manufacturer (name)
    VALUES (manufacturer_name)
    ON CONFLICT (name) DO NOTHING
    RETURNING id INTO manufacturer_id;

    -- If no ID was returned (conflict occurred), get the existing ID
    IF manufacturer_id IS NULL THEN
        SELECT id INTO manufacturer_id
        FROM dirac.manufacturer
        WHERE name = manufacturer_name;
    END IF;

    RETURN manufacturer_id;
END;
$$;


ALTER FUNCTION dirac.add_manufacturer(manufacturer_name character varying) OWNER TO postgres;

--
-- Name: add_supplier(character varying, public.vector); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.add_supplier(supplier_name character varying, supplier_embedding public.vector) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    supplier_id BIGINT;
BEGIN
    INSERT INTO dirac.supplier (name, embedding)
    VALUES (supplier_name, supplier_embedding)
    ON CONFLICT (name) DO NOTHING
    RETURNING id INTO supplier_id;

    -- If no ID was returned (conflict occurred), get the existing ID
    IF supplier_id IS NULL THEN
        SELECT id INTO supplier_id
        FROM dirac.supplier
        WHERE name = supplier_name;
    END IF;

    RETURN supplier_id;
END;
$$;


ALTER FUNCTION dirac.add_supplier(supplier_name character varying, supplier_embedding public.vector) OWNER TO postgres;

--
-- Name: bulk_upsert_products(dirac.product_input[]); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.bulk_upsert_products(products dirac.product_input[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
	-- raise with the no data found exception code
	IF products IS NULL OR array_length(products, 1) IS NULL OR array_length(products, 1) = 0 THEN
		RAISE EXCEPTION 'Products array cannot be null or empty' USING ERRCODE='P0002';
	END IF;

	RAISE NOTICE 'Starting bulk_upsert_products with % products', array_length(products, 1);

	CREATE TEMP TABLE product_input_table AS
	SELECT
		p.product_id,
		p.name,
		CASE WHEN p.barcode IS NOT NULL THEN dirac.to_gtin_14(p.barcode) ELSE NULL END as barcode,
		p.image_id,
		p.brand_id,
		p.brand_name,
		p.brand_embedding,
		p.product_embedding,
		COALESCE(p.uk_vat_fraction, 0.20) as uk_vat_fraction,
		-- Product detail fields
		p.pack_size,
		dirac.to_ml(p.volume)::DECIMAL(19,4) as volume_ml,
		p.shelf_life_days,
		p.is_gluten_free,
		REGEXP_REPLACE(p.tariff_code, '[^0-9]', '', 'g') as tariff_code,
		p.tariff_code_country,
		-- Product offer fields
		p.sku,
		p.supplier_id,
		COALESCE(p.discount_function_id, 1) as discount_function_id,
		COALESCE(p.brand_discount_function_id, 1) as brand_discount_function_id,
		p.case_price_base,
		p.case_price_currency,
		p.country_of_origin,
		p.eu_goods_tier,
		p.moq_cases,
		COALESCE(p.is_offer_active, TRUE) as is_offer_active,
		-- Product case fields
		p.units_per_case,
		CASE WHEN p.case_barcode IS NOT NULL THEN dirac.to_gtin_14(p.case_barcode) ELSE NULL END as case_barcode,
		p.cases_per_layer,
		p.layers_per_pallet,
		dirac.to_kg(p.case_weight) as case_weight_kg,
		dirac.to_cm(p.case_height) as case_height_cm,
		dirac.to_cm(p.case_width) as case_width_cm,
		dirac.to_cm(p.case_length) as case_length_cm,
		NULL::BIGINT as product_case_id  -- Will be populated after product_case insert
	FROM UNNEST(products) AS p;

	-- Insert barcodes (both product and case barcodes)
	INSERT INTO dirac.barcode (gtin_14)
	SELECT DISTINCT barcode FROM product_input_table WHERE barcode IS NOT NULL
	UNION
	SELECT DISTINCT case_barcode FROM product_input_table WHERE case_barcode IS NOT NULL
	ON CONFLICT (gtin_14) DO NOTHING;

	RAISE NOTICE 'Completed inserting barcodes';

	-- Insert new brand names with embeddings
	WITH brand_slugs AS (
	SELECT DISTINCT ON (brand_name) brand_name, dirac.generate_slug(brand_name) as slug, brand_embedding
	FROM product_input_table
	WHERE brand_name IS NOT NULL AND brand_id IS NULL AND brand_embedding IS NOT NULL
	)
	INSERT INTO dirac.brand (name, slug, embedding)
	SELECT DISTINCT ON (slug) brand_name, slug, brand_embedding
	FROM brand_slugs
	ON CONFLICT (slug) DO UPDATE SET
		embedding = EXCLUDED.embedding;

	RAISE NOTICE 'Completed inserting brands';

	-- Update temp table with resolved brand_ids
	UPDATE product_input_table p
	SET brand_id = b.id
	FROM dirac.brand b
	WHERE dirac.generate_slug(p.brand_name) = b.slug
	AND p.brand_id IS NULL;

	RAISE NOTICE 'Completed updating brand_ids in temp table';


	-- UPDATE products by ID (when product_id is provided)
	-- Direct update - no need to preserve old values since we're updating by explicit ID
	UPDATE dirac.product p
	SET
	    name = pit.name,
	    brand_id = pit.brand_id,
	    barcode = COALESCE(pit.barcode, p.barcode),  -- Update barcode if provided
	    image_id = COALESCE(pit.image_id, p.image_id),  -- Update image if provided
	    embedding = COALESCE(pit.product_embedding, p.embedding),  -- Keep old embedding if not provided
	    uk_vat_fraction = COALESCE(pit.uk_vat_fraction,p.uk_vat_fraction)
	FROM product_input_table pit
	WHERE pit.product_id IS NOT NULL
	  AND pit.product_id = p.id;

	RAISE NOTICE 'Completed updating products WITH ids';

	-- Insert/update products WITH barcodes and no ids (deduplicated by barcode to avoid conflict)
	INSERT INTO dirac.product (name, brand_id, image_id, barcode, embedding, uk_vat_fraction)
	SELECT DISTINCT ON (barcode) name, brand_id, image_id, barcode, product_embedding, uk_vat_fraction
	FROM product_input_table
	WHERE barcode IS NOT NULL AND product_embedding IS NOT NULL AND product_id IS NULL
	ORDER BY barcode, ctid DESC  -- Use ctid DESC to get the last row for each barcode
	ON CONFLICT (barcode) DO UPDATE SET
		name = EXCLUDED.name,  -- Trigger will regenerate slug if name changes
		brand_id = COALESCE(EXCLUDED.brand_id, dirac.product.brand_id),  -- Preserve brand if not provided
		image_id = COALESCE(EXCLUDED.image_id, dirac.product.image_id),  -- Update image if provided
		embedding = EXCLUDED.embedding,  -- IMPORTANT: Must provide new embedding if name changed
		uk_vat_fraction = COALESCE(EXCLUDED.uk_vat_fraction, dirac.product.uk_vat_fraction);

	RAISE NOTICE 'Completed inserting/updating products WITH barcodes';

	-- Insert/update products WITHOUT barcodes (use slug for conflict)
	INSERT INTO dirac.product (name, brand_id, image_id, barcode, slug, embedding, uk_vat_fraction)
	SELECT DISTINCT ON (dirac.generate_slug(name)) name, brand_id, image_id, barcode, dirac.generate_slug(name), product_embedding, uk_vat_fraction
	FROM product_input_table
	WHERE barcode IS NULL AND name IS NOT NULL AND product_embedding IS NOT NULL AND product_id IS NULL
	ON CONFLICT (slug) DO UPDATE SET
		name = EXCLUDED.name,
		brand_id = COALESCE(EXCLUDED.brand_id, dirac.product.brand_id),  -- Preserve brand if not provided
		image_id = COALESCE(EXCLUDED.image_id, dirac.product.image_id),  -- Update image if provided
		embedding = EXCLUDED.embedding,  -- IMPORTANT: Must provide new embedding if name changed
		uk_vat_fraction = EXCLUDED.uk_vat_fraction;

	RAISE NOTICE 'Completed inserting/updating products WITHOUT barcodes';

	-- Update temp table with product_ids from inserted/existing products
	UPDATE product_input_table t
	SET product_id = p.id
	FROM dirac.product p
	WHERE (t.barcode IS NOT NULL AND t.barcode = p.barcode)
	   OR (t.barcode IS NULL AND dirac.generate_slug(t.name) = p.slug);

	RAISE NOTICE 'Completed updating product_ids in temp table';

	-- Insert/update product details (now includes volume_ml and pack_size)
	INSERT INTO dirac.product_detail (product_id, volume_ml, pack_size, shelf_life_days, is_gluten_free)
	SELECT DISTINCT ON (product_id) product_id, volume_ml, pack_size, shelf_life_days, is_gluten_free
	FROM product_input_table
	WHERE product_id IS NOT NULL
		AND (volume_ml IS NOT NULL OR pack_size IS NOT NULL OR shelf_life_days IS NOT NULL OR is_gluten_free IS NOT NULL)
	ON CONFLICT (product_id) DO UPDATE SET
		volume_ml = COALESCE(EXCLUDED.volume_ml, product_detail.volume_ml),
		pack_size = COALESCE(EXCLUDED.pack_size, product_detail.pack_size),
		shelf_life_days = COALESCE(EXCLUDED.shelf_life_days, product_detail.shelf_life_days),
		is_gluten_free = COALESCE(EXCLUDED.is_gluten_free, product_detail.is_gluten_free);

	RAISE NOTICE 'Completed inserting product details';

	-- Insert tariff classifications
	INSERT INTO dirac.product_tariff_classification (tariff_code_id, product_id)
	SELECT tc.id, pit.product_id
	FROM product_input_table pit
	JOIN dirac.tariff_code tc ON pit.tariff_code = tc.code AND pit.tariff_code_country = tc.country
	WHERE pit.product_id IS NOT NULL AND pit.tariff_code IS NOT NULL
	ON CONFLICT DO NOTHING;

	RAISE NOTICE 'Completed inserting tariff classifications';

	-- Insert product cases (before product_offer since they reference it)
	INSERT INTO dirac.product_case (
		product_id, case_barcode, weight_kg, height_cm, width_cm, length_cm,
		units_per_case, cases_per_layer, layers_per_pallet
	)
	SELECT DISTINCT ON (product_id, units_per_case, case_barcode)
		product_id, case_barcode, case_weight_kg, case_height_cm, case_width_cm, case_length_cm,
		units_per_case, cases_per_layer, layers_per_pallet
	FROM product_input_table
	WHERE product_id IS NOT NULL
		AND units_per_case IS NOT NULL
	-- No conflict resolution - multiple cases per product are allowed
	ON CONFLICT DO NOTHING;

	RAISE NOTICE 'Completed inserting product cases';

	-- Update temp table with product_case_id
	-- Match on product_id + units_per_case + case_barcode
	UPDATE product_input_table pit
	SET product_case_id = (
		SELECT pc.id
		FROM dirac.product_case pc
		WHERE pc.product_id = pit.product_id
			AND pc.units_per_case = pit.units_per_case
			AND (pc.case_barcode = pit.case_barcode OR (pc.case_barcode IS NULL AND pit.case_barcode IS NULL))
		LIMIT 1
	)
	WHERE pit.units_per_case IS NOT NULL;

	RAISE NOTICE 'Completed updating product_case_ids in temp table';

	-- Insert product offers (now using product_case_id)
	INSERT INTO dirac.product_offer (
		sku, supplier_id, product_id, product_case_id, case_price_base, case_price_currency,
		country_of_origin, moq_cases, eu_goods_tier,
		product_level_discount_function_id, brand_level_discount_function_id, is_active
	)
	SELECT DISTINCT ON (supplier_id, product_id)
		sku, supplier_id, product_id, product_case_id, case_price_base, case_price_currency,
		country_of_origin, moq_cases, eu_goods_tier,
		discount_function_id, brand_discount_function_id, is_offer_active
	FROM product_input_table
	WHERE product_id IS NOT NULL
		AND supplier_id IS NOT NULL
		AND product_case_id IS NOT NULL
		AND case_price_base IS NOT NULL
		AND case_price_currency IS NOT NULL
	ON CONFLICT (supplier_id, product_id) DO UPDATE SET
		sku = EXCLUDED.sku,
		product_case_id = EXCLUDED.product_case_id,
		case_price_base = EXCLUDED.case_price_base,
		case_price_currency = EXCLUDED.case_price_currency,
		eu_goods_tier = EXCLUDED.eu_goods_tier,
		country_of_origin = EXCLUDED.country_of_origin,
		moq_cases = EXCLUDED.moq_cases,
		product_level_discount_function_id = EXCLUDED.product_level_discount_function_id,
		brand_level_discount_function_id = EXCLUDED.brand_level_discount_function_id,
		is_active = EXCLUDED.is_active,
		updated_at = CURRENT_TIMESTAMP;

	RAISE NOTICE 'Completed inserting product offers';

	DROP TABLE product_input_table;
END;
$$;


ALTER FUNCTION dirac.bulk_upsert_products(products dirac.product_input[]) OWNER TO postgres;

--
-- Name: calculate_line_item_totals(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.calculate_line_item_totals(p_case_quantity numeric, p_case_price numeric, p_discount_applied numeric, p_uk_vat_fraction numeric) RETURNS TABLE(line_total numeric, vat_amount numeric, line_total_with_vat numeric)
    LANGUAGE sql IMMUTABLE PARALLEL SAFE
    AS $$
	SELECT
		(p_case_quantity * p_case_price - COALESCE(p_discount_applied, 0))::DECIMAL(19,4) AS line_total,
		((p_case_quantity * p_case_price - COALESCE(p_discount_applied, 0)) * p_uk_vat_fraction)::DECIMAL(19,4) AS vat_amount,
		((p_case_quantity * p_case_price - COALESCE(p_discount_applied, 0)) * (1 + p_uk_vat_fraction))::DECIMAL(19,4) AS line_total_with_vat;
$$;


ALTER FUNCTION dirac.calculate_line_item_totals(p_case_quantity numeric, p_case_price numeric, p_discount_applied numeric, p_uk_vat_fraction numeric) OWNER TO postgres;

--
-- Name: FUNCTION calculate_line_item_totals(p_case_quantity numeric, p_case_price numeric, p_discount_applied numeric, p_uk_vat_fraction numeric); Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON FUNCTION dirac.calculate_line_item_totals(p_case_quantity numeric, p_case_price numeric, p_discount_applied numeric, p_uk_vat_fraction numeric) IS 'Calculates line item pricing: subtotal (after discount), VAT amount, and total with VAT. Single source of truth for order item calculations.';


--
-- Name: calculate_order_total(bigint); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.calculate_order_total(p_order_id bigint) RETURNS TABLE(total_excl_vat numeric, total_vat numeric, total_incl_vat numeric, currency character)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
	-- Calculate totals using helper function for consistency
	-- Note: All items in an order must have the same currency (enforced by trigger)
	RETURN QUERY
	SELECT
		SUM(totals.line_total)::DECIMAL(19,4) as total_excl_vat,
		SUM(totals.vat_amount)::DECIMAL(19,4) as total_vat,
		SUM(totals.line_total_with_vat)::DECIMAL(19,4) as total_incl_vat,
		oi.currency as currency
	FROM dirac.order_item oi
	CROSS JOIN LATERAL dirac.calculate_line_item_totals(
		oi.case_quantity,
		oi.case_price,
		oi.discount_applied,
		oi.uk_vat_fraction
	) AS totals
	WHERE oi.order_id = p_order_id
	GROUP BY oi.order_id, oi.currency;
END;
$$;


ALTER FUNCTION dirac.calculate_order_total(p_order_id bigint) OWNER TO postgres;

--
-- Name: calculate_shipping_cost(uuid); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.calculate_shipping_cost(p_order_uuid uuid) RETURNS TABLE(num_pallets integer, shipping_cost_amount numeric, shipping_cost_currency character, is_uk boolean)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	_num_pallets INTEGER;
	_shipping_cost DECIMAL(19,4);
	_shipping_country CHAR(2);
	_is_uk BOOLEAN;
BEGIN
	-- Get shipping country from order
	SELECT sl.country INTO _shipping_country
	FROM dirac.order o
	LEFT JOIN dirac.location sl ON sl.id = o.shipping_address_id
	WHERE o.uuid = p_order_uuid;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Order not found' USING ERRCODE = 'P0002';
	END IF;

	-- Check if UK order
	_is_uk := (_shipping_country = 'GB');

	-- Calculate number of pallets
	_num_pallets := api.get_pallets_for_order(p_order_uuid);

	-- Calculate shipping cost if UK
	IF _is_uk AND _num_pallets > 0 THEN
		_shipping_cost := _num_pallets * 61.70;
	ELSE
		_shipping_cost := NULL;
	END IF;

	-- Return the results (no storage)
	RETURN QUERY
	SELECT
		_num_pallets,
		_shipping_cost,
		CASE WHEN _is_uk THEN 'GBP'::CHAR(3) ELSE NULL END,
		_is_uk;
END;
$$;


ALTER FUNCTION dirac.calculate_shipping_cost(p_order_uuid uuid) OWNER TO postgres;

--
-- Name: check_order_item_currency(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.check_order_item_currency() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_existing_currency CHAR(3);
BEGIN
	-- Get currency from first existing item in this order (if any)
	SELECT currency INTO v_existing_currency
	FROM dirac.order_item
	WHERE order_id = NEW.order_id
	LIMIT 1;

	-- If there are existing items and currency doesn't match, reject
	IF v_existing_currency IS NOT NULL AND v_existing_currency != NEW.currency THEN
		RAISE EXCEPTION 'Cannot mix currencies in order. Order uses % but item uses %',
			v_existing_currency, NEW.currency
			USING ERRCODE = 'P0004';
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION dirac.check_order_item_currency() OWNER TO postgres;

--
-- Name: FUNCTION check_order_item_currency(); Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON FUNCTION dirac.check_order_item_currency() IS 'Ensures all items in an order have the same currency to prevent invalid calculations';


--
-- Name: extract_linkedin_slug(text); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.extract_linkedin_slug(url text) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    AS $_$
DECLARE
    slug_val VARCHAR(255);
BEGIN
    IF url IS NULL THEN
        RETURN NULL;
    END IF;

    slug_val := substring(url FROM '/(?:in|company)/([^/?#]+)');
    IF slug_val IS NOT NULL THEN
        slug_val := rtrim(slug_val, '/');
        IF slug_val ~ '^[a-z0-9]+(-[a-z0-9]+)*$' THEN
            RETURN slug_val;
        END IF;
    END IF;

    RETURN NULL;
END;
$_$;


ALTER FUNCTION dirac.extract_linkedin_slug(url text) OWNER TO postgres;

--
-- Name: generate_slug(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.generate_slug() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  BEGIN
    -- Generate slug from name if not provided
    IF NEW.slug IS NULL OR NEW.slug = '' THEN
      NEW.slug = dirac.generate_slug(NEW.name);
    END IF;

    RETURN NEW;
  END;
$$;


ALTER FUNCTION dirac.generate_slug() OWNER TO postgres;

--
-- Name: generate_slug(character varying); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.generate_slug(input_text character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  BEGIN
    -- Convert to lowercase, replace spaces/invalid chars with hyphen
    RETURN trim(both '-' from lower(regexp_replace(input_text, '[^a-zA-Z0-9]+', '-', 'g')));
  END;
$$;


ALTER FUNCTION dirac.generate_slug(input_text character varying) OWNER TO postgres;

--
-- Name: get_price(bigint, numeric, integer); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.get_price(p_discount_id bigint, p_base_price numeric, p_qty integer) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
	v_discount dirac.discount_range;
	v_final_price DECIMAL(19,4);
	BEGIN
		-- If no discount function, return base price
		IF p_discount_id IS NULL THEN
		  RETURN p_base_price * p_qty;
		END IF;

		-- Find the discount range that contains this quantity
		SELECT d.* INTO v_discount
		FROM dirac.discount_function df
		CROSS JOIN LATERAL unnest(df.discounts) AS d
		WHERE df.id = p_discount_id
		AND d.qty_range @> p_qty;  -- @> means "contains"

		-- If no matching range found (shouldn't happen if validated), return base price
		IF NOT FOUND THEN
		  RETURN p_base_price * p_qty;
		END IF;

		-- Apply discount
		IF v_discount.discount_absolute IS NOT NULL THEN
		  -- Absolute discount per unit
		  v_final_price := (p_base_price - v_discount.discount_absolute) * p_qty;
		ELSIF v_discount.discount_fraction IS NOT NULL THEN
		  -- Percentage discount
		  v_final_price := p_base_price * (1 - v_discount.discount_fraction) * p_qty;
		ELSE
		  -- No discount (shouldn't happen if validated)
		  v_final_price := p_base_price * p_qty;
		END IF;

		-- Ensure price doesn't go negative
		RETURN GREATEST(v_final_price, 0);
	END;
$$;


ALTER FUNCTION dirac.get_price(p_discount_id bigint, p_base_price numeric, p_qty integer) OWNER TO postgres;

--
-- Name: is_valid_slug(text); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.is_valid_slug(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
  BEGIN
    -- Allow alphanumeric, percent signs, ampersands, semicolons, and hyphens (including consecutive)
    RETURN $1 ~ '^[a-zA-Z0-9%;&-]+$';
  END;
$_$;


ALTER FUNCTION dirac.is_valid_slug(text) OWNER TO postgres;

--
-- Name: regenerate_image_uuid(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.regenerate_image_uuid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	-- Only regenerate UUID if blob is being updated (not on insert)
	IF TG_OP = 'UPDATE' AND OLD.blob IS DISTINCT FROM NEW.blob THEN
		NEW.uuid = gen_random_uuid();
		NEW.updated_at = CURRENT_TIMESTAMP;
		-- Application layer should delete old file and save new file with new UUID
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION dirac.regenerate_image_uuid() OWNER TO postgres;

--
-- Name: test_add_demand_request(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_add_demand_request() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_customer_id BIGINT;
    v_brand_id BIGINT;
    v_product_id BIGINT;
    v_request_id BIGINT;
    v_request_id2 BIGINT;
    v_embedding vector(768);
BEGIN
    -- Create test embedding (simplified - normally would be actual embedding)
    v_embedding := array_fill(0.1::float4, ARRAY[768])::vector;

    -- Setup currencies
    INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
    INSERT INTO dirac.currency (iso_4217, name) VALUES ('EUR', 'Euro') ON CONFLICT DO NOTHING;

    -- Create test admin
    INSERT INTO auth.admin_user (email, full_name, is_active)
    VALUES ('test_admin@test.com', 'Test Admin', true)
    RETURNING id INTO v_admin_id;

    -- Create test customer
    INSERT INTO dirac.customer (name, embedding)
    VALUES ('Test Customer', v_embedding)
    RETURNING id INTO v_customer_id;

    -- Create test brand
    INSERT INTO dirac.brand (name, slug, embedding)
    VALUES ('Test Brand', 'test-brand', v_embedding)
    RETURNING id INTO v_brand_id;

    -- Create test product
    INSERT INTO dirac.product (name, slug, brand_id, embedding)
    VALUES ('Test Product', 'test-product', v_brand_id, v_embedding)
    RETURNING id INTO v_product_id;

    -- Test 1: Add product demand request with target price
    v_request_id := admin.add_demand_request(
        p_admin_id => v_admin_id,
        p_quantity => ROW(10, 'case'::dirac.product_quantity_unit)::dirac.product_quantity,
        p_customer_id => v_customer_id,
        p_product_id => v_product_id,
        p_notes => 'Test request with target price',
        p_source => 'test',
        p_target_unit_price => 15.50,
        p_target_unit_price_currency => 'USD'
    );

    RETURN NEXT ok(v_request_id IS NOT NULL, 'Should create demand request with target price');

    -- Test 2: Verify target price was saved correctly
    RETURN NEXT is(
        (SELECT target_unit_price FROM dirac.demand_request WHERE id = v_request_id),
        15.50,
        'Target unit price should be saved correctly'
    );

    RETURN NEXT is(
        (SELECT target_unit_price_currency FROM dirac.demand_request WHERE id = v_request_id),
        'USD',
        'Target unit price currency should be saved correctly'
    );

    -- Test 3: Add demand request without target price
    v_request_id2 := admin.add_demand_request(
        p_admin_id => v_admin_id,
        p_quantity => ROW(5, 'unit'::dirac.product_quantity_unit)::dirac.product_quantity,
        p_customer_id => v_customer_id,
        p_brand_id => v_brand_id,
        p_notes => 'Test brand request without target price',
        p_source => 'test'
    );

    RETURN NEXT ok(v_request_id2 IS NOT NULL, 'Should create demand request without target price');

    -- Test 4: Verify NULL target price fields
    RETURN NEXT is(
        (SELECT target_unit_price FROM dirac.demand_request WHERE id = v_request_id2),
        NULL::DECIMAL(19,4),
        'Target unit price should be NULL when not provided'
    );

    RETURN NEXT is(
        (SELECT target_unit_price_currency FROM dirac.demand_request WHERE id = v_request_id2),
        NULL::CHAR(3),
        'Target unit price currency should be NULL when not provided'
    );

    -- Test 5: Test constraint - price without currency should fail
    RETURN NEXT throws_ok(
        format('SELECT admin.add_demand_request(%s, ROW(1, ''unit''::dirac.product_quantity_unit)::dirac.product_quantity, %s, NULL, NULL, NULL, %s, NULL, NULL, NULL, NULL, NULL, NULL, ''test note'', ''test'', 10.00, NULL)',
            v_admin_id, v_customer_id, v_product_id),
        'P0004',
        'Target unit price and currency must both be provided or both be NULL',
        'Should fail when price provided without currency'
    );

    -- Test 6: Test constraint - currency without price should fail
    RETURN NEXT throws_ok(
        format('SELECT admin.add_demand_request(%s, ROW(1, ''unit''::dirac.product_quantity_unit)::dirac.product_quantity, %s, NULL, NULL, NULL, %s, NULL, NULL, NULL, NULL, NULL, NULL, ''test note'', ''test'', NULL, ''USD'')',
            v_admin_id, v_customer_id, v_product_id),
        'P0004',
        'Target unit price and currency must both be provided or both be NULL',
        'Should fail when currency provided without price'
    );

    -- Test 7: Update existing demand request with new target price
    v_request_id := admin.add_demand_request(
        p_admin_id => v_admin_id,
        p_quantity => ROW(20, 'case'::dirac.product_quantity_unit)::dirac.product_quantity,
        p_customer_id => v_customer_id,
        p_product_id => v_product_id,
        p_notes => 'Updated request',
        p_source => 'test',
        p_target_unit_price => 25.00,
        p_target_unit_price_currency => 'EUR'
    );

    RETURN NEXT is(
        (SELECT target_unit_price FROM dirac.demand_request WHERE customer_id = v_customer_id AND product_id = v_product_id),
        25.00,
        'Target unit price should be updated on conflict'
    );

    RETURN NEXT is(
        (SELECT target_unit_price_currency FROM dirac.demand_request WHERE customer_id = v_customer_id AND product_id = v_product_id),
        'EUR',
        'Target unit price currency should be updated on conflict'
    );

END;
$$;


ALTER FUNCTION dirac.test_add_demand_request() OWNER TO postgres;

--
-- Name: test_add_manufacturer(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_add_manufacturer() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    first_id BIGINT;
    second_id BIGINT;
    third_id BIGINT;
    v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
    -- Test 1: Add a new supplier
    SELECT dirac.add_supplier('Test Supplier TAM', v_dummy_embedding) INTO first_id;

    RETURN NEXT ok(first_id IS NOT NULL, 'Should return an ID when adding new supplier');

    -- Verify the supplier was created
    RETURN NEXT results_eq(
        'SELECT COUNT(*) FROM dirac.supplier WHERE name = ''Test Supplier TAM''',
        'SELECT 1::BIGINT',
        'Should create exactly one supplier record'
    );

    -- Test 2: Add the same supplier again (should return same ID)
    SELECT dirac.add_supplier('Test Supplier TAM', v_dummy_embedding) INTO second_id;

    RETURN NEXT is(second_id, first_id, 'Should return same ID when supplier already exists');

    -- Verify we still have only one record
    RETURN NEXT results_eq(
        'SELECT COUNT(*) FROM dirac.supplier WHERE name = ''Test Supplier TAM''',
        'SELECT 1::BIGINT',
        'Should still have only one record after duplicate insert'
    );

    -- Test 3: Add a different supplier
    SELECT dirac.add_supplier('Another Test Supplier TAM', v_dummy_embedding) INTO third_id;

    RETURN NEXT ok(third_id IS NOT NULL AND third_id != first_id, 'Should return different ID for different supplier');

    -- Verify we now have two test suppliers
    RETURN NEXT results_eq(
        'SELECT COUNT(*) FROM dirac.supplier WHERE name IN (''Test Supplier TAM'', ''Another Test Supplier TAM'')',
        'SELECT 2::BIGINT',
        'Should have two suppliers after adding different ones'
    );
END;
$$;


ALTER FUNCTION dirac.test_add_manufacturer() OWNER TO postgres;

--
-- Name: test_admin_oauth_first_login(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_first_login() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_session_uuid UUID;
    v_stored_google_id VARCHAR(255);
    v_email TEXT := 'test_oauth_admin_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '123456789012345678901';
BEGIN
    -- Create admin without google_id
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active)
    VALUES (v_email, NULL, 'Test OAuth Admin', true)
    RETURNING id INTO v_admin_id;

    -- First OAuth login should link the google_id
    v_session_uuid := admin.login(
        v_email,
        v_google_id,
        '192.168.1.100'::inet,
        'Mozilla/5.0 Test'
    );

    -- Check session was created
    RETURN NEXT ok(
        v_session_uuid IS NOT NULL,
        'First OAuth login should return session UUID'
    );

    -- Verify google_id was linked
    SELECT google_id INTO v_stored_google_id
    FROM auth.admin_user
    WHERE id = v_admin_id;

    RETURN NEXT is(
        v_stored_google_id,
        v_google_id,
        'First OAuth login should link google_id to account'
    );

    -- Clean up
    DELETE FROM auth.admin_session WHERE admin_user_id = v_admin_id;
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_first_login() OWNER TO postgres;

--
-- Name: test_admin_oauth_inactive_account(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_inactive_account() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_email TEXT := 'test_inactive_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '567890123456789012345';
BEGIN
    -- Create inactive admin
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active)
    VALUES (v_email, NULL, 'Test Inactive Admin', false)
    RETURNING id INTO v_admin_id;

    RETURN NEXT throws_ok(
        format('SELECT admin.login(%L, %L, %L::inet, %L)',
            v_email, v_google_id, '192.168.1.104', 'Edge/97.0'),
        'P0001',
        'Admin account is disabled',
        'Should reject inactive account'
    );

    -- Clean up
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_inactive_account() OWNER TO postgres;

--
-- Name: test_admin_oauth_last_login_update(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_last_login_update() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_session_uuid UUID;
    v_last_login_before TIMESTAMPTZ;
    v_last_login_after TIMESTAMPTZ;
    v_email TEXT := 'test_lastlogin_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '789012345678901234567';
BEGIN
    -- Create admin with NULL last_login
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active, last_login)
    VALUES (v_email, NULL, 'Test LastLogin Admin', true, NULL)
    RETURNING id, last_login INTO v_admin_id, v_last_login_before;

    -- Login
    v_session_uuid := admin.login(
        v_email,
        v_google_id,
        '192.168.1.106'::inet,
        'Brave/1.0'
    );

    -- Check last_login was updated
    SELECT last_login INTO v_last_login_after
    FROM auth.admin_user
    WHERE id = v_admin_id;

    RETURN NEXT ok(
        v_last_login_after IS NOT NULL,
        'Last login should be set after login'
    );

    RETURN NEXT ok(
        v_last_login_after >= NOW() - INTERVAL '5 seconds',
        'Last login should be current timestamp'
    );

    -- Clean up
    DELETE FROM auth.admin_session WHERE admin_user_id = v_admin_id;
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_last_login_update() OWNER TO postgres;

--
-- Name: test_admin_oauth_linked_login(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_linked_login() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_session_uuid UUID;
    v_email TEXT := 'test_linked_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '234567890123456789012';
BEGIN
    -- Create admin with google_id already set
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active)
    VALUES (v_email, v_google_id, 'Test Linked Admin', true)
    RETURNING id INTO v_admin_id;

    -- Login with matching google_id
    v_session_uuid := admin.login(
        v_email,
        v_google_id,
        '192.168.1.101'::inet,
        'Chrome/100.0 Test'
    );

    -- Check session was created
    RETURN NEXT ok(
        v_session_uuid IS NOT NULL,
        'Login with linked google_id should return session UUID'
    );

    -- Verify session exists in database
    RETURN NEXT ok(
        EXISTS(
            SELECT 1 FROM auth.admin_session
            WHERE uuid = v_session_uuid AND admin_user_id = v_admin_id
        ),
        'Session should exist in admin_session table'
    );

    -- Clean up
    DELETE FROM auth.admin_session WHERE admin_user_id = v_admin_id;
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_linked_login() OWNER TO postgres;

--
-- Name: test_admin_oauth_login_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_login_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'admin',
        'login',
        ARRAY['text', 'varchar', 'inet', 'text'],
        'admin.login OAuth function should exist'
    );

    RETURN NEXT function_returns(
        'admin',
        'login',
        ARRAY['text', 'varchar', 'inet', 'text'],
        'uuid',
        'admin.login should return UUID'
    );
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_login_exists() OWNER TO postgres;

--
-- Name: test_admin_oauth_multiple_sessions(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_multiple_sessions() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_session_uuid1 UUID;
    v_session_uuid2 UUID;
    v_session_count INTEGER;
    v_email TEXT := 'test_multi_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '901234567890123456789';
BEGIN
    -- Create admin
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active)
    VALUES (v_email, v_google_id, 'Test Multi Admin', true)
    RETURNING id INTO v_admin_id;

    -- Create first session
    v_session_uuid1 := admin.login(
        v_email,
        v_google_id,
        '192.168.1.107'::inet,
        'Device1/1.0'
    );

    -- Create second session
    v_session_uuid2 := admin.login(
        v_email,
        v_google_id,
        '192.168.1.108'::inet,
        'Device2/2.0'
    );

    RETURN NEXT isnt(
        v_session_uuid1,
        v_session_uuid2,
        'Multiple logins should create different session UUIDs'
    );

    -- Count sessions for this admin
    SELECT COUNT(*) INTO v_session_count
    FROM auth.admin_session
    WHERE admin_user_id = v_admin_id;

    RETURN NEXT is(
        v_session_count,
        2,
        'Multiple logins should create multiple active sessions'
    );

    -- Clean up
    DELETE FROM auth.admin_session WHERE admin_user_id = v_admin_id;
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_multiple_sessions() OWNER TO postgres;

--
-- Name: test_admin_oauth_nonexistent_email(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_nonexistent_email() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT throws_ok(
        format('SELECT admin.login(%L, %L, %L::inet, %L)',
            'nonexistent_admin@example.com', '456789012345678901234',
            '192.168.1.103', 'Safari/14.0'),
        'P0001',
        'Invalid admin credentials',
        'Should reject non-existent email'
    );
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_nonexistent_email() OWNER TO postgres;

--
-- Name: test_admin_oauth_session_expiry(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_session_expiry() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_session_uuid UUID;
    v_expires_at TIMESTAMPTZ;
    v_email TEXT := 'test_expiry_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '678901234567890123456';
BEGIN
    -- Create admin
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active)
    VALUES (v_email, NULL, 'Test Expiry Admin', true)
    RETURNING id INTO v_admin_id;

    -- Login
    v_session_uuid := admin.login(
        v_email,
        v_google_id,
        '192.168.1.105'::inet,
        'Opera/80.0'
    );

    -- Check session expiry
    SELECT expires_at INTO v_expires_at
    FROM auth.admin_session
    WHERE uuid = v_session_uuid;

    -- Check if expiry is approximately 2 hours from now (within 5 seconds tolerance)
    RETURN NEXT ok(
        v_expires_at BETWEEN (NOW() + INTERVAL '2 hours' - INTERVAL '5 seconds')
            AND (NOW() + INTERVAL '2 hours' + INTERVAL '5 seconds'),
        'Session should expire in 2 hours'
    );

    -- Clean up
    DELETE FROM auth.admin_session WHERE admin_user_id = v_admin_id;
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_session_expiry() OWNER TO postgres;

--
-- Name: test_admin_oauth_session_metadata(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_session_metadata() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_session_uuid UUID;
    v_stored_ip INET;
    v_stored_user_agent TEXT;
    v_email TEXT := 'test_metadata_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '890123456789012345678';
    v_test_ip INET := '10.20.30.40'::inet;
    v_test_user_agent TEXT := 'Custom Test Browser 2.0';
BEGIN
    -- Create admin
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active)
    VALUES (v_email, NULL, 'Test Metadata Admin', true)
    RETURNING id INTO v_admin_id;

    -- Login with specific IP and user agent
    v_session_uuid := admin.login(
        v_email,
        v_google_id,
        v_test_ip,
        v_test_user_agent
    );

    -- Verify stored values
    SELECT ip, user_agent INTO v_stored_ip, v_stored_user_agent
    FROM auth.admin_session
    WHERE uuid = v_session_uuid;

    RETURN NEXT is(
        v_stored_ip,
        v_test_ip,
        'Session should store correct IP address'
    );

    RETURN NEXT is(
        v_stored_user_agent,
        v_test_user_agent,
        'Session should store correct user agent'
    );

    -- Clean up
    DELETE FROM auth.admin_session WHERE admin_user_id = v_admin_id;
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_session_metadata() OWNER TO postgres;

--
-- Name: test_admin_oauth_wrong_google_id(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_admin_oauth_wrong_google_id() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_admin_id BIGINT;
    v_email TEXT := 'test_wrong_' || gen_random_uuid()::text || '@example.com';
    v_google_id VARCHAR(255) := '345678901234567890123';
    v_wrong_google_id VARCHAR(255) := '999999999999999999999';
BEGIN
    -- Create admin with google_id already set
    INSERT INTO auth.admin_user (email, google_id, full_name, is_active)
    VALUES (v_email, v_google_id, 'Test Wrong Admin', true)
    RETURNING id INTO v_admin_id;

    -- Try to login with different google_id
    RETURN NEXT throws_ok(
        format('SELECT admin.login(%L, %L, %L::inet, %L)',
            v_email, v_wrong_google_id, '192.168.1.102', 'Firefox/95.0'),
        'P0001',
        'Invalid admin credentials',
        'Should reject wrong google_id for linked account'
    );

    -- Clean up
    DELETE FROM auth.admin_user WHERE id = v_admin_id;
END;
$$;


ALTER FUNCTION dirac.test_admin_oauth_wrong_google_id() OWNER TO postgres;

--
-- Name: test_api_role_permissions(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_api_role_permissions() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    _original_role TEXT;
BEGIN
    -- Store original role
    _original_role := current_user;

    -- Test 1: Check api role exists
    RETURN NEXT has_role('api', 'API role should exist');

    -- Test 2: Check api schema exists
    RETURN NEXT has_schema('api', 'API schema should exist');

    -- Test 3: Check api role has USAGE on api schema
    RETURN NEXT schema_privs_are(
        'api',     -- schema
        'api',     -- role
        ARRAY['USAGE'],
        'API role should have USAGE privilege on api schema'
    );

    -- Test 4: Check api role can execute get_product_listing
    RETURN NEXT has_function(
        'api',
        'get_product_listing',
        ARRAY['integer', 'integer', 'character varying', 'character varying', 'character varying', 'vector'],
        'get_product_listing function should exist in api schema'
    );

    RETURN NEXT function_privs_are(
        'api',
        'get_product_listing',
        ARRAY['integer', 'integer', 'character varying', 'character varying', 'character varying', 'vector'],
        'api',
        ARRAY['EXECUTE'],
        'API role should have EXECUTE privilege on get_product_listing'
    );

    -- Test 5: Check api role can execute get_product_detail
    RETURN NEXT has_function(
        'api',
        'get_product_detail',
        ARRAY['character varying'],
        'get_product_detail function should exist in api schema'
    );

    RETURN NEXT function_privs_are(
        'api',
        'get_product_detail',
        ARRAY['character varying'],
        'api',
        ARRAY['EXECUTE'],
        'API role should have EXECUTE privilege on get_product_detail'
    );

    -- Test 6: Check api role has USAGE on dirac schema (needed for types)
    -- Note: The api role needs USAGE to access types but not tables
    RETURN NEXT schema_privs_are(
        'dirac',    -- schema
        'api',      -- role
        ARRAY['USAGE'],
        'API role should have USAGE privilege on dirac schema for types'
    );

    -- Test 7: Verify api role cannot directly SELECT from dirac.product
    RETURN NEXT table_privs_are(
        'dirac',
        'product',
        'api',
        ARRAY[]::text[],  -- No privileges
        'API role should have NO privileges on dirac.product table'
    );

    -- Test 8: Verify api role cannot directly SELECT from dirac.brand
    RETURN NEXT table_privs_are(
        'dirac',
        'brand',
        'api',
        ARRAY[]::text[],  -- No privileges
        'API role should have NO privileges on dirac.brand table'
    );

    -- Test 9: Verify api role cannot directly SELECT from dirac.product_offer
    RETURN NEXT table_privs_are(
        'dirac',
        'product_offer',
        'api',
        ARRAY[]::text[],  -- No privileges
        'API role should have NO privileges on dirac.product_offer table'
    );

    -- Test 10: Functional test - Switch to api role and try to execute functions
    -- This tests that SECURITY DEFINER works properly
    BEGIN
        -- Temporarily switch to api role
        EXECUTE 'SET ROLE api';

        -- Test that we can call the functions (they should work due to SECURITY DEFINER)
        PERFORM api.get_product_listing(1, 0);
        RETURN NEXT pass('API role can execute get_product_listing function');

        -- Reset role
        EXECUTE 'SET ROLE ' || _original_role;
    EXCEPTION WHEN OTHERS THEN
        -- Reset role on error
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should be able to execute get_product_listing: ' || SQLERRM);
    END;

    -- Test 11: Verify api role cannot directly query dirac tables
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'SELECT * FROM dirac.product LIMIT 1';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to directly query dirac.product');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied direct access to dirac.product');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error when testing direct access: ' || SQLERRM);
    END;

    -- Test 12: Verify api role cannot modify dirac tables
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'INSERT INTO dirac.product(name) VALUES(''test'')';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to insert into dirac.product');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied insert access to dirac.product');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error when testing insert access: ' || SQLERRM);
    END;

    -- Test 13: Verify api role cannot execute dirac schema functions
    -- This tests that PUBLIC EXECUTE has been revoked from dirac functions
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'SELECT dirac.generate_slug(''Test Product'')';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to execute dirac.generate_slug');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied access to dirac.generate_slug');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error testing dirac.generate_slug access: ' || SQLERRM);
    END;

END;
$$;


ALTER FUNCTION dirac.test_api_role_permissions() OWNER TO postgres;

--
-- Name: test_auth_permissions(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_auth_permissions() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    _original_role TEXT;
BEGIN
    -- Store original role
    _original_role := current_user;

    -- Test 1: Check auth schema exists
    RETURN NEXT has_schema('auth', 'Auth schema should exist');

    -- Test 2: Check api schema exists
    RETURN NEXT has_schema('api', 'API schema should exist');

    -- Test 3: Check api role exists
    RETURN NEXT has_role('api', 'API role should exist');

    -- Test 4: Check api role has USAGE on api schema
    RETURN NEXT schema_privs_are(
        'api',     -- schema
        'api',     -- role
        ARRAY['USAGE'],
        'API role should have USAGE privilege on api schema'
    );

    -- Test 5: Check api role can execute create_account
    RETURN NEXT has_function(
        'api',
        'create_account',
        ARRAY['text', 'text', 'inet', 'text'],
        'create_account function should exist in api schema'
    );

    RETURN NEXT function_privs_are(
        'api',
        'create_account',
        ARRAY['text', 'text', 'inet', 'text'],
        'api',
        ARRAY['EXECUTE'],
        'API role should have EXECUTE privilege on create_account'
    );

    -- Test 6: Check api role can execute login
    RETURN NEXT has_function(
        'api',
        'login',
        ARRAY['text', 'text', 'inet', 'text'],
        'login function should exist in api schema'
    );

    RETURN NEXT function_privs_are(
        'api',
        'login',
        ARRAY['text', 'text', 'inet', 'text'],
        'api',
        ARRAY['EXECUTE'],
        'API role should have EXECUTE privilege on login'
    );

    -- Test 7: Check api role can execute is_session_valid
    RETURN NEXT has_function(
        'api',
        'is_session_valid',
        ARRAY['uuid', 'inet', 'text'],
        'is_session_valid function should exist in api schema'
    );

    RETURN NEXT function_privs_are(
        'api',
        'is_session_valid',
        ARRAY['uuid', 'inet', 'text'],
        'api',
        ARRAY['EXECUTE'],
        'API role should have EXECUTE privilege on is_session_valid'
    );

    -- Test 8: Check api role does NOT have direct access to auth schema
    RETURN NEXT schema_privs_are(
        'auth',    -- schema
        'api',      -- role
        ARRAY[]::text[],  -- Empty array means no privileges
        'API role should NOT have any privileges on auth schema'
    );

    -- Test 9: Verify api role cannot directly access auth.user table
    RETURN NEXT table_privs_are(
        'auth',
        'user',
        'api',
        ARRAY[]::text[],  -- No privileges
        'API role should have NO direct privileges on auth.user table'
    );

    -- Test 10: Verify api role cannot directly access auth.web_session table
    RETURN NEXT table_privs_are(
        'auth',
        'web_session',
        'api',
        ARRAY[]::text[],  -- No privileges
        'API role should have NO direct privileges on auth.web_session table'
    );

    -- Test 11: Verify api role cannot execute auth schema functions directly
    -- Note: We check schema access, not function privileges, as schema USAGE controls access
    RETURN NEXT schema_privs_are(
        'auth',
        'api',
        ARRAY[]::text[],  -- No privileges on auth schema
        'API role should have NO privileges on auth schema (blocks function access)'
    );

    -- These tests check function-level privileges but are redundant since schema access is blocked
    -- Keeping them commented as documentation of what we're NOT testing
    -- RETURN NEXT function_privs_are('auth', 'hash_password', ARRAY['text'], 'api', ARRAY[]::text[], 'API role should have NO privileges on auth.hash_password');
    -- RETURN NEXT function_privs_are('auth', 'verify_password', ARRAY['text', 'text'], 'api', ARRAY[]::text[], 'API role should have NO privileges on auth.verify_password');

    -- Test 12: Functional test - Switch to api role and try to execute auth functions
    BEGIN
        -- Temporarily switch to api role
        EXECUTE 'SET ROLE api';

        -- Test that we can call the API functions (they should work due to SECURITY DEFINER)
        DECLARE
            v_uuid UUID;
        BEGIN
            -- These should succeed due to SECURITY DEFINER
            BEGIN
                v_uuid := api.create_account(
                    'testperm@gmail.com',
                    'TestPass123',
                    '192.168.1.1'::inet,
                    'Test/1.0'
                );
                RETURN NEXT pass('API role can execute create_account function');
            EXCEPTION
                WHEN SQLSTATE 'P0001' OR SQLSTATE 'P0004' THEN
                    RETURN NEXT fail('API role should be able to execute create_account: ' || SQLERRM);
            END;

            -- Clean up test user
            EXECUTE 'SET ROLE ' || _original_role;
            DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = 'testperm@gmail.com');
            DELETE FROM auth.user WHERE email = 'testperm@gmail.com';
            EXECUTE 'SET ROLE api';
        END;

        -- Reset role
        EXECUTE 'SET ROLE ' || _original_role;
    EXCEPTION WHEN OTHERS THEN
        -- Reset role on error
        EXECUTE 'SET ROLE ' || _original_role;
        RAISE;
    END;

    -- Test 13: Verify api role cannot directly query auth.user table
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'SELECT * FROM auth.user LIMIT 1';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to directly query auth.user');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied direct access to auth.user');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error when testing direct access: ' || SQLERRM);
    END;

    -- Test 14: Verify api role cannot directly query auth.web_session table
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'SELECT * FROM auth.web_session LIMIT 1';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to directly query auth.web_session');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied direct access to auth.web_session');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error when testing web_session access: ' || SQLERRM);
    END;

    -- Test 15: Verify api role cannot modify auth tables
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'INSERT INTO auth.user(email, password_hash) VALUES(''test@test.com'', ''hash'')';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to insert into auth.user');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied insert access to auth.user');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error when testing insert access: ' || SQLERRM);
    END;

    -- Test 16: Verify api role cannot call auth.hash_password directly
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'SELECT auth.hash_password(''test'')';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to call auth.hash_password');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied access to auth.hash_password');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error when testing hash_password access: ' || SQLERRM);
    END;

    -- Test 17: Verify api role cannot call auth.verify_password directly
    BEGIN
        EXECUTE 'SET ROLE api';
        EXECUTE 'SELECT auth.verify_password(''test'', ''hash'')';
        -- If we get here, the test failed
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should NOT be able to call auth.verify_password');
    EXCEPTION
        WHEN insufficient_privilege THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT pass('API role correctly denied access to auth.verify_password');
        WHEN OTHERS THEN
            EXECUTE 'SET ROLE ' || _original_role;
            RETURN NEXT fail('Unexpected error when testing verify_password access: ' || SQLERRM);
    END;

    -- Test 18: Test SECURITY DEFINER behavior - api functions can access auth tables
    DECLARE
        v_email TEXT := 'secdefiner@gmail.com';
        v_password TEXT := 'SecDefPass123';
        v_ip INET := '192.168.1.1'::inet;
        v_ua TEXT := 'Test/1.0';
        v_uuid UUID;
    BEGIN
        -- As original role, create account via api function
        v_uuid := api.create_account(v_email, v_password, v_ip, v_ua);

        RETURN NEXT ok(
            v_uuid IS NOT NULL,
            'SECURITY DEFINER allows api functions to access auth tables'
        );

        -- Verify the user was actually created in auth schema
        RETURN NEXT ok(
            EXISTS(SELECT 1 FROM auth.user WHERE email = v_email),
            'SECURITY DEFINER function successfully created user in auth.user'
        );

        -- Test login function also works with SECURITY DEFINER
        v_uuid := api.login(v_email, v_password, v_ip, v_ua);

        RETURN NEXT ok(
            v_uuid IS NOT NULL,
            'SECURITY DEFINER allows login function to access auth tables'
        );

        -- Test is_session_valid also works
        RETURN NEXT is(
            api.is_session_valid(v_uuid, v_ip, v_ua),
            TRUE,
            'SECURITY DEFINER allows is_session_valid to access auth tables'
        );

        -- Clean up
        DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
        DELETE FROM auth.user WHERE email = v_email;
    END;

    -- Test 19: API role should be able to use dirac schema types
    DECLARE
        v_test_length dirac.length_unit;
    BEGIN
        EXECUTE 'SET ROLE api';
        -- Try to use the dirac.length_unit type
        v_test_length := 'cm'::dirac.length_unit;
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT pass('API role can use dirac.length_unit type');
    EXCEPTION WHEN OTHERS THEN
        EXECUTE 'SET ROLE ' || _original_role;
        RETURN NEXT fail('API role should be able to use dirac.length_unit type: ' || SQLERRM);
    END;

END;
$$;


ALTER FUNCTION dirac.test_auth_permissions() OWNER TO postgres;

--
-- Name: test_bulk_upsert_barcode_normalization(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_barcode_normalization() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_products dirac.product_input[];
	v_supplier_id BIGINT;
	v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
	-- Setup
	INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer BN', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
	-- Add USD currency and US country if not already present
	INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
	INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
	VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;

	-- Test various barcode formats
	v_products := ARRAY[
		ROW(NULL, 'Product UPC-A', '012345678905', NULL, NULL, NULL, v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU002', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
		ROW(NULL, 'Product EAN-13', '1234567890128', NULL, NULL, NULL, v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU003', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
		ROW(NULL, 'Product GTIN-14', '12345678901231', NULL, NULL, NULL, v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU004', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
	];

	-- Execute function
	PERFORM dirac.bulk_upsert_products(v_products);

	-- Verify UPC-A was padded to GTIN-14 (12 digits -> add two zeros)
	RETURN NEXT ok(
		EXISTS(SELECT 1 FROM dirac.barcode WHERE gtin_14 = '00012345678905'),
		'UPC-A should be converted to GTIN-14 with two leading zeros'
	);

	-- Verify EAN-13 was padded to GTIN-14 (13 digits -> add one zero)
	RETURN NEXT ok(
		EXISTS(SELECT 1 FROM dirac.barcode WHERE gtin_14 = '01234567890128'),
		'EAN-13 should be converted to GTIN-14 with one leading zero'
	);

	-- Verify GTIN-14 stays as is
	RETURN NEXT ok(
		EXISTS(SELECT 1 FROM dirac.barcode WHERE gtin_14 = '12345678901231'),
		'GTIN-14 should remain unchanged'
	);


END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_barcode_normalization() OWNER TO postgres;

--
-- Name: test_bulk_upsert_basic_insert(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_basic_insert() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_products dirac.product_input[];
	v_product_id BIGINT;
	v_brand_id BIGINT;
	v_supplier_id BIGINT;
	v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
	-- Setup: Create test brand and manufacturer
	INSERT INTO dirac.brand (name, slug, embedding) VALUES ('Test Brand BUI', 'test-brand-bui', array_fill(0, ARRAY[768])::vector) RETURNING id INTO v_brand_id;
	INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer BUI', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
	INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
	INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
	VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;

	-- Test basic product insertion
	v_products := ARRAY[
		ROW(
			NULL,                       -- product_id
			'Test Product 1',           -- name
			'00000000000000',           -- barcode
			NULL,                       -- image_id
			v_brand_id,                 -- brand_id
			NULL,                       -- brand_name
			v_dummy_embedding,          -- brand_embedding
			v_dummy_embedding,          -- product_embedding
			1,                          -- pack_size
			ROW(500, 'ml')::dirac.volume,   -- volume
			90,                         -- shelf_life_days
			true,                       -- is_gluten_free
			'8708.99',                  -- tariff_code
			'US',                       -- tariff_code_country
			'SKU001',                   -- sku
			v_supplier_id,              -- supplier_id
			NULL,                       -- discount_function_id
			NULL,                       -- brand_discount_function_id
			99.99,                      -- case_price_base
			'USD',                      -- case_price_currency
			'US',                       -- country_of_origin
			NULL,                       -- eu_goods_tier
			5,                          -- moq_cases
			TRUE,                       -- is_offer_active
			12,                         -- units_per_case
			'00000000000017',           -- case_barcode
			NULL,                       -- cases_per_layer
			NULL,                       -- layers_per_pallet
			NULL,                       -- case_weight
			NULL,                       -- case_height
			NULL,                       -- case_width
			NULL,                       -- case_length
			0.2000                      -- uk_vat_fraction
		)::dirac.product_input
	];

	-- Execute function
	PERFORM dirac.bulk_upsert_products(v_products);

	-- Verify product was inserted
	RETURN NEXT ok(
		EXISTS(SELECT 1 FROM dirac.product WHERE barcode = '00000000000000'),
		'Product should be inserted with correct barcode'
	);

	-- Verify product details
	RETURN NEXT results_eq(
		'SELECT name, brand_id FROM dirac.product WHERE barcode = ''00000000000000''',
		format('SELECT ''Test Product 1''::varchar(255), %s::bigint', v_brand_id),
		'Product should have correct name and brand_id'
	);

	-- Verify product_case was created
	RETURN NEXT ok(
		EXISTS(SELECT 1 FROM dirac.product_case WHERE product_id = (SELECT id FROM dirac.product WHERE barcode = '00000000000000') AND units_per_case = 12),
		'Product case should be created with units_per_case'
	);

	-- Verify product_detail was created
	RETURN NEXT results_eq(
		'SELECT shelf_life_days, is_gluten_free FROM dirac.product_detail WHERE product_id = (SELECT id FROM dirac.product WHERE barcode = ''00000000000000'')',
		'SELECT 90::int, true::boolean',
		'Product details should be stored correctly'
	);

	-- Verify product_offer was created
	RETURN NEXT results_eq(
		'SELECT sku, case_price_base FROM dirac.product_offer WHERE product_id = (SELECT id FROM dirac.product WHERE barcode = ''00000000000000'')',
		'SELECT ''SKU001''::varchar(127), 99.99::decimal(19,4)',
		'Product offer should be created with correct values'
	);

	-- Verify NULL discount function IDs are converted to 1
	RETURN NEXT results_eq(
		'SELECT product_level_discount_function_id, brand_level_discount_function_id FROM dirac.product_offer WHERE product_id = (SELECT id FROM dirac.product WHERE barcode = ''00000000000000'')',
		'SELECT 1::bigint, 1::bigint',
		'NULL discount function IDs should be converted to 1'
	);


END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_basic_insert() OWNER TO postgres;

--
-- Name: test_bulk_upsert_brand_resolution(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_brand_resolution() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_products dirac.product_input[];
	v_existing_brand_id BIGINT;
	v_supplier_id BIGINT;
	v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
	-- Setup: Create existing brand
	INSERT INTO dirac.brand (name, slug, embedding) VALUES ('Existing Brand', 'existing-brand', array_fill(0, ARRAY[768])::vector) RETURNING id INTO v_existing_brand_id;
	INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer BR', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
	-- Add USD currency and US country if not already present
	INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
	INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
	VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;

	-- Test products with various brand configurations
	v_products := ARRAY[
		-- Product with brand_id provided
		ROW(NULL, 'Product with ID', '00000000000116', NULL, v_existing_brand_id, NULL, v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU005', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
		-- Product with only brand_name (existing)
		ROW(NULL, 'Product with existing name', '00000000000222', NULL, NULL, 'Existing Brand', v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU006', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
		-- Product with only brand_name (new)
		ROW(NULL, 'Product with new brand', '00000000000338', NULL, NULL, 'New Brand', v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU007', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
		-- Product with both brand_id and brand_name (id takes precedence)
		ROW(NULL, 'Product with both', '00000000000444', NULL, v_existing_brand_id, 'Different Brand', v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU008', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
	];

	-- Execute function
	PERFORM dirac.bulk_upsert_products(v_products);

	-- Verify brand_id was used directly
	RETURN NEXT results_eq(
		format('SELECT brand_id FROM dirac.product WHERE barcode = ''00000000000116'''),
		format('SELECT %s::bigint', v_existing_brand_id),
		'Product with brand_id should use provided brand_id'
	);

	-- Verify brand_name was resolved to existing brand_id
	RETURN NEXT results_eq(
		format('SELECT brand_id FROM dirac.product WHERE barcode = ''00000000000222'''),
		format('SELECT %s::bigint', v_existing_brand_id),
		'Product with existing brand_name should resolve to existing brand_id'
	);

	-- Verify new brand was created
	RETURN NEXT ok(
		EXISTS(SELECT 1 FROM dirac.brand WHERE name = 'New Brand'),
		'New brand should be created when brand_name is new'
	);

	-- Verify new brand was assigned to product
	RETURN NEXT results_eq(
		'SELECT b.name FROM dirac.product p JOIN dirac.brand b ON p.brand_id = b.id WHERE p.barcode = ''00000000000338''',
		'SELECT ''New Brand''::varchar(255)',
		'Product should be linked to newly created brand'
	);

	-- Verify brand_id takes precedence over brand_name
	RETURN NEXT results_eq(
		format('SELECT brand_id FROM dirac.product WHERE barcode = ''00000000000444'''),
		format('SELECT %s::bigint', v_existing_brand_id),
		'brand_id should take precedence when both brand_id and brand_name are provided'
	);


END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_brand_resolution() OWNER TO postgres;

--
-- Name: test_bulk_upsert_brand_slug_conflict(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_brand_slug_conflict() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_products dirac.product_input[];
	v_brand_count BIGINT;
	v_supplier_id BIGINT;
	v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
	-- Setup: Insert a brand that will create a slug conflict
	INSERT INTO dirac.brand (name, slug, embedding) VALUES ('Bear Coffee', 'bear-coffee', array_fill(0, ARRAY[768])::vector);
	INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer BSC', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
	INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;

	-- Test: Try to insert products with brand names that would create same slug
	v_products := ARRAY[
		ROW(
			NULL,                          -- product_id
			'Product 1',                    -- name
			NULL,                          -- barcode
			NULL,                          -- image_id
			NULL,                          -- brand_id
			'Bear coffee',                 -- brand_name (different case)
			v_dummy_embedding,             -- brand_embedding
			v_dummy_embedding,             -- product_embedding
			NULL,                          -- pack_size
			NULL::dirac.volume,            -- volume
			NULL, NULL,                    -- shelf_life_days, is_gluten_free
			NULL, NULL,                    -- tariff_code, tariff_code_country
			'SKU001',                      -- sku
			v_supplier_id,                 -- supplier_id
			1, 1,                          -- discount_function_id, brand_discount_function_id
			10.50, 'USD',                  -- case_price_base, case_price_currency
			NULL,                          -- country_of_origin
			NULL,                          -- eu_goods_tier
			NULL,                          -- moq_cases
			TRUE,                          -- is_offer_active
			12,                            -- units_per_case
			NULL,                          -- case_barcode
			NULL, NULL,                    -- cases_per_layer, layers_per_pallet
			NULL, NULL, NULL, NULL,        -- case_weight, case_height, case_width, case_length
			0.2000                         -- uk_vat_fraction
		)::dirac.product_input,
		ROW(
			NULL,                          -- product_id
			'Product 2',                    -- name
			NULL,                          -- barcode
			NULL,                          -- image_id
			NULL,                          -- brand_id
			'BEAR COFFEE',                 -- brand_name (different case)
			v_dummy_embedding,             -- brand_embedding
			v_dummy_embedding,             -- product_embedding
			NULL,                          -- pack_size
			NULL::dirac.volume,            -- volume
			NULL, NULL,                    -- shelf_life_days, is_gluten_free
			NULL, NULL,                    -- tariff_code, tariff_code_country
			'SKU002',                      -- sku
			v_supplier_id,                 -- supplier_id
			1, 1,                          -- discount_function_id, brand_discount_function_id
			15.00, 'USD',                  -- case_price_base, case_price_currency
			NULL,                          -- country_of_origin
			NULL,                          -- eu_goods_tier
			NULL,                          -- moq_cases
			TRUE,                          -- is_offer_active
			6,                             -- units_per_case
			NULL,                          -- case_barcode
			NULL, NULL,                    -- cases_per_layer, layers_per_pallet
			NULL, NULL, NULL, NULL,        -- case_weight, case_height, case_width, case_length
			0.2000                         -- uk_vat_fraction
		)::dirac.product_input
	];

	-- This should work without errors due to ON CONFLICT (slug) DO NOTHING
	PERFORM dirac.bulk_upsert_products(v_products);
	RETURN NEXT pass('Should handle brand slug conflicts without errors');

	-- Verify we still have only one brand with that slug
	SELECT COUNT(*) INTO v_brand_count FROM dirac.brand WHERE slug = 'bear-coffee';
	RETURN NEXT is(v_brand_count, 1::BIGINT, 'Should have only one brand with slug bear-coffee');

	-- Verify products were still created
	RETURN NEXT results_eq(
		'SELECT COUNT(*) FROM dirac.product WHERE name IN (''Product 1'', ''Product 2'')',
		'SELECT 2::BIGINT',
		'Should create both products despite brand slug conflict'
	);

END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_brand_slug_conflict() OWNER TO postgres;

--
-- Name: test_bulk_upsert_duplicate_brand_slugs(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_duplicate_brand_slugs() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_supplier_id BIGINT;
    v_brand_count BIGINT;
    v_brand_name TEXT;
    v_product_count BIGINT;
    v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
    RETURN NEXT has_function('dirac', 'bulk_upsert_products', ARRAY['dirac.product_input[]'], 'bulk_upsert_products function should exist');

    -- Setup: Create supplier and currency
    INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer DBS', v_dummy_embedding) RETURNING id INTO v_supplier_id;
    INSERT INTO dirac.currency (iso_4217, name) VALUES ('GBP', 'British Pound Sterling') ON CONFLICT (iso_4217) DO NOTHING;
    INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
    VALUES ('GB', 'GBR', 'United Kingdom', 'United Kingdom of Great Britain and Northern Ireland', 'GBP')
    ON CONFLICT (iso_3166_2) DO NOTHING;

    -- Test: Insert products with brand names that generate same slug but different product names
    PERFORM dirac.bulk_upsert_products(ARRAY[
        ROW(
            NULL, 'Coffee Beans Dark Roast', NULL, NULL, NULL, 'Test Brand', v_dummy_embedding, v_dummy_embedding,
            NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL,
            'SKU001', v_supplier_id, 1, 1, 10.00, 'GBP', 'GB', NULL, NULL, TRUE,
            12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000
        )::dirac.product_input,
        ROW(
            NULL, 'Coffee Beans Medium Roast', NULL, NULL, NULL, 'Test-Brand', v_dummy_embedding, v_dummy_embedding,
            NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL,
            'SKU002', v_supplier_id, 1, 1, 15.00, 'GBP', 'GB', NULL, NULL, TRUE,
            24, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000
        )::dirac.product_input,
        ROW(
            NULL, 'Coffee Beans Light Roast', NULL, NULL, NULL, 'TEST BRAND', v_dummy_embedding, v_dummy_embedding,
            NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL,
            'SKU003', v_supplier_id, 1, 1, 8.00, 'GBP', 'GB', NULL, NULL, TRUE,
            6, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000
        )::dirac.product_input
    ]);

    -- Verify only one brand was created
    SELECT COUNT(*) INTO v_brand_count FROM dirac.brand WHERE slug = 'test-brand';
    RETURN NEXT is(v_brand_count, 1::BIGINT, 'Should create only one brand with slug test-brand');

    -- Verify brand name is from first occurrence
    SELECT name INTO v_brand_name FROM dirac.brand WHERE slug = 'test-brand';
    RETURN NEXT is(v_brand_name, 'Test Brand', 'Should use first brand name encountered');

    -- Verify all products were created
    SELECT COUNT(*) INTO v_product_count
    FROM dirac.product p
    JOIN dirac.brand b ON p.brand_id = b.id
    WHERE b.slug = 'test-brand';
    RETURN NEXT is(v_product_count, 3::BIGINT, 'Should create all 3 products with the single brand');

    -- Cleanup
    DELETE FROM dirac.product_offer WHERE supplier_id = v_supplier_id;
    DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE brand_id IN (SELECT id FROM dirac.brand WHERE slug = 'test-brand'));
    DELETE FROM dirac.product WHERE brand_id IN (SELECT id FROM dirac.brand WHERE slug = 'test-brand');
    DELETE FROM dirac.brand WHERE slug = 'test-brand';
    DELETE FROM dirac.supplier WHERE id = v_supplier_id;
END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_duplicate_brand_slugs() OWNER TO postgres;

--
-- Name: test_bulk_upsert_duplicate_product_names_no_barcode(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_duplicate_product_names_no_barcode() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_supplier_id BIGINT;
    v_brand_id_1 BIGINT;
    v_brand_id_2 BIGINT;
    v_product_count BIGINT;
    v_product_name TEXT;
    v_product_brand_id BIGINT;
    v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
    RETURN NEXT has_function('dirac', 'bulk_upsert_products', ARRAY['dirac.product_input[]'], 'bulk_upsert_products function should exist');

    -- Setup: Create manufacturer, brands, and currency
    INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer DUPLICATEPRODUCTNAMES', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
    INSERT INTO dirac.brand (name, slug, embedding) VALUES ('Brand One', 'brand-one', array_fill(0, ARRAY[768])::vector) RETURNING id INTO v_brand_id_1;
    INSERT INTO dirac.brand (name, slug, embedding) VALUES ('Brand Two', 'brand-two', array_fill(0, ARRAY[768])::vector) RETURNING id INTO v_brand_id_2;
    INSERT INTO dirac.currency (iso_4217, name) VALUES ('GBP', 'British Pound Sterling') ON CONFLICT (iso_4217) DO NOTHING;
    INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
    VALUES ('GB', 'GBR', 'United Kingdom', 'United Kingdom of Great Britain and Northern Ireland', 'GBP') ON CONFLICT (iso_3166_2) DO NOTHING;

    -- Test: Insert products without barcodes that have identical/similar names
    PERFORM dirac.bulk_upsert_products(ARRAY[
        ROW(
            NULL, 'Coffee Beans', NULL, NULL, v_brand_id_1, NULL, v_dummy_embedding, v_dummy_embedding,
            NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL,
            'SKU001', v_supplier_id, NULL, NULL, 10.00, 'GBP', 'GB', NULL, 1, TRUE,
            12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000
        )::dirac.product_input,
        ROW(
            NULL, 'Coffee Beans', NULL, NULL, v_brand_id_2, NULL, v_dummy_embedding, v_dummy_embedding,
            NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL,
            'SKU002', v_supplier_id, NULL, NULL, 15.00, 'GBP', 'GB', NULL, 1, TRUE,
            24, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000
        )::dirac.product_input,
        ROW(
            NULL, 'Coffee-Beans', NULL, NULL, v_brand_id_1, NULL, v_dummy_embedding, v_dummy_embedding,
            NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL,
            'SKU003', v_supplier_id, NULL, NULL, 8.00, 'GBP', 'GB', NULL, 1, TRUE,
            6, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000
        )::dirac.product_input
    ]);

    -- Verify only one product was created with slug 'coffee-beans'
    SELECT COUNT(*) INTO v_product_count FROM dirac.product WHERE slug = 'coffee-beans';
    RETURN NEXT is(v_product_count, 1::BIGINT, 'Should create only one product with slug coffee-beans');

    -- Verify product details
    SELECT name, brand_id INTO v_product_name, v_product_brand_id
    FROM dirac.product WHERE slug = 'coffee-beans';
    RETURN NEXT is(v_product_name, 'Coffee Beans', 'Should use first product name encountered');
    RETURN NEXT is(v_product_brand_id, v_brand_id_1, 'Should use first brand_id encountered');

    -- Verify product offers were created for all SKUs (should be deduplicated by supplier_id, product_id)
    SELECT COUNT(*) INTO v_product_count
    FROM dirac.product_offer po
    JOIN dirac.product p ON po.product_id = p.id
    WHERE p.slug = 'coffee-beans' AND po.supplier_id = v_supplier_id;
    RETURN NEXT is(v_product_count, 1::BIGINT, 'Should create only one product offer due to duplicate (supplier_id, product_id)');

    -- Cleanup
    DELETE FROM dirac.product_offer WHERE supplier_id = v_supplier_id;
    DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE slug = 'coffee-beans');
    DELETE FROM dirac.product WHERE slug = 'coffee-beans';
    DELETE FROM dirac.brand WHERE id IN (v_brand_id_1, v_brand_id_2);
    DELETE FROM dirac.supplier WHERE id = v_supplier_id;
END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_duplicate_product_names_no_barcode() OWNER TO postgres;

--
-- Name: test_bulk_upsert_error_handling(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_error_handling() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_products dirac.product_input[];
	v_error_caught BOOLEAN := false;
	v_supplier_id_1 BIGINT;
	v_supplier_id_2 BIGINT;
BEGIN
	-- Test 1: NULL array
	BEGIN
		PERFORM dirac.bulk_upsert_products(NULL);
		v_error_caught := false;
	EXCEPTION WHEN OTHERS THEN
		v_error_caught := true;
	END;
	RETURN NEXT ok(v_error_caught, 'NULL array should raise exception');

	-- Test 2: Empty array
	v_error_caught := false;
	BEGIN
		PERFORM dirac.bulk_upsert_products(ARRAY[]::dirac.product_input[]);
		v_error_caught := false;
	EXCEPTION WHEN OTHERS THEN
		v_error_caught := true;
	END;
	RETURN NEXT ok(v_error_caught, 'Empty array should raise exception');

	-- Test 3: Product with NULL barcode is now allowed (nullable barcode)
	v_error_caught := false;
	BEGIN
		-- Clean up any existing test data first
		DELETE FROM dirac.product_offer WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		UPDATE dirac.product SET web_product_case_id = NULL WHERE name = 'No Barcode Product EH';
		DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		DELETE FROM dirac.product_detail WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		DELETE FROM dirac.product WHERE name = 'No Barcode Product EH';
		DELETE FROM dirac.brand WHERE name = 'Test Brand EH NBP';

		INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer EH1', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id_1;
		-- Add USD currency and US country if not already present
		INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
		INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
		VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;
		v_products := ARRAY[
			ROW(NULL, 'No Barcode Product EH', NULL, NULL, NULL, 'Test Brand EH NBP', array_fill(0.1::float4, ARRAY[768])::vector(768), array_fill(0.1::float4, ARRAY[768])::vector(768), NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU999', v_supplier_id_1, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
		];
		PERFORM dirac.bulk_upsert_products(v_products);
		-- Clean up the successfully created product (delete child records first)
		DELETE FROM dirac.product_offer WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		-- Must set web_product_case_id to NULL before deleting product_case
		UPDATE dirac.product SET web_product_case_id = NULL WHERE name = 'No Barcode Product EH';
		DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		DELETE FROM dirac.product_detail WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		DELETE FROM dirac.product WHERE name = 'No Barcode Product EH';
		DELETE FROM dirac.brand WHERE name = 'Test Brand EH NBP';
		DELETE FROM dirac.supplier WHERE id = v_supplier_id_1;
	EXCEPTION WHEN OTHERS THEN
		v_error_caught := true;
		-- Clean up any partially created records
		DELETE FROM dirac.product_offer WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		UPDATE dirac.product SET web_product_case_id = NULL WHERE name = 'No Barcode Product EH';
		DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		DELETE FROM dirac.product_detail WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'No Barcode Product EH');
		DELETE FROM dirac.product WHERE name = 'No Barcode Product EH';
		DELETE FROM dirac.brand WHERE name = 'Test Brand EH NBP';
		DELETE FROM dirac.supplier WHERE id = v_supplier_id_1;
	END;
	RETURN NEXT ok(NOT v_error_caught, 'Product with NULL barcode should be allowed now');

	-- Test 4: Invalid barcode format
	v_error_caught := false;
	BEGIN
		INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer EH2', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id_2;
		-- Add USD currency and US country if not already present
		INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
		INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
		VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;
		v_products := ARRAY[
			ROW(NULL, 'Invalid Barcode', 'INVALID123', NULL, NULL, NULL, array_fill(0.1::float4, ARRAY[768])::vector(768), array_fill(0.1::float4, ARRAY[768])::vector(768), NULL, NULL::dirac.volume, NULL, NULL, NULL, NULL, 'SKU998', v_supplier_id_2, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
		];
		PERFORM dirac.bulk_upsert_products(v_products);
		v_error_caught := false;
	EXCEPTION WHEN OTHERS THEN
		v_error_caught := true;
		DELETE FROM dirac.supplier WHERE id = v_supplier_id_2;
	END;
	RETURN NEXT ok(v_error_caught, 'Invalid barcode format should raise exception');


END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_error_handling() OWNER TO postgres;

--
-- Name: test_bulk_upsert_mixed_barcode_products(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_mixed_barcode_products() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_products dirac.product_input[];
    v_product_count INT;
    v_supplier_id BIGINT;
    v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
    -- Setup
    INSERT INTO dirac.supplier (name, embedding) VALUES ( 'Mixed Test Manufacturer', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
    INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
    INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
    VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;

    -- Test: Insert mix of products with and without barcodes
    v_products := ARRAY[
        ROW(NULL, 'Product With Barcode Mixed', '1234567890128', NULL, NULL, 'Brand Mixed 1', v_dummy_embedding, v_dummy_embedding, 1, ROW(400, 'ml')::dirac.volume, 30, true, NULL, NULL, 'SKU-MX-001', v_supplier_id, NULL, NULL, 50.00, 'USD', 'US', NULL, 10, TRUE, 12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
        ROW(NULL, 'Product Without Barcode Mixed', NULL, NULL, NULL, 'Brand Mixed 2', v_dummy_embedding, v_dummy_embedding, 1, ROW(600, 'ml')::dirac.volume, 45, false, NULL, NULL, 'SKU-MX-002', v_supplier_id, NULL, NULL, 60.00, 'USD', 'US', NULL, 10, TRUE, 12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
        ROW(NULL, 'Another Product With Barcode', '9876543210982', NULL, NULL, 'Brand Mixed 3', v_dummy_embedding, v_dummy_embedding, 1, ROW(500, 'ml')::dirac.volume, 60, true, NULL, NULL, 'SKU-MX-003', v_supplier_id, NULL, NULL, 70.00, 'USD', 'US', NULL, 10, TRUE, 12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
    ];

    PERFORM dirac.bulk_upsert_products(v_products);

    -- Check all products were created
    SELECT COUNT(*) INTO v_product_count FROM dirac.product
    WHERE name IN ('Product With Barcode Mixed', 'Product Without Barcode Mixed', 'Another Product With Barcode');
    RETURN NEXT is(v_product_count, 3, 'All three products should be created');

    -- Check products with barcodes have barcodes
    RETURN NEXT ok(
        EXISTS(SELECT 1 FROM dirac.product WHERE name = 'Product With Barcode Mixed' AND barcode IS NOT NULL),
        'Product with barcode should have barcode stored'
    );

    -- Check product without barcode has NULL barcode but has slug
    RETURN NEXT ok(
        EXISTS(SELECT 1 FROM dirac.product WHERE name = 'Product Without Barcode Mixed' AND barcode IS NULL AND slug = 'product-without-barcode-mixed'),
        'Product without barcode should have NULL barcode but valid slug'
    );

    -- Test update: Update the product without barcode by name
    v_products := ARRAY[
        ROW(NULL, 'Product Without Barcode Mixed', NULL, NULL, NULL, 'Brand Mixed 2 Updated', v_dummy_embedding, v_dummy_embedding, 2, ROW(700, 'ml')::dirac.volume, 50, true, NULL, NULL, 'SKU-MX-002-U', v_supplier_id, NULL, NULL, 65.00, 'USD', 'US', NULL, 10, TRUE, 12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
    ];

    PERFORM dirac.bulk_upsert_products(v_products);

    -- Check product was updated, not duplicated
    SELECT COUNT(*) INTO v_product_count FROM dirac.product WHERE name = 'Product Without Barcode Mixed';
    RETURN NEXT is(v_product_count, 1, 'Product without barcode should be updated by name match');

    -- Cleanup (delete child records first)
    DELETE FROM dirac.product_offer WHERE product_id IN (SELECT id FROM dirac.product WHERE name IN ('Product With Barcode Mixed', 'Product Without Barcode Mixed', 'Another Product With Barcode'));
    DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE name IN ('Product With Barcode Mixed', 'Product Without Barcode Mixed', 'Another Product With Barcode'));
    DELETE FROM dirac.product_detail WHERE product_id IN (SELECT id FROM dirac.product WHERE name IN ('Product With Barcode Mixed', 'Product Without Barcode Mixed', 'Another Product With Barcode'));
    DELETE FROM dirac.product WHERE name IN ('Product With Barcode Mixed', 'Product Without Barcode Mixed', 'Another Product With Barcode');
    DELETE FROM dirac.brand WHERE name LIKE 'Brand Mixed%';
    DELETE FROM dirac.supplier WHERE id = v_supplier_id;
END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_mixed_barcode_products() OWNER TO postgres;

--
-- Name: test_bulk_upsert_name_conflict_without_barcode(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_name_conflict_without_barcode() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_products dirac.product_input[];
    v_product_count INT;
    v_supplier_id BIGINT;
    v_brand_name TEXT;
    v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
    -- Setup
    INSERT INTO dirac.supplier (name, embedding) VALUES ( 'Conflict Test Manufacturer', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
    INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
    INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
    VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;

    -- Insert initial product without barcode
    v_products := ARRAY[
        ROW(NULL, 'Unique Product Name Conflict Test', NULL, NULL, NULL, 'Original Brand', v_dummy_embedding, v_dummy_embedding, 1, ROW(400, 'ml')::dirac.volume, 30, true, NULL, NULL, 'SKU-CF-001', v_supplier_id, NULL, NULL, 50.00, 'USD', 'US', NULL, 10, TRUE, 12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
    ];
    PERFORM dirac.bulk_upsert_products(v_products);

    -- Try to insert another product with same name but different details
    v_products := ARRAY[
        ROW(NULL, 'Unique Product Name Conflict Test', NULL, NULL, NULL, 'Different Brand', v_dummy_embedding, v_dummy_embedding, 2, ROW(800, 'ml')::dirac.volume, 60, false, NULL, NULL, 'SKU-CF-002', v_supplier_id, NULL, NULL, 100.00, 'USD', 'US', NULL, 20, TRUE, 24, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
    ];
    PERFORM dirac.bulk_upsert_products(v_products);

    -- Check only one product exists with this name
    SELECT COUNT(*) INTO v_product_count FROM dirac.product WHERE name = 'Unique Product Name Conflict Test';
    RETURN NEXT is(v_product_count, 1, 'Only one product should exist with unique name');

    -- Check which brand is associated (should be updated to 'Different Brand')
    SELECT b.name INTO v_brand_name
    FROM dirac.product p
    JOIN dirac.brand b ON p.brand_id = b.id
    WHERE p.name = 'Unique Product Name Conflict Test';
    RETURN NEXT is(v_brand_name, 'Different Brand', 'Brand should be updated on name conflict');

    -- Cleanup (delete child records first)
    DELETE FROM dirac.product_offer WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'Unique Product Name Conflict Test');
    DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'Unique Product Name Conflict Test');
    DELETE FROM dirac.product_detail WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'Unique Product Name Conflict Test');
    DELETE FROM dirac.product WHERE name = 'Unique Product Name Conflict Test';
    DELETE FROM dirac.brand WHERE name IN ('Original Brand', 'Different Brand');
    DELETE FROM dirac.supplier WHERE id = v_supplier_id;
END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_name_conflict_without_barcode() OWNER TO postgres;

--
-- Name: test_bulk_upsert_products_without_barcode(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_products_without_barcode() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_products dirac.product_input[];
    v_product_count INT;
    v_supplier_id BIGINT;
    v_product_id BIGINT;
    v_slug TEXT;
    v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
    -- Setup: Add manufacturer and currency if needed
    INSERT INTO dirac.supplier (name, embedding) VALUES ( 'Test Manufacturer No Barcode', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
    INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
    INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
    VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;

    -- Test 1: Insert product without barcode (should use name for uniqueness)
    v_products := ARRAY[
        ROW(NULL, 'Product Without Barcode', NULL, NULL, NULL, 'Brand No Barcode', v_dummy_embedding, v_dummy_embedding, 1, ROW(500, 'ml')::dirac.volume, 30, true, NULL, NULL, 'SKU-NO-BC-001', v_supplier_id, NULL, NULL, 100.00, 'USD', 'US', NULL, 10, TRUE, 12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
    ];

    PERFORM dirac.bulk_upsert_products(v_products);

    -- Check product was created
    SELECT COUNT(*) INTO v_product_count FROM dirac.product WHERE name = 'Product Without Barcode';
    RETURN NEXT is(v_product_count, 1, 'Product without barcode should be created');

    -- Check slug was auto-generated
    SELECT id, slug INTO v_product_id, v_slug FROM dirac.product WHERE name = 'Product Without Barcode';
    RETURN NEXT is(v_slug, 'product-without-barcode', 'Slug should be auto-generated from name');

    -- Test 2: Update product without barcode (should match by name)
    v_products := ARRAY[
        ROW(NULL, 'Product Without Barcode', NULL, NULL, NULL, 'Updated Brand No Barcode', v_dummy_embedding, v_dummy_embedding, 2, ROW(600, 'ml')::dirac.volume, 45, false, NULL, NULL, 'SKU-NO-BC-001', v_supplier_id, NULL, NULL, 120.00, 'USD', 'US', NULL, 10, TRUE, 12, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
    ];

    PERFORM dirac.bulk_upsert_products(v_products);

    -- Check product count is still 1 (updated, not duplicated)
    SELECT COUNT(*) INTO v_product_count FROM dirac.product WHERE name = 'Product Without Barcode';
    RETURN NEXT is(v_product_count, 1, 'Product without barcode should be updated, not duplicated');

    -- Check brand was updated
    RETURN NEXT ok(
        EXISTS(
            SELECT 1 FROM dirac.product p
            JOIN dirac.brand b ON p.brand_id = b.id
            WHERE p.name = 'Product Without Barcode'
            AND b.name = 'Updated Brand No Barcode'
        ),
        'Brand should be updated for product without barcode'
    );

    -- Cleanup (delete child records first)
    DELETE FROM dirac.product_offer WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'Product Without Barcode');
    DELETE FROM dirac.product_case WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'Product Without Barcode');
    DELETE FROM dirac.product_detail WHERE product_id IN (SELECT id FROM dirac.product WHERE name = 'Product Without Barcode');
    DELETE FROM dirac.product WHERE name = 'Product Without Barcode';
    DELETE FROM dirac.brand WHERE name IN ('Brand No Barcode', 'Updated Brand No Barcode');
    DELETE FROM dirac.supplier WHERE id = v_supplier_id;
END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_products_without_barcode() OWNER TO postgres;

--
-- Name: test_bulk_upsert_tariff_code(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_bulk_upsert_tariff_code() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_products dirac.product_input[];
	v_supplier_id BIGINT;
	v_dummy_embedding vector(768) := array_fill(0.1::float4, ARRAY[768])::vector(768);
BEGIN
	-- Setup: Add test tariff codes
	INSERT INTO dirac.supplier (name, embedding) VALUES ('Test Manufacturer TC', array_fill(0.1::float4, ARRAY[768])::vector(768)) RETURNING id INTO v_supplier_id;
	-- Add USD currency and US country if not already present
	INSERT INTO dirac.currency (iso_4217, name) VALUES ('USD', 'US Dollar') ON CONFLICT DO NOTHING;
	INSERT INTO dirac.country (iso_3166_2, iso_3166_3, name, official_name, currency)
	VALUES ('US', 'USA', 'United States', 'United States of America', 'USD') ON CONFLICT DO NOTHING;
	INSERT INTO dirac.customs_territory (code, name, harmonization_depth, tariff_schedule_name)
	VALUES ('US', 'United States', 10, 'HTS') ON CONFLICT DO NOTHING;
	INSERT INTO dirac.tariff_code (code, country, depth, description)
	VALUES ('870899', 'US', 6, 'Test tariff code') ON CONFLICT DO NOTHING;

	-- Test tariff code regex cleaning
	v_products := ARRAY[
		ROW(NULL, 'Product with dots', '00000000001007', NULL, NULL, NULL, v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, '8708.99', 'US', 'SKU013', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
		ROW(NULL, 'Product with dashes', '00000000002004', NULL, NULL, NULL, v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, '8708-99', 'US', 'SKU014', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input,
		ROW(NULL, 'Product with spaces', '00000000003001', NULL, NULL, NULL, v_dummy_embedding, v_dummy_embedding, NULL, NULL::dirac.volume, NULL, NULL, '8708 99', 'US', 'SKU015', v_supplier_id, NULL, NULL, 10.00, 'USD', NULL, NULL, NULL, TRUE, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0.2000)::dirac.product_input
	];

	-- Execute function
	PERFORM dirac.bulk_upsert_products(v_products);

	-- Verify tariff codes were cleaned and linked
	RETURN NEXT ok(
		EXISTS(
			SELECT 1 FROM dirac.product_tariff_classification ptc
			JOIN dirac.product p ON ptc.product_id = p.id
			JOIN dirac.tariff_code tc ON ptc.tariff_code_id = tc.id
			WHERE p.barcode = '00000000001007' AND tc.code = '870899'
		),
		'Tariff code with dots should be cleaned to digits only'
	);

	RETURN NEXT ok(
		EXISTS(
			SELECT 1 FROM dirac.product_tariff_classification ptc
			JOIN dirac.product p ON ptc.product_id = p.id
			JOIN dirac.tariff_code tc ON ptc.tariff_code_id = tc.id
			WHERE p.barcode = '00000000002004' AND tc.code = '870899'
		),
		'Tariff code with dashes should be cleaned to digits only'
	);


END;
$$;


ALTER FUNCTION dirac.test_bulk_upsert_tariff_code() OWNER TO postgres;

--
-- Name: test_calculate_order_total_empty(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_calculate_order_total_empty() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_total_excl_vat DECIMAL(19,4);
    v_total_vat DECIMAL(19,4);
    v_total_incl_vat DECIMAL(19,4);
    v_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('totaltest5@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create empty order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Calculate total (no items)
    SELECT * INTO v_total_excl_vat, v_total_vat, v_total_incl_vat, v_currency FROM dirac.calculate_order_total(v_order_id);

    RETURN NEXT is(
        v_total_excl_vat,
        NULL::DECIMAL(19,4),
        'Empty order should return NULL total'
    );

    RETURN NEXT is(
        v_currency,
        NULL::CHAR(3),
        'Empty order should return NULL currency'
    );

    -- Clean up
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_calculate_order_total_empty() OWNER TO postgres;

--
-- Name: test_calculate_order_total_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_calculate_order_total_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'dirac',
        'calculate_order_total',
        ARRAY['bigint'],
        'dirac.calculate_order_total function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_calculate_order_total_exists() OWNER TO postgres;

--
-- Name: test_calculate_order_total_mixed_discounts(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_calculate_order_total_mixed_discounts() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product1_id BIGINT;
    v_product_case1_id BIGINT;
    v_product2_id BIGINT;
    v_product_case2_id BIGINT;
    v_product3_id BIGINT;
    v_product_case3_id BIGINT;
    v_total_excl_vat DECIMAL(19,4);
    v_total_vat DECIMAL(19,4);
    v_total_incl_vat DECIMAL(19,4);
    v_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('totaltest4@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create products
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Full Price', 'full-price-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product1_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product1_id, 12)
    RETURNING id INTO v_product_case1_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('10% Off', '10pct-off-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product2_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product2_id, 12)
    RETURNING id INTO v_product_case2_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('$5 Off', '5-off-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product3_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product3_id, 12)
    RETURNING id INTO v_product_case3_id;

    -- Add order items with various discounts
    -- Item 1: No discount - 5 cases at $20 = $100
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case1_id, 5, 20.0000, 'USD');

    -- Item 2: With discount - 10 cases at $10 = $100, discount $10 = $90
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, discount_applied)
    VALUES (v_order_id, v_product_case2_id, 10, 10.0000, 'USD', 10.0000);

    -- Item 3: With discount - 2 cases at $50 = $100, discount $5 = $95
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, discount_applied)
    VALUES (v_order_id, v_product_case3_id, 2, 50.0000, 'USD', 5.0000);

    -- Calculate total
    SELECT * INTO v_total_excl_vat, v_total_vat, v_total_incl_vat, v_currency FROM dirac.calculate_order_total(v_order_id);

    -- Expected: $100 + $90 + $95 = $285
    RETURN NEXT is(
        v_total_excl_vat,
        285.0000::DECIMAL(19,4),
        'Total should be $100 + $90 + $95 = $285'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id IN (v_product_case1_id, v_product_case2_id, v_product_case3_id);
    DELETE FROM dirac.product WHERE id IN (v_product1_id, v_product2_id, v_product3_id);
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_calculate_order_total_mixed_discounts() OWNER TO postgres;

--
-- Name: test_calculate_order_total_multiple_items(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_calculate_order_total_multiple_items() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product1_id BIGINT;
    v_product_case1_id BIGINT;
    v_product2_id BIGINT;
    v_product_case2_id BIGINT;
    v_product3_id BIGINT;
    v_product_case3_id BIGINT;
    v_total_excl_vat DECIMAL(19,4);
    v_total_vat DECIMAL(19,4);
    v_total_incl_vat DECIMAL(19,4);
    v_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('totaltest2@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create products
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Product A', 'product-a-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product1_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product1_id, 12)
    RETURNING id INTO v_product_case1_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Product B', 'product-b-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product2_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product2_id, 12)
    RETURNING id INTO v_product_case2_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Product C', 'product-c-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product3_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product3_id, 12)
    RETURNING id INTO v_product_case3_id;

    -- Add order items
    -- Item 1: 5 cases at $10.00 = $50.00
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case1_id, 5, 10.0000, 'USD');

    -- Item 2: 2 cases at $25.50 = $51.00
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case2_id, 2, 25.5000, 'USD');

    -- Item 3: 100 cases at $0.99 = $99.00
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case3_id, 100, 0.9900, 'USD');

    -- Calculate total
    SELECT * INTO v_total_excl_vat, v_total_vat, v_total_incl_vat, v_currency FROM dirac.calculate_order_total(v_order_id);

    -- Expected: $50.00 + $51.00 + $99.00 = $200.00
    RETURN NEXT is(
        v_total_excl_vat,
        200.0000::DECIMAL(19,4),
        'Total should be sum of all items: $50 + $51 + $99 = $200'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id IN (v_product_case1_id, v_product_case2_id, v_product_case3_id);
    DELETE FROM dirac.product WHERE id IN (v_product1_id, v_product2_id, v_product3_id);
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_calculate_order_total_multiple_items() OWNER TO postgres;

--
-- Name: test_calculate_order_total_precision(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_calculate_order_total_precision() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_total_excl_vat DECIMAL(19,4);
    v_total_vat DECIMAL(19,4);
    v_total_incl_vat DECIMAL(19,4);
    v_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('totaltest6@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Precision Test', 'precision-test-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Add order item with precise decimal: 3 cases at $33.3333 = $99.9999
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 3, 33.3333, 'USD');

    -- Calculate total
    SELECT * INTO v_total_excl_vat, v_total_vat, v_total_incl_vat, v_currency FROM dirac.calculate_order_total(v_order_id);

    RETURN NEXT is(
        v_total_excl_vat,
        99.9999::DECIMAL(19,4),
        'Total should maintain 4 decimal places precision'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_calculate_order_total_precision() OWNER TO postgres;

--
-- Name: test_calculate_order_total_single_item(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_calculate_order_total_single_item() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_total_excl_vat DECIMAL(19,4);
    v_total_vat DECIMAL(19,4);
    v_total_incl_vat DECIMAL(19,4);
    v_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('totaltest1@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create a simple product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Test Product', 'test-product-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Add order item: 10 cases at $5.00 each = $50.00
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 10, 5.0000, 'USD');

    -- Calculate total
    SELECT * INTO v_total_excl_vat, v_total_vat, v_total_incl_vat, v_currency FROM dirac.calculate_order_total(v_order_id);

    RETURN NEXT is(
        v_total_excl_vat,
        50.0000::DECIMAL(19,4),
        'Total should be 10 units Ã— $5.00 = $50.00'
    );

    RETURN NEXT is(
        v_currency,
        'USD'::CHAR(3),
        'Currency should be USD'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_calculate_order_total_single_item() OWNER TO postgres;

--
-- Name: test_calculate_order_total_with_discounts(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_calculate_order_total_with_discounts() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_total_excl_vat DECIMAL(19,4);
    v_total_vat DECIMAL(19,4);
    v_total_incl_vat DECIMAL(19,4);
    v_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('totaltest3@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Discounted Product', 'discounted-product-total', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Add order item with discount
    -- 10 cases at $10.00 = $100.00, discount of $15.00 = $85.00
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, discount_applied)
    VALUES (v_order_id, v_product_case_id, 10, 10.0000, 'USD', 15.0000);

    -- Calculate total
    SELECT * INTO v_total_excl_vat, v_total_vat, v_total_incl_vat, v_currency FROM dirac.calculate_order_total(v_order_id);

    RETURN NEXT is(
        v_total_excl_vat,
        85.0000::DECIMAL(19,4),
        'Total should be $100 - $15 discount = $85'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_calculate_order_total_with_discounts() OWNER TO postgres;

--
-- Name: test_check_email_edge_cases(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_check_email_edge_cases() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Null input
    RETURN NEXT ok(
        check_email(NULL) IS NULL,
        'NULL email should return NULL (due to STRICT modifier)'
    );

    -- Empty string
    RETURN NEXT ok(
        NOT check_email(''),
        'Empty string should be invalid'
    );

    -- Just whitespace
    RETURN NEXT ok(
        NOT check_email('   '),
        'Whitespace-only string should be invalid'
    );

    -- Very long local part (over 64 chars - RFC limit)
    -- Note: email_validator library doesn't enforce the 64-char RFC limit
    -- This is acceptable as it focuses on practical validation
    RETURN NEXT ok(
        check_email(repeat('a', 65) || '@gmail.com'),
        'Email with local part over 64 chars is accepted by email_validator'
    );

    -- Very long domain (over 253 chars - RFC limit)
    RETURN NEXT ok(
        NOT check_email('user@' || repeat('a', 250) || '.com'),
        'Email with domain over 253 chars should be invalid'
    );
END;
$$;


ALTER FUNCTION dirac.test_check_email_edge_cases() OWNER TO postgres;

--
-- Name: test_check_email_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_check_email_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'check_email',
        ARRAY['text'],
        'check_email function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_check_email_exists() OWNER TO postgres;

--
-- Name: test_check_email_invalid(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_check_email_invalid() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Missing @ symbol
    RETURN NEXT ok(
        NOT check_email('userexample.com'),
        'Email without @ symbol should be invalid'
    );

    -- Missing domain
    RETURN NEXT ok(
        NOT check_email('user@'),
        'Email without domain should be invalid'
    );

    -- Missing local part
    RETURN NEXT ok(
        NOT check_email('@gmail.com'),
        'Email without local part should be invalid'
    );

    -- Double @
    RETURN NEXT ok(
        NOT check_email('user@@gmail.com'),
        'Email with double @ should be invalid'
    );

    -- Spaces in email
    RETURN NEXT ok(
        NOT check_email('user name@gmail.com'),
        'Email with spaces should be invalid'
    );

    -- Invalid characters
    RETURN NEXT ok(
        NOT check_email('user<>@gmail.com'),
        'Email with invalid characters should be invalid'
    );

    -- Missing TLD
    RETURN NEXT ok(
        NOT check_email('user@example'),
        'Email without TLD might be invalid (depends on deliverability check)'
    );

    -- Invalid TLD
    RETURN NEXT ok(
        NOT check_email('user@example.c'),
        'Email with single-char TLD should be invalid'
    );
END;
$$;


ALTER FUNCTION dirac.test_check_email_invalid() OWNER TO postgres;

--
-- Name: test_check_email_special_valid(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_check_email_special_valid() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Uppercase letters (should be valid, emails are case-insensitive)
    RETURN NEXT ok(
        check_email('User@Gmail.COM'),
        'Email with uppercase letters should be valid'
    );

    -- Underscores
    RETURN NEXT ok(
        check_email('user_name@gmail.com'),
        'Email with underscores should be valid'
    );

    -- Numbers in domain (using real domain)
    RETURN NEXT ok(
        check_email('user@163.com'),
        'Email with numbers in domain should be valid'
    );

    -- Multiple subdomains (using real domain)
    RETURN NEXT ok(
        check_email('user@mail.google.com'),
        'Email with multiple subdomains should be valid'
    );
END;
$$;


ALTER FUNCTION dirac.test_check_email_special_valid() OWNER TO postgres;

--
-- Name: test_check_email_undeliverable(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_check_email_undeliverable() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Non-existent domain
    -- Note: This test assumes the domain doesn't exist
    RETURN NEXT ok(
        NOT check_email('user@thisdomaindefinitelydoesnotexist12345.com'),
        'Email with non-existent domain should be undeliverable'
    );

    -- Invalid TLD that doesn't exist
    RETURN NEXT ok(
        NOT check_email('user@example.invalidtld'),
        'Email with invalid TLD should be undeliverable'
    );
END;
$$;


ALTER FUNCTION dirac.test_check_email_undeliverable() OWNER TO postgres;

--
-- Name: test_check_email_valid(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_check_email_valid() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Standard email format (using gmail.com which has MX records)
    RETURN NEXT ok(
        check_email('user@gmail.com'),
        'Standard email format should be valid'
    );

    -- Email with subdomain (using a real domain)
    RETURN NEXT ok(
        check_email('user@mail.google.com'),
        'Email with subdomain should be valid'
    );

    -- Email with numbers
    RETURN NEXT ok(
        check_email('user123@gmail.com'),
        'Email with numbers should be valid'
    );

    -- Email with dots in local part
    RETURN NEXT ok(
        check_email('first.last@gmail.com'),
        'Email with dots in local part should be valid'
    );

    -- Email with plus sign (common for filters)
    RETURN NEXT ok(
        check_email('user+tag@gmail.com'),
        'Email with plus sign should be valid'
    );

    -- Email with hyphens (using a real domain with MX records)
    RETURN NEXT ok(
        check_email('user@yahoo.com'),
        'Email with common domain should be valid'
    );
END;
$$;


ALTER FUNCTION dirac.test_check_email_valid() OWNER TO postgres;

--
-- Name: test_create_account_duplicate_email(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_create_account_duplicate_email() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'duplicate@gmail.com';
    v_password TEXT := 'Password123';
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Test Browser';
    v_uuid1 UUID;
    v_error_message TEXT;
    v_user_count INTEGER;
BEGIN
    -- Create first account
    v_uuid1 := api.create_account(v_email, v_password, v_ip, v_user_agent);

    -- First should succeed
    RETURN NEXT ok(
        v_uuid1 IS NOT NULL,
        'First account creation should succeed'
    );

    -- Try to create duplicate account - should raise exception
    BEGIN
        PERFORM api.create_account(v_email, 'DifferentPassword', v_ip, v_user_agent);
        RETURN NEXT fail('Duplicate email should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN  -- RaiseError
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                format('Email %s already exists', v_email),
                'Duplicate email should raise RaiseError with appropriate message'
            );
    END;

    -- Verify only one user exists
    SELECT COUNT(*) INTO v_user_count FROM auth.user WHERE email = v_email;
    RETURN NEXT is(
        v_user_count,
        1,
        'Only one user should exist with the email'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
    DELETE FROM auth.user WHERE email = v_email;
END;
$$;


ALTER FUNCTION dirac.test_create_account_duplicate_email() OWNER TO postgres;

--
-- Name: test_create_account_edge_cases(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_create_account_edge_cases() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Test Browser';
    v_uuid UUID;
    v_email TEXT;
BEGIN
    -- Very long but valid email
    v_email := repeat('a', 50) || '@gmail.com';
    v_uuid := api.create_account(v_email, 'Password123', v_ip, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'Long email should be accepted if valid'
    );

    -- Clean up this test
    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
    DELETE FROM auth.user WHERE email = v_email;

    -- Unicode password
    v_uuid := api.create_account('unicode@gmail.com', 'Ð¿Ð°Ñ€Ð¾Ð»ÑŒå¯†ç ', v_ip, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'Unicode password should be accepted'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = 'unicode@gmail.com');
    DELETE FROM auth.user WHERE email = 'unicode@gmail.com';

    -- IPv6 address
    v_uuid := api.create_account('ipv6@gmail.com', 'Password123', '2001:db8::1'::inet, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'IPv6 address should be accepted'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = 'ipv6@gmail.com');
    DELETE FROM auth.user WHERE email = 'ipv6@gmail.com';
END;
$$;


ALTER FUNCTION dirac.test_create_account_edge_cases() OWNER TO postgres;

--
-- Name: test_create_account_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_create_account_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'api',
        'create_account',
        ARRAY['text', 'text', 'inet', 'text'],
        'api.create_account function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_create_account_exists() OWNER TO postgres;

--
-- Name: test_create_account_invalid_email(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_create_account_invalid_email() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_password TEXT := 'ValidPassword123';
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Test Browser';
    v_error_message TEXT;
BEGIN
    -- Test with invalid email format - should raise exception
    BEGIN
        PERFORM api.create_account('notanemail', v_password, v_ip, v_user_agent);
        RETURN NEXT fail('Invalid email should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0004' THEN  -- AssertError
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Invalid email',
                'Invalid email should raise AssertError with appropriate message'
            );
    END;

    -- Test with empty email
    BEGIN
        PERFORM api.create_account('', v_password, v_ip, v_user_agent);
        RETURN NEXT fail('Empty email should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0004' THEN  -- AssertError
            RETURN NEXT pass('Empty email raises AssertError');
    END;

    -- Test with null email
    BEGIN
        PERFORM api.create_account(NULL, v_password, v_ip, v_user_agent);
        RETURN NEXT fail('NULL email should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0004' THEN  -- AssertError
            RETURN NEXT pass('NULL email raises AssertError');
    END;

    -- Verify no users were created
    RETURN NEXT is(
        (SELECT COUNT(*) FROM auth.user WHERE email IN ('notanemail', '', NULL)),
        0::bigint,
        'No users should be created with invalid emails'
    );
END;
$$;


ALTER FUNCTION dirac.test_create_account_invalid_email() OWNER TO postgres;

--
-- Name: test_create_account_session_details(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_create_account_session_details() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'session.test@gmail.com';
    v_password TEXT := 'Password123';
    v_ip1 INET := '10.0.0.1'::inet;
    v_ip2 INET := '10.0.0.2'::inet;
    v_user_agent1 TEXT := 'Chrome/100.0';
    v_user_agent2 TEXT := 'Firefox/98.0';
    v_uuid1 UUID;
    v_uuid2 UUID;
    v_user_id BIGINT;
BEGIN
    -- Create account with first IP/UA
    v_uuid1 := api.create_account(v_email, v_password, v_ip1, v_user_agent1);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Login with different IP/UA (using login function to create another session)
    v_uuid2 := api.login(v_email, v_password, v_ip2, v_user_agent2);

    -- Both should have sessions
    RETURN NEXT ok(
        v_uuid1 IS NOT NULL AND v_uuid2 IS NOT NULL,
        'Both operations should create sessions'
    );

    -- Sessions should be different
    RETURN NEXT ok(
        v_uuid1 != v_uuid2,
        'Different sessions should have different UUIDs'
    );

    -- Verify both sessions exist with correct details
    RETURN NEXT is(
        (SELECT COUNT(*) FROM auth.web_session
         WHERE user_id = v_user_id
         AND ((ip = v_ip1 AND user_agent = v_user_agent1)
           OR (ip = v_ip2 AND user_agent = v_user_agent2))),
        2::bigint,
        'Both sessions should exist with correct IP and user agent'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_create_account_session_details() OWNER TO postgres;

--
-- Name: test_create_account_success(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_create_account_success() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_email TEXT := 'newuser@gmail.com';
    v_password TEXT := 'SecurePassword123!';
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Mozilla/5.0 Test Browser';
    v_uuid UUID;
    v_user_id BIGINT;
    v_session_count INTEGER;
BEGIN
    -- Create account
    v_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);

    -- Check UUID is returned
    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'Successful account creation should return a session UUID'
    );

    -- Verify user was created in auth.user table
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;
    RETURN NEXT ok(
        v_user_id IS NOT NULL,
        'User should be created in auth.user table'
    );

    -- Verify password was hashed (not stored as plain text)
    RETURN NEXT ok(
        NOT EXISTS(
            SELECT 1 FROM auth.user
            WHERE email = v_email AND password_hash = v_password
        ),
        'Password should be hashed, not stored as plain text'
    );

    -- Verify password hash starts with Argon2 identifier
    RETURN NEXT results_eq(
        format('SELECT password_hash LIKE ''$argon2%%'' FROM auth.user WHERE id = %s', v_user_id),
        'SELECT TRUE::boolean',
        'Password should be hashed with Argon2'
    );

    -- Verify session was created
    SELECT COUNT(*) INTO v_session_count
    FROM auth.web_session
    WHERE uuid = v_uuid AND user_id = v_user_id;

    RETURN NEXT is(
        v_session_count,
        1,
        'Session should be created for new account'
    );

    -- Verify session details
    RETURN NEXT results_eq(
        format('SELECT ip, user_agent FROM auth.web_session WHERE uuid = ''%s''', v_uuid),
        format('SELECT ''%s''::inet, ''%s''::text', v_ip, v_user_agent),
        'Session should store correct IP and user agent'
    );

    -- Verify session expiry is set (5 hours from now)
    RETURN NEXT ok(
        EXISTS(
            SELECT 1 FROM auth.web_session
            WHERE uuid = v_uuid
            AND expires_at > NOW()
            AND expires_at <= NOW() + INTERVAL '5 hours 1 minute'
        ),
        'Session should expire in approximately 5 hours'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_create_account_success() OWNER TO postgres;

--
-- Name: test_create_account_transaction_safety(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_create_account_transaction_safety() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'transaction.test@gmail.com';
    v_password TEXT := 'Password123';
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Test Browser';
    v_uuid UUID;
    v_initial_user_count BIGINT;
    v_initial_session_count BIGINT;
    v_final_user_count BIGINT;
    v_final_session_count BIGINT;
BEGIN
    -- Get initial counts
    SELECT COUNT(*) INTO v_initial_user_count FROM auth.user;
    SELECT COUNT(*) INTO v_initial_session_count FROM auth.web_session;

    -- First create a valid account
    v_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'First account creation should succeed'
    );

    -- Try to create duplicate (should fail and not affect counts)
    BEGIN
        PERFORM api.create_account(v_email, v_password, v_ip, v_user_agent);
        RETURN NEXT fail('Duplicate account creation should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            NULL; -- Expected error
    END;

    -- Get final counts
    SELECT COUNT(*) INTO v_final_user_count FROM auth.user;
    SELECT COUNT(*) INTO v_final_session_count FROM auth.web_session;

    -- Verify only one user was added (failed attempt didn't create partial data)
    RETURN NEXT is(
        v_final_user_count - v_initial_user_count,
        1::bigint,
        'Only one user should be added despite failed duplicate attempt'
    );

    -- Verify only one session was added
    RETURN NEXT is(
        v_final_session_count - v_initial_session_count,
        1::bigint,
        'Only one session should be added despite failed duplicate attempt'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
    DELETE FROM auth.user WHERE email = v_email;
END;
$$;


ALTER FUNCTION dirac.test_create_account_transaction_safety() OWNER TO postgres;

--
-- Name: test_discount_function_validation(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_discount_function_validation() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_discount_id BIGINT;
	v_valid_discounts dirac.discount_range[];
	v_invalid_discounts dirac.discount_range[];
BEGIN
	-- test everything exists
	RETURN NEXT has_table('dirac','discount_function','dirac.discount_function should exist');
	RETURN NEXT has_function('dirac', 'validate_discounts', ARRAY['dirac.discount_range[]'],'validate_discounts function should exist');

	-- Test default "No Discount" function exists with id 1
	RETURN NEXT ok(
		EXISTS(SELECT 1 FROM dirac.discount_function WHERE id = 1 AND name = 'No Discount'),
		'Default "No Discount" function should exist with id 1'
	);

	-- Test default discount function returns base price * qty (no discount)
	RETURN NEXT results_eq(
		'SELECT dirac.get_price(1, 100.00, 10)',
		'SELECT 1000.00::numeric(19,4)',
		'Default discount function (id=1) should apply no discount'
	);

      -- Test 1: Valid discount array (complete coverage, no overlaps)
      v_valid_discounts := ARRAY[
          ROW('[0,10)', NULL, 0.00)::dirac.discount_range,     -- $0 absolute discount
          ROW('[10,50)', 0.10, NULL)::dirac.discount_range,    -- 10% fraction discount
          ROW('[50,100)', NULL, 5.00)::dirac.discount_range,   -- $5 absolute discount
          ROW('[100,)', 0.20, NULL)::dirac.discount_range      -- 20% fraction discount
      ];
      RETURN NEXT ok(dirac.validate_discounts(v_valid_discounts), 'Valid discount array should pass validation');

      -- Test 2: Invalid - has gaps
      v_invalid_discounts := ARRAY[
          ROW('[0,10)', NULL, 0.00)::dirac.discount_range,
          ROW('[20,)', 0.10, NULL)::dirac.discount_range  -- Gap from 10-20
      ];
      RETURN NEXT ok(NOT dirac.validate_discounts(v_invalid_discounts), 'Discount array with gaps should fail');

      -- Test 3: Invalid - overlapping ranges
      v_invalid_discounts := ARRAY[
          ROW('[0,15)', NULL, 0.00)::dirac.discount_range,
          ROW('[10,50)', 0.10, NULL)::dirac.discount_range,  -- Overlaps 10-15
          ROW('[50,)', 0.20, NULL)::dirac.discount_range
      ];
      RETURN NEXT ok(NOT dirac.validate_discounts(v_invalid_discounts), 'Overlapping ranges should fail');

      -- Test 4: Invalid - both discount types
      v_invalid_discounts := ARRAY[
          ROW('[0,10)', 0.10, 5.00)::dirac.discount_range,  -- Has both absolute and fraction
          ROW('[10,)', 0.20, NULL)::dirac.discount_range
      ];
      RETURN NEXT ok(NOT dirac.validate_discounts(v_invalid_discounts), 'Having both discount types should fail');

      -- Test 5: Invalid - doesn't start at 0
      v_invalid_discounts := ARRAY[
          ROW('[5,)', 0.10, NULL)::dirac.discount_range
      ];
      RETURN NEXT ok(NOT dirac.validate_discounts(v_invalid_discounts), 'Not starting at 0 should fail');

END;
$_$;


ALTER FUNCTION dirac.test_discount_function_validation() OWNER TO postgres;

--
-- Name: test_generate_email_verification_token_after_wait(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_email_verification_token_after_wait() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'waittest@test.com';
    v_user_id BIGINT;
    v_token1 UUID;
    v_token2 UUID;
    v_expires1 TIMESTAMPTZ;
    v_expires2 TIMESTAMPTZ;
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash, email_verified)
    VALUES (v_email, 'hash', FALSE)
    RETURNING id INTO v_user_id;

    -- Generate first token
    SELECT * INTO v_token1, v_expires1
    FROM api.generate_email_verification_token(v_email);

    -- Manually set updated_at to 11 minutes ago to bypass rate limit
    UPDATE auth.user
    SET updated_at = NOW() - INTERVAL '11 minutes'
    WHERE id = v_user_id;

    -- Generate second token (should succeed now)
    SELECT * INTO v_token2, v_expires2
    FROM api.generate_email_verification_token(v_email);

    RETURN NEXT ok(
        v_token2 IS NOT NULL,
        'Second token generation should succeed after wait period'
    );

    RETURN NEXT ok(
        v_token2 != v_token1,
        'Second token should be different from first token'
    );

    -- Both tokens have 24-hour expiry from their generation time
    -- Since we can't reliably compare expiry times across the rate limit manipulation,
    -- just verify the second token has a valid future expiry
    RETURN NEXT ok(
        v_expires2 > NOW() + INTERVAL '23 hours',
        'Second token should have valid 24-hour expiry'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_generate_email_verification_token_after_wait() OWNER TO postgres;

--
-- Name: test_generate_email_verification_token_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_email_verification_token_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'api',
        'generate_email_verification_token',
        ARRAY['text'],
        'api.generate_email_verification_token function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_generate_email_verification_token_exists() OWNER TO postgres;

--
-- Name: test_generate_email_verification_token_expiry(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_email_verification_token_expiry() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'expirytest@test.com';
    v_user_id BIGINT;
    v_token UUID;
    v_expires_at TIMESTAMPTZ;
    v_now TIMESTAMPTZ;
    v_expected_expiry TIMESTAMPTZ;
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash, email_verified)
    VALUES (v_email, 'hash', FALSE)
    RETURNING id INTO v_user_id;

    -- Capture current time
    v_now := NOW();

    -- Generate token
    SELECT * INTO v_token, v_expires_at
    FROM api.generate_email_verification_token(v_email);

    -- Calculate expected expiry (24 hours from now)
    v_expected_expiry := v_now + INTERVAL '24 hours';

    -- Verify expiry is in the future
    RETURN NEXT ok(
        v_expires_at > v_now,
        'Expiry should be in the future'
    );

    -- Verify expiry is within reasonable range of 24 hours
    -- Allow 1 minute tolerance for test execution time
    RETURN NEXT ok(
        v_expires_at >= v_expected_expiry - INTERVAL '1 minute'
        AND v_expires_at <= v_expected_expiry + INTERVAL '1 minute',
        'Expiry should be approximately 24 hours from generation time'
    );

    -- Verify not expired yet
    RETURN NEXT ok(
        v_expires_at > NOW(),
        'Token should not be expired immediately after generation'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_generate_email_verification_token_expiry() OWNER TO postgres;

--
-- Name: test_generate_email_verification_token_rate_limit(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_email_verification_token_rate_limit() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'ratelimit@test.com';
    v_user_id BIGINT;
    v_token1 UUID;
    v_expires1 TIMESTAMPTZ;
    v_error_message TEXT;
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash, email_verified)
    VALUES (v_email, 'hash', FALSE)
    RETURNING id INTO v_user_id;

    -- Generate first token
    SELECT * INTO v_token1, v_expires1
    FROM api.generate_email_verification_token(v_email);

    RETURN NEXT ok(
        v_token1 IS NOT NULL,
        'First token generation should succeed'
    );

    -- Try to generate second token immediately (should fail)
    BEGIN
        PERFORM api.generate_email_verification_token(v_email);
        RETURN NEXT fail('Should raise exception for rate limiting');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN  -- RaiseError
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT ok(
                v_error_message LIKE 'Please wait % seconds before requesting a new verification email',
                'Should raise rate limit error with wait time'
            );
    END;

    -- Verify the original token is still stored
    RETURN NEXT is(
        (SELECT email_verification_token FROM auth.user WHERE id = v_user_id),
        v_token1,
        'Original token should remain unchanged after rate limit'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_generate_email_verification_token_rate_limit() OWNER TO postgres;

--
-- Name: test_generate_email_verification_token_replaces(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_email_verification_token_replaces() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'replacetest@test.com';
    v_user_id BIGINT;
    v_old_token UUID := gen_random_uuid();
    v_old_expires TIMESTAMPTZ := NOW() + INTERVAL '12 hours';
    v_new_token UUID;
    v_new_expires TIMESTAMPTZ;
    v_stored_token UUID;
BEGIN
    -- Create test user with existing token
    INSERT INTO auth.user (
        email,
        password_hash,
        email_verified,
        email_verification_token,
        email_verification_expires_at,
        updated_at
    )
    VALUES (
        v_email,
        'hash',
        FALSE,
        v_old_token,
        v_old_expires,
        NOW() - INTERVAL '11 minutes'  -- Old enough to bypass rate limit
    )
    RETURNING id INTO v_user_id;

    -- Generate new token
    SELECT * INTO v_new_token, v_new_expires
    FROM api.generate_email_verification_token(v_email);

    -- Verify new token is different
    RETURN NEXT ok(
        v_new_token != v_old_token,
        'New token should be different from old token'
    );

    -- Verify new token replaced old one in database
    SELECT email_verification_token INTO v_stored_token
    FROM auth.user WHERE id = v_user_id;

    RETURN NEXT is(
        v_stored_token,
        v_new_token,
        'Database should store new token, not old token'
    );

    RETURN NEXT ok(
        v_stored_token != v_old_token,
        'Old token should be overwritten'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_generate_email_verification_token_replaces() OWNER TO postgres;

--
-- Name: test_generate_email_verification_token_success(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_email_verification_token_success() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'tokentest1@test.com';
    v_user_id BIGINT;
    v_token UUID;
    v_expires_at TIMESTAMPTZ;
    v_stored_token UUID;
    v_stored_expires TIMESTAMPTZ;
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash, email_verified)
    VALUES (v_email, 'hash', FALSE)
    RETURNING id INTO v_user_id;

    -- Generate token
    SELECT * INTO v_token, v_expires_at
    FROM api.generate_email_verification_token(v_email);

    RETURN NEXT ok(
        v_token IS NOT NULL,
        'Should return a valid UUID token'
    );

    RETURN NEXT ok(
        v_expires_at IS NOT NULL,
        'Should return an expiry timestamp'
    );

    -- Verify token was stored in database
    SELECT email_verification_token, email_verification_expires_at
    INTO v_stored_token, v_stored_expires
    FROM auth.user WHERE id = v_user_id;

    RETURN NEXT is(
        v_stored_token,
        v_token,
        'Token should be stored in user record'
    );

    RETURN NEXT is(
        v_stored_expires,
        v_expires_at,
        'Expiry should be stored in user record'
    );

    -- Verify expiry is approximately 24 hours from now
    RETURN NEXT ok(
        v_expires_at > NOW() + INTERVAL '23 hours 59 minutes'
        AND v_expires_at <= NOW() + INTERVAL '24 hours 1 minute',
        'Token should expire in approximately 24 hours'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_generate_email_verification_token_success() OWNER TO postgres;

--
-- Name: test_generate_email_verification_token_user_not_found(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_email_verification_token_user_not_found() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'nonexistent@test.com';
    v_error_message TEXT;
BEGIN
    -- Ensure user doesn't exist
    DELETE FROM auth.user WHERE email = v_email;

    -- Try to generate token for non-existent user
    BEGIN
        PERFORM api.generate_email_verification_token(v_email);
        RETURN NEXT fail('Should raise exception for non-existent user');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN  -- RaiseError
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'User not found',
                'Should raise "User not found" error'
            );
    END;
END;
$$;


ALTER FUNCTION dirac.test_generate_email_verification_token_user_not_found() OWNER TO postgres;

--
-- Name: test_generate_slug_trigger(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_generate_slug_trigger() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_product_id BIGINT;
    v_slug TEXT;
BEGIN
    -- Test function exists
    RETURN NEXT has_function('dirac', 'generate_slug', 'generate_slug trigger function should exist');

    -- Create temporary test table
    CREATE TEMP TABLE test_products (
        id BIGSERIAL PRIMARY KEY,
        name TEXT NOT NULL,
        slug TEXT
    );

    -- Create trigger on test table
    CREATE TRIGGER generate_slug_trigger
        BEFORE INSERT OR UPDATE ON test_products
        FOR EACH ROW EXECUTE FUNCTION dirac.generate_slug();

    -- Test 1: Generate slug from name when NULL
    INSERT INTO test_products (name) VALUES ('Product Name') RETURNING id, slug INTO v_product_id, v_slug;
    RETURN NEXT is(
        v_slug,
        'product-name',
        'Should generate slug from name when NULL'
    );

    -- Test 2: Generate slug with spaces converted to hyphens
    INSERT INTO test_products (name) VALUES ('My Awesome Product 123') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'my-awesome-product-123',
        'Should convert spaces to hyphens'
    );

    -- Test 3: Preserve existing slug when provided
    INSERT INTO test_products (name, slug) VALUES ('Another Product', 'custom-slug') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'custom-slug',
        'Should preserve existing slug when provided'
    );

    -- Test 4: Handle special characters
    INSERT INTO test_products (name) VALUES ('Product!@#$%^&*()_+') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'product',
        'Should remove special characters'
    );

    -- Test 5: Handle leading/trailing spaces and special chars
    INSERT INTO test_products (name) VALUES ('  ---Product Name---  ') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'product-name',
        'Should trim leading/trailing hyphens'
    );

    -- Test 6: Handle uppercase conversion
    INSERT INTO test_products (name) VALUES ('UPPERCASE PRODUCT') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'uppercase-product',
        'Should convert to lowercase'
    );

    -- Test 7: Handle consecutive spaces/special chars
    INSERT INTO test_products (name) VALUES ('Product   ///   Name') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'product-name',
        'Should not create consecutive hyphens'
    );

    -- Test 8: Handle numeric values
    INSERT INTO test_products (name) VALUES ('123 456 789') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        '123-456-789',
        'Should handle numeric values'
    );

    -- Test 9: Update with NULL slug should regenerate
    UPDATE test_products SET name = 'Updated Product', slug = NULL WHERE id = v_product_id RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'updated-product',
        'Should regenerate slug when set to NULL on update'
    );

    -- Test 10: Update with empty string slug should regenerate
    UPDATE test_products SET name = 'New Updated Product', slug = '' WHERE id = v_product_id RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'new-updated-product',
        'Should regenerate slug when set to empty string on update'
    );

    -- Test 11: Update name without touching slug should preserve slug
    INSERT INTO test_products (name, slug) VALUES ('Test Product', 'existing-slug') RETURNING id INTO v_product_id;
    UPDATE test_products SET name = 'Changed Name' WHERE id = v_product_id RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'existing-slug',
        'Should preserve slug when updating name if slug already exists'
    );

    -- Test 12: Handle only special characters (edge case)
    INSERT INTO test_products (name) VALUES ('!!!@@@###') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        '',
        'Should return empty string for only special characters'
    );

    -- Test 13: Handle unicode/international characters
    INSERT INTO test_products (name) VALUES ('CafÃ© RÃ©sumÃ© naÃ¯ve') RETURNING slug INTO v_slug;
    RETURN NEXT is(
        v_slug,
        'caf-r-sum-na-ve',
        'Should handle unicode characters'
    );

    -- Clean up
    DROP TABLE test_products;
END;
$_$;


ALTER FUNCTION dirac.test_generate_slug_trigger() OWNER TO postgres;

--
-- Name: test_get_discount(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_get_discount() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_discount_id BIGINT;
BEGIN
	-- Setup: Insert test discount function
	INSERT INTO dirac.discount_function (name, discounts)
	VALUES ('Test Pricing Function', ARRAY[
	  ROW('[0,10)', NULL, 0.00)::dirac.discount_range,     -- $0 off for 0-9 (using absolute)
	  ROW('[10,50)', 0.10, NULL)::dirac.discount_range,    -- 10% off for 10-49
	  ROW('[50,100)', NULL, 5.00)::dirac.discount_range,   -- $5 off per unit for 50-99
	  ROW('[100,)', 0.20, NULL)::dirac.discount_range      -- 20% off for 100+
	])
	RETURNING id INTO v_discount_id;

	-- Test get_price with different quantities
	RETURN NEXT results_eq(
	  format('SELECT dirac.get_price(%s, 100.00, 5)', v_discount_id),
	  'SELECT 500.00::numeric(19,4)',
	  'Qty 5 should get no discount (0-9 range)'
	);

	RETURN NEXT results_eq(
	  format('SELECT dirac.get_price(%s, 100.00, 25)', v_discount_id),
	  'SELECT 2250.00::numeric(19,4)',
	  'Qty 25 should get 10% discount (10-49 range)'
	);

	RETURN NEXT results_eq(
	  format('SELECT dirac.get_price(%s, 100.00, 75)', v_discount_id),
	  'SELECT 7125.00::numeric(19,4)',
	  'Qty 75 should get $5 off per unit (50-99 range)'
	);

	RETURN NEXT results_eq(
	  format('SELECT dirac.get_price(%s, 100.00, 150)', v_discount_id),
	  'SELECT 12000.00::numeric(19,4)',
	  'Qty 150 should get 20% discount (100+ range)'
	);

	-- Test NULL discount function
	RETURN NEXT results_eq(
	  'SELECT dirac.get_price(NULL, 100.00, 10)',
	  'SELECT 1000.00::numeric(19,4)',
	  'NULL discount should return base price * qty'
	);

	-- Test edge cases
	RETURN NEXT results_eq(
	  format('SELECT dirac.get_price(%s, 100.00, 0)', v_discount_id),
	  'SELECT 0.00::numeric(19,4)',
	  'Qty 0 should return 0'
	);

	RETURN NEXT results_eq(
	  format('SELECT dirac.get_price(%s, 100.00, 10)', v_discount_id),
	  'SELECT 900.00::numeric(19,4)',
	  'Qty 10 should be in [10,50) range (boundary test)'
	);

	RETURN NEXT results_eq(
	  format('SELECT dirac.get_price(%s, 100.00, 50)', v_discount_id),
	  'SELECT 4750.00::numeric(19,4)',
	  'Qty 50 should be in [50,100) range (boundary test)'
	);

	-- Clean up
	DELETE FROM dirac.discount_function WHERE id = v_discount_id;

  END;
  $_$;


ALTER FUNCTION dirac.test_get_discount() OWNER TO postgres;

--
-- Name: test_get_product_detail(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_get_product_detail() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    _manufacturer_id BIGINT;
    _brand_id BIGINT;
    _product_id BIGINT;
    _product_case_id BIGINT;
    _result api.product_detail_display;
BEGIN
    -- Test function exists with correct signature
    RETURN NEXT has_function(
        'api',
        'get_product_detail',
        ARRAY['character varying'],
        'get_product_detail function should exist'
    );

    -- Setup test data
    INSERT INTO dirac.supplier(name, embedding) VALUES ('Test Manufacturer GPD', array_fill(0.1::float4, ARRAY[768])::vector(768))
    RETURNING id INTO _manufacturer_id;

    -- Insert brand with a dummy embedding (768 dimensions of zeros)
    INSERT INTO dirac.brand(name, slug, embedding)
    VALUES ('Test Brand', 'test-brand', array_fill(0, ARRAY[768])::vector)
    RETURNING id INTO _brand_id;

    -- Insert barcode first (required by foreign key constraint)
    INSERT INTO dirac.barcode(gtin_14) VALUES ('12345678901231');

    -- Create test product with full details and dummy embedding
    -- Start with show_on_web = FALSE to satisfy check_has_price_if_web constraint
    INSERT INTO dirac.product(slug, name, brand_id, show_on_web, barcode, embedding)
    VALUES ('test-product-slug', 'Test Product Name', _brand_id, FALSE, '12345678901231', array_fill(0, ARRAY[768])::vector)
    RETURNING id INTO _product_id;

    -- Add product details (includes size information now)
    INSERT INTO dirac.product_detail(product_id, shelf_life_days, is_gluten_free, volume_ml, weight_g, pack_size)
    VALUES (_product_id, 365, TRUE, 500.0, 1500.0, 6);

    -- Insert case barcode (required by foreign key constraint)
    INSERT INTO dirac.barcode(gtin_14) VALUES ('98765432109876');

    -- Insert currency and country (required by foreign key constraints)
    INSERT INTO dirac.currency(iso_4217, name) VALUES ('GBP', 'British Pound')
    ON CONFLICT (iso_4217) DO NOTHING;

    INSERT INTO dirac.country(iso_3166_2, iso_3166_3, name, official_name, currency)
    VALUES ('GB', 'GBR', 'United Kingdom', 'United Kingdom of Great Britain and Northern Ireland', 'GBP')
    ON CONFLICT (iso_3166_2) DO NOTHING;

    -- Add product case first (replaces the old case info in product_offer)
    INSERT INTO dirac.product_case(
        product_id, case_barcode, units_per_case, layers_per_pallet
    )
    VALUES (_product_id, '98765432109876', 12, 4)
    RETURNING id INTO _product_case_id;

    -- Add product offer
    INSERT INTO dirac.product_offer(
        sku, supplier_id, product_id, product_case_id,
        case_price_base, case_price_currency,
        moq_cases, country_of_origin, is_active
    )
    VALUES (
        'SKU123', _manufacturer_id, _product_id, _product_case_id,
        120.00, 'GBP',
        10, 'GB', TRUE
    );

    -- Now update product to show_on_web = TRUE since it has an offer
    UPDATE dirac.product
    SET show_on_web = TRUE,
        web_unit_price = 10.00,  -- 120/12
        web_unit_price_currency = 'GBP',
        web_product_case_id = _product_case_id
    WHERE id = _product_id;

    -- Test 1: Function returns data for valid slug
    SELECT * INTO _result
    FROM api.get_product_detail('test-product-slug');

    RETURN NEXT is(
        _result.slug,
        'test-product-slug',
        'Should return correct slug'
    );

    RETURN NEXT is(
        _result.name,
        'Test Product Name',
        'Should return correct product name'
    );

    RETURN NEXT is(
        _result.brand_name,
        'Test Brand',
        'Should return correct brand name'
    );

    RETURN NEXT is(
        _result.barcode,
        '12345678901231',
        'Should return correct barcode'
    );

    RETURN NEXT is(
        _result.show_on_web,
        TRUE,
        'Should return correct show_on_web status'
    );

    -- Test product details
    RETURN NEXT is(
        _result.shelf_life_days,
        365,
        'Should return correct shelf life'
    );

    RETURN NEXT is(
        _result.is_gluten_free,
        TRUE,
        'Should return correct gluten free status'
    );

    -- Test offer information
    RETURN NEXT is(
        _result.units_per_case,
        12,
        'Should return correct units per case'
    );

    RETURN NEXT is(
        _result.case_price,
        120.00,
        'Should return correct case price'
    );

    RETURN NEXT is(
        _result.currency,
        'GBP',
        'Should return correct currency'
    );

    RETURN NEXT is(
        _result.unit_price,
        10.00,
        'Should calculate correct unit price (120/12)'
    );

    RETURN NEXT is(
        _result.case_barcode,
        '98765432109876',
        'Should return correct case barcode'
    );

    RETURN NEXT is(
        _result.layers_per_pallet,
        4,
        'Should return correct layers per pallet'
    );

    RETURN NEXT is(
        _result.moq_cases,
        10,
        'Should return correct MOQ'
    );

    RETURN NEXT is(
        _result.country_of_origin,
        'GB',
        'Should return correct country of origin'
    );

    -- Test 2: Returns NULL for non-existent slug
    SELECT * INTO _result
    FROM api.get_product_detail('non-existent-slug');

    RETURN NEXT is(
        _result.slug,
        NULL,
        'Should return NULL for non-existent product'
    );

    -- Test 3: Hidden products (show_on_web = FALSE) should not be returned
    UPDATE dirac.product SET show_on_web = FALSE WHERE id = _product_id;

    SELECT * INTO _result
    FROM api.get_product_detail('test-product-slug');

    RETURN NEXT is(
        _result.slug,
        NULL,
        'Should return NULL for hidden products'
    );

    -- Test 4: Product with no offers still returns basic info
    -- Note: Can't set show_on_web = TRUE without offers due to check_has_price_if_web constraint
    -- So we delete offers and keep show_on_web = FALSE
    DELETE FROM dirac.product_offer WHERE product_id = _product_id;
    UPDATE dirac.product SET show_on_web = FALSE WHERE id = _product_id;

    SELECT * INTO _result
    FROM api.get_product_detail('test-product-slug');

    -- Since show_on_web = FALSE, the product should return NULL (hidden)
    RETURN NEXT is(
        _result.slug,
        NULL,
        'Should return NULL for products without offers (show_on_web must be FALSE)'
    );

    -- Test 5: Inactive offers should be ignored
    -- Re-add the offer but set it as inactive
    INSERT INTO dirac.product_offer(
        sku, supplier_id, product_id, product_case_id,
        case_price_base, case_price_currency,
        moq_cases, country_of_origin, is_active
    )
    VALUES (
        'SKU123', _manufacturer_id, _product_id, _product_case_id,
        120.00, 'GBP',
        10, 'GB', FALSE  -- Inactive offer
    );

    SELECT * INTO _result
    FROM api.get_product_detail('test-product-slug');

    RETURN NEXT is(
        _result.case_price,
        NULL,
        'Should return NULL case price when only inactive offers exist'
    );

    -- Cleanup (delete in correct order to respect foreign key constraints)
    DELETE FROM dirac.product_offer WHERE product_id = _product_id;
    DELETE FROM dirac.product_detail WHERE product_id = _product_id;
    -- Must set web_product_case_id to NULL before deleting product_case
    UPDATE dirac.product SET web_product_case_id = NULL WHERE id = _product_id;
    DELETE FROM dirac.product_case WHERE product_id = _product_id;
    DELETE FROM dirac.product WHERE id = _product_id;
    DELETE FROM dirac.barcode WHERE gtin_14 IN ('12345678901231', '98765432109876');
    DELETE FROM dirac.brand WHERE id = _brand_id;
    DELETE FROM dirac.supplier WHERE id = _manufacturer_id;

END;
$$;


ALTER FUNCTION dirac.test_get_product_detail() OWNER TO postgres;

--
-- Name: test_get_product_listing(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_get_product_listing() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    _manufacturer_id BIGINT;
    _brand_id BIGINT;
    _product_id1 BIGINT;
    _product_id2 BIGINT;
    _product_id3 BIGINT;
    _product_case_id1 BIGINT;
    _product_case_id2 BIGINT;
    _result_count INT;
    _result api.product_listing;
BEGIN
    -- Test function exists with correct signature
    RETURN NEXT has_function(
        'api',
        'get_product_listing',
        ARRAY['integer', 'integer', 'character varying', 'character varying', 'character varying', 'vector'],
        'get_product_listing function should exist'
    );

    -- Clean up any existing test data first
    DELETE FROM dirac.product WHERE slug IN ('test-listing-product-alpha', 'test-listing-product-beta', 'test-listing-hidden-product');
    DELETE FROM dirac.brand WHERE slug = 'test-listing-brand-a';
    DELETE FROM dirac.supplier WHERE name = 'Test Listing Manufacturer';

    -- Setup test data with unique names
    INSERT INTO dirac.supplier(name, embedding) VALUES ('Test Listing Manufacturer GPL', array_fill(0.1::float4, ARRAY[768])::vector(768))
    RETURNING id INTO _manufacturer_id;

    -- Insert brand with a dummy embedding (768 dimensions of zeros)
    INSERT INTO dirac.brand(name, slug, embedding)
    VALUES ('Test Listing Brand A', 'test-listing-brand-a', array_fill(0, ARRAY[768])::vector)
    RETURNING id INTO _brand_id;

    -- Create test products with dummy embeddings - let trigger generate slugs
    -- Start with show_on_web = FALSE to satisfy check_has_price_if_web constraint
    INSERT INTO dirac.product(name, brand_id, show_on_web, embedding)
    VALUES ('Test Listing Product Alpha', _brand_id, FALSE, array_fill(0, ARRAY[768])::vector)
    RETURNING id INTO _product_id1;

    INSERT INTO dirac.product(name, brand_id, show_on_web, embedding)
    VALUES ('Test Listing Product Beta', _brand_id, FALSE, array_fill(0, ARRAY[768])::vector)
    RETURNING id INTO _product_id2;

    -- Create a product that should NOT show (show_on_web = FALSE)
    INSERT INTO dirac.product(name, brand_id, show_on_web, embedding)
    VALUES ('Test Listing Hidden Product', _brand_id, FALSE, array_fill(0, ARRAY[768])::vector)
    RETURNING id INTO _product_id3;

    -- Add product offers to satisfy check_has_price_if_web constraint
    -- Insert currency and country (required by foreign key constraints)
    INSERT INTO dirac.currency(iso_4217, name) VALUES ('USD', 'US Dollar')
    ON CONFLICT (iso_4217) DO NOTHING;

    INSERT INTO dirac.country(iso_3166_2, iso_3166_3, name, official_name, currency)
    VALUES ('US', 'USA', 'United States', 'United States of America', 'USD')
    ON CONFLICT (iso_3166_2) DO NOTHING;

    -- Add product cases
    INSERT INTO dirac.product_case(product_id, units_per_case)
    VALUES (_product_id1, 12)
    RETURNING id INTO _product_case_id1;

    INSERT INTO dirac.product_case(product_id, units_per_case)
    VALUES (_product_id2, 12)
    RETURNING id INTO _product_case_id2;

    -- Add product offers for the visible products
    INSERT INTO dirac.product_offer(
        sku, supplier_id, product_id, product_case_id,
        case_price_base, case_price_currency,
        country_of_origin, is_active
    )
    VALUES
        ('SKU-ALPHA', _manufacturer_id, _product_id1, _product_case_id1, 100.00, 'USD', 'US', TRUE),
        ('SKU-BETA', _manufacturer_id, _product_id2, _product_case_id2, 100.00, 'USD', 'US', TRUE);

    -- Now update the first two products to show_on_web = TRUE with web pricing
    UPDATE dirac.product
    SET show_on_web = TRUE,
        web_unit_price = 8.33,  -- 100/12
        web_unit_price_currency = 'GBP',
        web_product_case_id = _product_case_id1
    WHERE id = _product_id1;

    UPDATE dirac.product
    SET show_on_web = TRUE,
        web_unit_price = 8.33,
        web_unit_price_currency = 'GBP',
        web_product_case_id = _product_case_id2
    WHERE id = _product_id2;

    -- Test 1: Basic listing returns visible products
    SELECT COUNT(*) INTO _result_count
    FROM api.get_product_listing();

    RETURN NEXT ok(
        _result_count >= 2,
        'Should return at least the 2 visible products'
    );

    -- Test 2: Hidden products are not returned
    PERFORM 1 FROM api.get_product_listing()
    WHERE name = 'Hidden Product';

    RETURN NEXT is(
        NOT FOUND,
        TRUE,
        'Hidden products (show_on_web=FALSE) should not be returned'
    );

    -- Test 3: Limit parameter works
    SELECT COUNT(*) INTO _result_count
    FROM api.get_product_listing(limit_val := 1);

    RETURN NEXT is(
        _result_count,
        1,
        'Limit parameter should restrict results'
    );

    -- Test 4: Offset parameter works
    SELECT COUNT(*) INTO _result_count
    FROM api.get_product_listing(limit_val := 1, offset_val := 1);

    RETURN NEXT ok(
        _result_count <= 1,
        'Offset should skip results'
    );

    -- Test 5: Brand filter works
    SELECT COUNT(*) INTO _result_count
    FROM api.get_product_listing(brand_name_filter := 'Test Listing Brand A');

    RETURN NEXT ok(
        _result_count >= 2,
        'Brand filter should return products from specified brand'
    );

    SELECT COUNT(*) INTO _result_count
    FROM api.get_product_listing(brand_name_filter := 'Nonexistent Brand');

    RETURN NEXT is(
        _result_count,
        0,
        'Brand filter with nonexistent brand should return no results'
    );

    -- Test 6: Search term works
    SELECT COUNT(*) INTO _result_count
    FROM api.get_product_listing(search_term := 'Listing Product Alpha');

    RETURN NEXT ok(
        _result_count >= 1,
        'Search should find products with matching name'
    );

    -- Test 7: Search term works with brand names
    SELECT COUNT(*) INTO _result_count
    FROM api.get_product_listing(search_term := 'Test Listing Brand');

    RETURN NEXT ok(
        _result_count >= 2,
        'Search should find products when brand name matches'
    );

    -- Test 8: Verify returned fields structure
    SELECT * INTO _result
    FROM api.get_product_listing(search_term:='Test Listing Product Alpha')
    WHERE slug = 'test-listing-product-alpha';

    RETURN NEXT is(
        _result.slug,
        'test-listing-product-alpha',
        'Should return correct slug'
    );

    RETURN NEXT is(
        _result.name,
        'Test Listing Product Alpha',
        'Should return correct name'
    );

    RETURN NEXT is(
        _result.brand_name,
        'Test Listing Brand A',
        'Should return correct brand name'
    );

    -- Cleanup (delete in correct order to respect foreign key constraints)
    DELETE FROM dirac.product_offer WHERE product_id IN (_product_id1, _product_id2, _product_id3);
    -- Must set web_product_case_id to NULL before deleting product_case
    UPDATE dirac.product SET web_product_case_id = NULL WHERE id IN (_product_id1, _product_id2, _product_id3);
    DELETE FROM dirac.product_case WHERE product_id IN (_product_id1, _product_id2, _product_id3);
    DELETE FROM dirac.product WHERE id IN (_product_id1, _product_id2, _product_id3);
    DELETE FROM dirac.brand WHERE id = _brand_id;
    DELETE FROM dirac.supplier WHERE id = _manufacturer_id;

END;
$$;


ALTER FUNCTION dirac.test_get_product_listing() OWNER TO postgres;

--
-- Name: test_hash_password_basic(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_hash_password_basic() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_hash TEXT;
BEGIN
    -- Test that function runs without error
    BEGIN
        v_hash := auth.hash_password('testpassword123');
        RETURN NEXT ok(
            v_hash IS NOT NULL,
            'hash_password should return a non-null hash'
        );
    EXCEPTION WHEN OTHERS THEN
        RETURN NEXT fail('hash_password threw an error: ' || SQLERRM);
    END;

    -- Test that hash is not empty
    RETURN NEXT ok(
        LENGTH(v_hash) > 0,
        'Hash should not be empty'
    );

    -- Test that hash starts with Argon2 identifier
    RETURN NEXT ok(
        v_hash LIKE '$argon2%',
        'Hash should start with Argon2 identifier'
    );
END;
$_$;


ALTER FUNCTION dirac.test_hash_password_basic() OWNER TO postgres;

--
-- Name: test_hash_password_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_hash_password_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'auth',
        'hash_password',
        ARRAY['text'],
        'auth.hash_password function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_hash_password_exists() OWNER TO postgres;

--
-- Name: test_hash_password_lengths(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_hash_password_lengths() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hash TEXT;
BEGIN
    -- Empty password (edge case, but should work)
    BEGIN
        v_hash := auth.hash_password('');
        RETURN NEXT ok(
            v_hash IS NOT NULL AND LENGTH(v_hash) > 0,
            'Empty password should still produce a hash'
        );
    EXCEPTION WHEN OTHERS THEN
        RETURN NEXT fail('Empty password threw an error: ' || SQLERRM);
    END;

    -- Very short password
    BEGIN
        v_hash := auth.hash_password('a');
        RETURN NEXT ok(
            v_hash IS NOT NULL AND LENGTH(v_hash) > 0,
            'Single character password should produce a hash'
        );
    EXCEPTION WHEN OTHERS THEN
        RETURN NEXT fail('Single char password threw an error: ' || SQLERRM);
    END;

    -- Long password
    BEGIN
        v_hash := auth.hash_password(repeat('a', 100));
        RETURN NEXT ok(
            v_hash IS NOT NULL AND LENGTH(v_hash) > 0,
            'Long password (100 chars) should produce a hash'
        );
    EXCEPTION WHEN OTHERS THEN
        RETURN NEXT fail('Long password threw an error: ' || SQLERRM);
    END;

    -- Very long password
    BEGIN
        v_hash := auth.hash_password(repeat('a', 1000));
        RETURN NEXT ok(
            v_hash IS NOT NULL AND LENGTH(v_hash) > 0,
            'Very long password (1000 chars) should produce a hash'
        );
    EXCEPTION WHEN OTHERS THEN
        RETURN NEXT fail('Very long password threw an error: ' || SQLERRM);
    END;
END;
$$;


ALTER FUNCTION dirac.test_hash_password_lengths() OWNER TO postgres;

--
-- Name: test_hash_password_null(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_hash_password_null() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Function is STRICT, so NULL input should return NULL
    RETURN NEXT is(
        auth.hash_password(NULL),
        NULL,
        'NULL password should return NULL (STRICT function)'
    );
END;
$$;


ALTER FUNCTION dirac.test_hash_password_null() OWNER TO postgres;

--
-- Name: test_hash_password_uniqueness(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_hash_password_uniqueness() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hash1 TEXT;
    v_hash2 TEXT;
    v_hash3 TEXT;
BEGIN
    -- Hash different passwords
    v_hash1 := auth.hash_password('password1');
    v_hash2 := auth.hash_password('password2');
    v_hash3 := auth.hash_password('password1'); -- Same as first

    -- Different passwords should produce different hashes
    RETURN NEXT ok(
        v_hash1 != v_hash2,
        'Different passwords should produce different hashes'
    );

    -- Same password should produce different hashes (due to salt)
    RETURN NEXT ok(
        v_hash1 != v_hash3,
        'Same password should produce different hashes due to salt'
    );
END;
$$;


ALTER FUNCTION dirac.test_hash_password_uniqueness() OWNER TO postgres;

--
-- Name: test_is_session_valid_deleted_user(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_deleted_user() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'deleted@gmail.com';
    v_password TEXT := 'DeletedPass123';
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Test/1.0';
    v_user_id BIGINT;
    v_session_uuid UUID;
    v_is_valid BOOLEAN;
BEGIN
    -- Create account
    v_session_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Verify session is valid
    RETURN NEXT is(
        api.is_session_valid(v_session_uuid, v_ip, v_user_agent),
        TRUE,
        'Session should be valid before user deletion'
    );

    -- Delete user (CASCADE should delete sessions)
    DELETE FROM auth.user WHERE id = v_user_id;

    -- Test session after user deletion
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session should be invalid after user deletion (CASCADE)'
    );
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_deleted_user() OWNER TO postgres;

--
-- Name: test_is_session_valid_edge_cases(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_edge_cases() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'edge@gmail.com';
    v_password TEXT := 'EdgePass123';
    v_ip_v4 INET := '192.168.1.1'::inet;
    v_ip_v6 INET := '2001:db8::1'::inet;
    v_ua_long TEXT := repeat('Mozilla/5.0 ', 100);
    v_user_id BIGINT;
    v_session_uuid UUID;
    v_session_uuid_v6 UUID;
BEGIN
    -- Test with very long user agent
    v_session_uuid := api.create_account(v_email, v_password, v_ip_v4, v_ua_long);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    RETURN NEXT is(
        api.is_session_valid(v_session_uuid, v_ip_v4, v_ua_long),
        TRUE,
        'Session with very long user agent should validate correctly'
    );

    -- Test with IPv6
    v_session_uuid_v6 := api.login(v_email, v_password, v_ip_v6, 'IPv6 Browser');

    RETURN NEXT is(
        api.is_session_valid(v_session_uuid_v6, v_ip_v6, 'IPv6 Browser'),
        TRUE,
        'Session with IPv6 should validate correctly'
    );

    -- Test case sensitivity of UUID (PostgreSQL UUIDs are case-insensitive)
    RETURN NEXT is(
        api.is_session_valid(v_session_uuid, v_ip_v4, v_ua_long),
        api.is_session_valid(v_session_uuid, v_ip_v4, v_ua_long),
        'UUID validation should be consistent'
    );

    -- Test boundary condition: session about to expire
    UPDATE auth.web_session
    SET expires_at = NOW() + INTERVAL '1 second'
    WHERE uuid = v_session_uuid;

    RETURN NEXT is(
        api.is_session_valid(v_session_uuid, v_ip_v4, v_ua_long),
        TRUE,
        'Session about to expire (1 second) should still be valid'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_edge_cases() OWNER TO postgres;

--
-- Name: test_is_session_valid_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'api',
        'is_session_valid',
        ARRAY['uuid', 'inet', 'text'],
        'api.is_session_valid function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_exists() OWNER TO postgres;

--
-- Name: test_is_session_valid_expired(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_expired() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'expired@gmail.com';
    v_password TEXT := 'ExpiredPass123';
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Firefox/98.0';
    v_user_id BIGINT;
    v_session_uuid UUID;
    v_is_valid BOOLEAN;
BEGIN
    -- Create account
    v_session_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Manually expire the session
    UPDATE auth.web_session
    SET expires_at = NOW() - INTERVAL '1 hour'
    WHERE uuid = v_session_uuid;

    -- Test expired session
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Expired session should return FALSE'
    );

    -- Test session that expires right now
    UPDATE auth.web_session
    SET expires_at = NOW()
    WHERE uuid = v_session_uuid;

    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session expiring at NOW() should return FALSE'
    );

    -- Test session expiring in the future
    UPDATE auth.web_session
    SET expires_at = NOW() + INTERVAL '1 hour'
    WHERE uuid = v_session_uuid;

    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        TRUE,
        'Session expiring in the future should return TRUE'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_expired() OWNER TO postgres;

--
-- Name: test_is_session_valid_multiple_sessions(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_multiple_sessions() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'multisess@gmail.com';
    v_password TEXT := 'MultiPass123';
    v_ip1 INET := '192.168.1.100'::inet;
    v_ip2 INET := '192.168.1.101'::inet;
    v_ua1 TEXT := 'Chrome/100';
    v_ua2 TEXT := 'Firefox/98';
    v_user_id BIGINT;
    v_session1_uuid UUID;
    v_session2_uuid UUID;
BEGIN
    -- Create account (session 1)
    v_session1_uuid := api.create_account(v_email, v_password, v_ip1, v_ua1);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Create second session via login
    v_session2_uuid := api.login(v_email, v_password, v_ip2, v_ua2);

    -- Test both sessions are valid with their respective parameters
    RETURN NEXT is(
        api.is_session_valid(v_session1_uuid, v_ip1, v_ua1),
        TRUE,
        'First session should be valid with its IP and user agent'
    );

    RETURN NEXT is(
        api.is_session_valid(v_session2_uuid, v_ip2, v_ua2),
        TRUE,
        'Second session should be valid with its IP and user agent'
    );

    -- Cross-check: session 1 with session 2's params should fail
    RETURN NEXT is(
        api.is_session_valid(v_session1_uuid, v_ip2, v_ua2),
        FALSE,
        'First session with second session''s parameters should be invalid'
    );

    RETURN NEXT is(
        api.is_session_valid(v_session2_uuid, v_ip1, v_ua1),
        FALSE,
        'Second session with first session''s parameters should be invalid'
    );

    -- Expire one session and verify the other is still valid
    UPDATE auth.web_session
    SET expires_at = NOW() - INTERVAL '1 hour'
    WHERE uuid = v_session1_uuid;

    RETURN NEXT is(
        api.is_session_valid(v_session1_uuid, v_ip1, v_ua1),
        FALSE,
        'Expired first session should be invalid'
    );

    RETURN NEXT is(
        api.is_session_valid(v_session2_uuid, v_ip2, v_ua2),
        TRUE,
        'Second session should still be valid after first expires'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_multiple_sessions() OWNER TO postgres;

--
-- Name: test_is_session_valid_nonexistent(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_nonexistent() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_fake_uuid UUID := gen_random_uuid();
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Test/1.0';
    v_is_valid BOOLEAN;
BEGIN
    -- Test with non-existent UUID
    v_is_valid := api.is_session_valid(v_fake_uuid, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Non-existent session UUID should return FALSE'
    );

    -- Test with NULL UUID
    v_is_valid := api.is_session_valid(NULL, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'NULL UUID should return FALSE'
    );
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_nonexistent() OWNER TO postgres;

--
-- Name: test_is_session_valid_success(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_success() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'sessionvalid@gmail.com';
    v_password TEXT := 'ValidPass123';
    v_ip INET := '192.168.1.100'::inet;
    v_user_agent TEXT := 'Chrome/100.0';
    v_user_id BIGINT;
    v_session_uuid UUID;
    v_is_valid BOOLEAN;
BEGIN
    -- Create account and get session
    v_session_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Test with correct parameters
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        TRUE,
        'Valid session with matching IP and user agent should return TRUE'
    );

    -- Test again to ensure it's consistent
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        TRUE,
        'Valid session should consistently return TRUE'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_success() OWNER TO postgres;

--
-- Name: test_is_session_valid_wrong_ip(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_wrong_ip() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'wrongip@gmail.com';
    v_password TEXT := 'WrongIPPass123';
    v_correct_ip INET := '192.168.1.100'::inet;
    v_wrong_ip INET := '192.168.1.101'::inet;
    v_user_agent TEXT := 'Safari/15.0';
    v_user_id BIGINT;
    v_session_uuid UUID;
    v_is_valid BOOLEAN;
BEGIN
    -- Create account with correct IP
    v_session_uuid := api.create_account(v_email, v_password, v_correct_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Test with wrong IP
    v_is_valid := api.is_session_valid(v_session_uuid, v_wrong_ip, v_user_agent);

    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session with wrong IP should return FALSE'
    );

    -- Test with various wrong IPs
    v_is_valid := api.is_session_valid(v_session_uuid, '10.0.0.1'::inet, v_user_agent);
    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session with completely different IP should return FALSE'
    );

    -- Test with IPv6 when session has IPv4
    v_is_valid := api.is_session_valid(v_session_uuid, '::1'::inet, v_user_agent);
    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session with IPv6 when expecting IPv4 should return FALSE'
    );

    -- Test with correct IP should still work
    v_is_valid := api.is_session_valid(v_session_uuid, v_correct_ip, v_user_agent);
    RETURN NEXT is(
        v_is_valid,
        TRUE,
        'Session with correct IP should return TRUE'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_wrong_ip() OWNER TO postgres;

--
-- Name: test_is_session_valid_wrong_user_agent(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_session_valid_wrong_user_agent() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'wrongua@gmail.com';
    v_password TEXT := 'WrongUAPass123';
    v_ip INET := '192.168.1.100'::inet;
    v_correct_ua TEXT := 'Mozilla/5.0 Chrome/100.0';
    v_wrong_ua TEXT := 'Mozilla/5.0 Firefox/98.0';
    v_user_id BIGINT;
    v_session_uuid UUID;
    v_is_valid BOOLEAN;
BEGIN
    -- Create account with correct user agent
    v_session_uuid := api.create_account(v_email, v_password, v_ip, v_correct_ua);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Test with wrong user agent
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_wrong_ua);

    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session with wrong user agent should return FALSE'
    );

    -- Test with slightly different user agent
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_correct_ua || ' ');
    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session with slightly different user agent (extra space) should return FALSE'
    );

    -- Test with empty user agent
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, '');
    RETURN NEXT is(
        v_is_valid,
        FALSE,
        'Session with empty user agent should return FALSE'
    );

    -- Test with correct user agent should work
    v_is_valid := api.is_session_valid(v_session_uuid, v_ip, v_correct_ua);
    RETURN NEXT is(
        v_is_valid,
        TRUE,
        'Session with correct user agent should return TRUE'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_is_session_valid_wrong_user_agent() OWNER TO postgres;

--
-- Name: test_is_valid_slug(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_is_valid_slug() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Test function exists
    RETURN NEXT has_function('dirac', 'is_valid_slug', ARRAY['text'], 'is_valid_slug function should exist');

    -- Test valid slugs
    RETURN NEXT ok(
        dirac.is_valid_slug('valid-slug'),
        'Slug with hyphen should be valid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('product123'),
        'Alphanumeric slug should be valid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('a'),
        'Single character slug should be valid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('123'),
        'Numeric only slug should be valid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('product-123-name'),
        'Slug with multiple hyphens should be valid'
    );

    -- Test LinkedIn-specific characters
    RETURN NEXT ok(
        dirac.is_valid_slug('frank-cort%C3%A9s-76136054'),
        'LinkedIn slug with URL encoding should be valid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('company-name-'),
        'LinkedIn slug ending with hyphen should be valid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('user&param;test'),
        'Slug with & and ; should be valid (for query params)'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('ehmer-kirmani-ideapreneur--chief-knight-filmmaker'),
        'LinkedIn slug with double hyphens should be valid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('some&amp;company'),
        'Slug with HTML entities should be valid'
    );

    -- Test uppercase (now valid for URL encoding)
    RETURN NEXT ok(
        dirac.is_valid_slug('Invalid-Slug'),
        'Slug with uppercase should be valid (for URL encoding)'
    );

    RETURN NEXT ok(
        NOT dirac.is_valid_slug('invalid slug'),
        'Slug with spaces should be invalid'
    );

    RETURN NEXT ok(
        NOT dirac.is_valid_slug('invalid_slug'),
        'Slug with underscore should be invalid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('invalid--slug'),
        'Slug with consecutive hyphens should be valid (LinkedIn compatibility)'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('-invalid'),
        'Slug starting with hyphen should be valid (LinkedIn compatibility)'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug('invalid-'),
        'Slug ending with hyphen should be valid (for LinkedIn compatibility)'
    );

    RETURN NEXT ok(
        NOT dirac.is_valid_slug(''),
        'Empty string should be invalid'
    );

    RETURN NEXT ok(
        NOT dirac.is_valid_slug('slug!@#'),
        'Slug with disallowed special characters (!, @, #) should be invalid'
    );

    RETURN NEXT ok(
        NOT dirac.is_valid_slug('slug.com'),
        'Slug with period should be invalid'
    );

    RETURN NEXT ok(
        dirac.is_valid_slug(NULL) IS NULL,
        'NULL input should return NULL'
    );
END;
$$;


ALTER FUNCTION dirac.test_is_valid_slug() OWNER TO postgres;

--
-- Name: test_login_edge_cases(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_edge_cases() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT;
    v_password TEXT := 'EdgeCasePass123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'EdgeTest/1.0';
    v_uuid UUID;
BEGIN
    -- Test with email containing special characters
    v_email := 'user+tag@gmail.com';
    v_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    v_uuid := api.login(v_email, v_password, v_ip, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'Login with email containing + should work'
    );

    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
    DELETE FROM auth.user WHERE email = v_email;

    -- Test with Unicode password
    v_email := 'unicode.pass@gmail.com';
    v_password := 'Ð¿Ð°Ñ€Ð¾Ð»ÑŒå¯†ç 123';
    v_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    v_uuid := api.login(v_email, v_password, v_ip, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'Login with Unicode password should work'
    );

    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
    DELETE FROM auth.user WHERE email = v_email;

    -- Test with IPv6
    v_email := 'ipv6.test@gmail.com';
    v_password := 'IPv6Pass123';
    v_uuid := api.create_account(v_email, v_password, '2001:db8::1'::inet, v_user_agent);
    v_uuid := api.login(v_email, v_password, '2001:db8::1'::inet, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'Login with IPv6 address should work'
    );

    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
    DELETE FROM auth.user WHERE email = v_email;

    -- Test with very long user agent
    v_email := 'long.ua@gmail.com';
    v_password := 'LongUAPass123';
    v_user_agent := repeat('Mozilla/5.0 ', 50);
    v_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    v_uuid := api.login(v_email, v_password, v_ip, v_user_agent);

    RETURN NEXT ok(
        v_uuid IS NOT NULL,
        'Login with very long user agent should work'
    );

    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_email);
    DELETE FROM auth.user WHERE email = v_email;
END;
$$;


ALTER FUNCTION dirac.test_login_edge_cases() OWNER TO postgres;

--
-- Name: test_login_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'api',
        'login',
        ARRAY['text', 'text', 'inet', 'text'],
        'api.login function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_login_exists() OWNER TO postgres;

--
-- Name: test_login_failed_no_last_login_update(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_failed_no_last_login_update() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'failedlogintest@gmail.com';
    v_correct_password TEXT := 'CorrectPassword123';
    v_wrong_password TEXT := 'WrongPassword123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'Firefox/98.0';
    v_user_id BIGINT;
    v_create_uuid UUID;
    v_login_uuid UUID;
    v_last_login_before TIMESTAMPTZ;
    v_last_login_after_success TIMESTAMPTZ;
    v_last_login_after_failure TIMESTAMPTZ;
BEGIN
    -- Create account
    v_create_uuid := api.create_account(v_email, v_correct_password, v_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Successful login to set last_login
    v_login_uuid := api.login(v_email, v_correct_password, v_ip, v_user_agent);
    SELECT last_login INTO v_last_login_after_success FROM auth.user WHERE id = v_user_id;

    -- Wait a moment
    PERFORM pg_sleep(0.1);

    -- Failed login attempt
    BEGIN
        PERFORM api.login(v_email, v_wrong_password, v_ip, v_user_agent);
        RETURN NEXT fail('Wrong password should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            NULL; -- Expected error
    END;

    -- Check last_login was NOT updated
    SELECT last_login INTO v_last_login_after_failure FROM auth.user WHERE id = v_user_id;
    RETURN NEXT is(
        v_last_login_after_failure,
        v_last_login_after_success,
        'last_login should NOT be updated on failed login'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_login_failed_no_last_login_update() OWNER TO postgres;

--
-- Name: test_login_multiple_sessions(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_multiple_sessions() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'multisession@gmail.com';
    v_password TEXT := 'Password123';
    v_ip1 INET := '192.168.1.100'::inet;
    v_ip2 INET := '192.168.1.101'::inet;
    v_ip3 INET := '192.168.1.102'::inet;
    v_user_agent1 TEXT := 'Chrome/100';
    v_user_agent2 TEXT := 'Firefox/98';
    v_user_agent3 TEXT := 'Safari/15';
    v_user_id BIGINT;
    v_uuid1 UUID;
    v_uuid2 UUID;
    v_uuid3 UUID;
    v_session_count INTEGER;
BEGIN
    -- Create account
    v_uuid1 := api.create_account(v_email, v_password, v_ip1, v_user_agent1);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Login from different devices/locations
    v_uuid2 := api.login(v_email, v_password, v_ip2, v_user_agent2);
    v_uuid3 := api.login(v_email, v_password, v_ip3, v_user_agent3);

    -- All should succeed
    RETURN NEXT ok(
        v_uuid1 IS NOT NULL AND v_uuid2 IS NOT NULL AND v_uuid3 IS NOT NULL,
        'All login attempts should succeed'
    );

    -- All UUIDs should be different
    RETURN NEXT ok(
        v_uuid1 != v_uuid2 AND
        v_uuid2 != v_uuid3 AND
        v_uuid1 != v_uuid3,
        'Each session should have a unique UUID'
    );

    -- Should have 3 sessions total
    SELECT COUNT(*) INTO v_session_count FROM auth.web_session WHERE user_id = v_user_id;
    RETURN NEXT is(
        v_session_count,
        3,
        'User should have 3 active sessions'
    );

    -- Verify each session has correct details
    RETURN NEXT ok(
        EXISTS(SELECT 1 FROM auth.web_session WHERE uuid = v_uuid1 AND ip = v_ip1 AND user_agent = v_user_agent1),
        'First session should have correct IP and user agent'
    );

    RETURN NEXT ok(
        EXISTS(SELECT 1 FROM auth.web_session WHERE uuid = v_uuid2 AND ip = v_ip2 AND user_agent = v_user_agent2),
        'Second session should have correct IP and user agent'
    );

    RETURN NEXT ok(
        EXISTS(SELECT 1 FROM auth.web_session WHERE uuid = v_uuid3 AND ip = v_ip3 AND user_agent = v_user_agent3),
        'Third session should have correct IP and user agent'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_login_multiple_sessions() OWNER TO postgres;

--
-- Name: test_login_nonexistent_email(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_nonexistent_email() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'nonexistent@gmail.com';
    v_password TEXT := 'SomePassword123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'Safari/15.0';
    v_error_message TEXT;
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
    v_duration INTERVAL;
BEGIN
    -- Ensure email doesn't exist
    DELETE FROM auth.user WHERE email = v_email;

    -- Try login with non-existent email - should raise exception
    v_start_time := clock_timestamp();
    BEGIN
        PERFORM api.login(v_email, v_password, v_ip, v_user_agent);
        RETURN NEXT fail('Non-existent email should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN  -- RaiseError
            v_end_time := clock_timestamp();
            v_duration := v_end_time - v_start_time;
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            -- Check error message (same as wrong password for security)
            RETURN NEXT is(
                v_error_message,
                'Invalid credentials',
                'Non-existent email should return "Invalid credentials" (not reveal email doesn''t exist)'
            );
    END;

    -- Verify no session was created
    RETURN NEXT is(
        (SELECT COUNT(*) FROM auth.web_session WHERE ip = v_ip AND user_agent = v_user_agent AND created_at > v_start_time),
        0::bigint,
        'No session should be created for non-existent email'
    );

    -- Verify timing attack protection (dummy hash verification should occur)
    -- The function should still take time to compute even for non-existent users
    RETURN NEXT ok(
        v_duration > '0 seconds'::interval,
        'Login with non-existent email should still perform password verification (timing attack protection)'
    );
END;
$$;


ALTER FUNCTION dirac.test_login_nonexistent_email() OWNER TO postgres;

--
-- Name: test_login_nonexistent_no_last_login(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_nonexistent_no_last_login() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'doesnotexist@gmail.com';
    v_password TEXT := 'SomePassword123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'Safari/15.0';
    v_user_count INTEGER;
BEGIN
    -- Ensure email doesn't exist
    DELETE FROM auth.user WHERE email = v_email;

    -- Try login with non-existent email
    BEGIN
        PERFORM api.login(v_email, v_password, v_ip, v_user_agent);
        RETURN NEXT fail('Non-existent email should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            NULL; -- Expected error
    END;

    -- Verify no user was created or modified
    SELECT COUNT(*) INTO v_user_count FROM auth.user WHERE email = v_email;
    RETURN NEXT is(
        v_user_count,
        0,
        'No user should be created for non-existent email login attempt'
    );
END;
$$;


ALTER FUNCTION dirac.test_login_nonexistent_no_last_login() OWNER TO postgres;

--
-- Name: test_login_success(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_success() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'logintest@gmail.com';
    v_password TEXT := 'CorrectPassword123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'Chrome/100.0';
    v_user_id BIGINT;
    v_create_uuid UUID;
    v_login_uuid UUID;
    v_session_count INTEGER;
BEGIN
    -- First create an account
    v_create_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Now test login
    v_login_uuid := api.login(v_email, v_password, v_ip, v_user_agent);

    -- Check UUID is returned
    RETURN NEXT ok(
        v_login_uuid IS NOT NULL,
        'Successful login should return a session UUID'
    );

    -- Verify new session was created (should have 2 now - one from create, one from login)
    SELECT COUNT(*) INTO v_session_count FROM auth.web_session WHERE user_id = v_user_id;
    RETURN NEXT is(
        v_session_count,
        2,
        'Login should create a new session (in addition to create_account session)'
    );

    -- Verify session details
    RETURN NEXT ok(
        EXISTS(
            SELECT 1 FROM auth.web_session
            WHERE uuid = v_login_uuid
            AND user_id = v_user_id
            AND ip = v_ip
            AND user_agent = v_user_agent
            AND expires_at > NOW()
        ),
        'Login session should have correct details'
    );

    -- Verify sessions have different UUIDs
    RETURN NEXT ok(
        v_create_uuid != v_login_uuid,
        'Create and login should generate different session UUIDs'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_login_success() OWNER TO postgres;

--
-- Name: test_login_timing_attack(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_timing_attack() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_existing_email TEXT := 'timing@gmail.com';
    v_nonexistent_email TEXT := 'notexist@gmail.com';
    v_password TEXT := 'TestPassword123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'Test/1.0';
    v_create_uuid UUID;
    v_dummy_hash TEXT := '$argon2id$v=19$m=65536,t=3,p=4$p1xepijE7AcFb1mAUkn7wA$gXH7+03YO9EE9uVJ/i6VzSEk5GjhznJEiwAQRCtHNJE';
    v_time_existing INTERVAL;
    v_time_nonexistent INTERVAL;
    v_start TIMESTAMP;
    v_end TIMESTAMP;
BEGIN
    -- Create account for existing email
    v_create_uuid := api.create_account(v_existing_email, v_password, v_ip, v_user_agent);

    -- Test 1: Both should return same error message
    BEGIN
        PERFORM api.login(v_existing_email, 'WrongPassword', v_ip, v_user_agent);
        RETURN NEXT fail('Existing email with wrong password should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            RETURN NEXT is(
                SQLERRM,
                'Invalid credentials',
                'Existing email with wrong password returns "Invalid credentials"'
            );
    END;

    BEGIN
        PERFORM api.login(v_nonexistent_email, 'AnyPassword', v_ip, v_user_agent);
        RETURN NEXT fail('Non-existent email should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            RETURN NEXT is(
                SQLERRM,
                'Invalid credentials',
                'Non-existent email returns same "Invalid credentials" message'
            );
    END;

    -- Test 2: Verify dummy hash is used for non-existent users
    -- This is implementation detail testing, but important for security
    -- The login function should verify against dummy hash when user doesn't exist

    -- Time login attempt for existing user with wrong password
    v_start := clock_timestamp();
    BEGIN
        PERFORM api.login(v_existing_email, 'WrongPassword', v_ip, v_user_agent);
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            NULL; -- Expected error
    END;
    v_end := clock_timestamp();
    v_time_existing := v_end - v_start;

    -- Time login attempt for non-existent user
    v_start := clock_timestamp();
    BEGIN
        PERFORM api.login(v_nonexistent_email, 'AnyPassword', v_ip, v_user_agent);
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            NULL; -- Expected error
    END;
    v_end := clock_timestamp();
    v_time_nonexistent := v_end - v_start;

    -- Both should take some time (password verification occurs)
    RETURN NEXT ok(
        v_time_existing > '0 seconds'::interval AND v_time_nonexistent > '0 seconds'::interval,
        'Both existing and non-existent user login attempts should perform password verification'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = (SELECT id FROM auth.user WHERE email = v_existing_email);
    DELETE FROM auth.user WHERE email = v_existing_email;
END;
$_$;


ALTER FUNCTION dirac.test_login_timing_attack() OWNER TO postgres;

--
-- Name: test_login_updates_last_login(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_updates_last_login() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'lastlogintest@gmail.com';
    v_password TEXT := 'TestPassword123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'Chrome/100.0';
    v_user_id BIGINT;
    v_create_uuid UUID;
    v_login_uuid UUID;
    v_last_login_before TIMESTAMPTZ;
    v_last_login_after TIMESTAMPTZ;
    v_last_login_second TIMESTAMPTZ;
BEGIN
    -- Create an account
    v_create_uuid := api.create_account(v_email, v_password, v_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;


    -- Wait a moment to ensure timestamp difference
    PERFORM pg_sleep(0.1);

    -- Login for the first time
    v_login_uuid := api.login(v_email, v_password, v_ip, v_user_agent);

    -- Check last_login is now set
    SELECT last_login INTO v_last_login_after FROM auth.user WHERE id = v_user_id;
    RETURN NEXT ok(
        v_last_login_after IS NOT NULL,
        'last_login should be set after first login'
    );

    -- Verify last_login is recent (within last minute)
    RETURN NEXT ok(
        v_last_login_after > NOW() - INTERVAL '1 minute',
        'last_login should be recent (within last minute)'
    );

    -- Wait and login again (longer wait to ensure timestamp difference)
    PERFORM pg_sleep(1);
    v_login_uuid := api.login(v_email, v_password, v_ip, v_user_agent);

    -- Check last_login is updated
    SELECT last_login INTO v_last_login_second FROM auth.user WHERE id = v_user_id;
    RETURN NEXT ok(
        v_last_login_second > v_last_login_after,
        'last_login should be updated on subsequent login'
    );

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_login_updates_last_login() OWNER TO postgres;

--
-- Name: test_login_wrong_password(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_login_wrong_password() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'wrongpass@gmail.com';
    v_correct_password TEXT := 'CorrectPassword123';
    v_wrong_password TEXT := 'WrongPassword123';
    v_ip INET := '192.168.1.50'::inet;
    v_user_agent TEXT := 'Firefox/98.0';
    v_user_id BIGINT;
    v_create_uuid UUID;
    v_error_message TEXT;
    v_session_count_before INTEGER;
    v_session_count_after INTEGER;
BEGIN
    -- Create account
    v_create_uuid := api.create_account(v_email, v_correct_password, v_ip, v_user_agent);
    SELECT id INTO v_user_id FROM auth.user WHERE email = v_email;

    -- Count sessions before failed login
    SELECT COUNT(*) INTO v_session_count_before FROM auth.web_session WHERE user_id = v_user_id;

    -- Try login with wrong password - should raise exception
    BEGIN
        PERFORM api.login(v_email, v_wrong_password, v_ip, v_user_agent);
        RETURN NEXT fail('Wrong password should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN  -- RaiseError
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Invalid credentials',
                'Wrong password should raise RaiseError with "Invalid credentials" message'
            );
    END;

    -- Verify no new session was created
    SELECT COUNT(*) INTO v_session_count_after FROM auth.web_session WHERE user_id = v_user_id;
    RETURN NEXT is(
        v_session_count_after,
        v_session_count_before,
        'Failed login should not create a new session'
    );

    -- Test various wrong passwords
    -- Case sensitivity
    BEGIN
        PERFORM api.login(v_email, lower(v_correct_password), v_ip, v_user_agent);
        RETURN NEXT fail('Case-different password should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            RETURN NEXT pass('Password is case sensitive');
    END;

    -- Extra characters
    BEGIN
        PERFORM api.login(v_email, v_correct_password || 'x', v_ip, v_user_agent);
        RETURN NEXT fail('Password with extra characters should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            RETURN NEXT pass('Password with extra characters fails');
    END;

    -- Missing characters
    BEGIN
        PERFORM api.login(v_email, substr(v_correct_password, 1, length(v_correct_password)-1), v_ip, v_user_agent);
        RETURN NEXT fail('Password missing characters should raise exception');
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN
            RETURN NEXT pass('Password missing characters fails');
    END;

    -- Clean up
    DELETE FROM auth.web_session WHERE user_id = v_user_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_login_wrong_password() OWNER TO postgres;

--
-- Name: test_place_order_addresses_and_notes(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_addresses_and_notes() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_order_id BIGINT;
    v_shipping_location_id BIGINT;
    v_billing_location_id BIGINT;
    v_country_code CHAR(2);
    v_returned_uuid UUID;
    v_stored_shipping_id BIGINT;
    v_stored_billing_id BIGINT;
    v_stored_notes TEXT;
    v_notes TEXT := 'Please deliver to back door';
BEGIN
    SELECT iso_3166_2 INTO v_country_code FROM dirac.country LIMIT 1;

    -- Create shipping location
    INSERT INTO dirac.location (name, country, address, postcode)
    VALUES ('Shipping Address', v_country_code, '100 Ship St', 'SH1 1IP')
    RETURNING id INTO v_shipping_location_id;

    -- Create billing location
    INSERT INTO dirac.location (name, country, address, postcode)
    VALUES ('Billing Address', v_country_code, '200 Bill Ave', 'BL2 2IL')
    RETURNING id INTO v_billing_location_id;

    -- Create customer with default shipping
    INSERT INTO dirac.customer (name, email, shipping_location_id, embedding)
    VALUES ('Address Test Customer', 'addresstest@test.com', v_shipping_location_id, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('addresstest@test.com', 'hash', TRUE, v_customer_id)
    RETURNING id INTO v_user_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Address Product', 'address-prod', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 5, 25.0000, 'USD');

    -- Place order with explicit billing address and notes
    v_returned_uuid := api.place_order(
        v_user_id,
        NULL::BIGINT,  -- Use customer's default shipping
        v_billing_location_id,
        v_notes
    );

    -- Verify UUID returned
    RETURN NEXT ok(
        v_returned_uuid IS NOT NULL,
        'Should return UUID'
    );

    -- Verify UUID matches order
    RETURN NEXT is(
        (SELECT uuid FROM dirac.order WHERE id = v_order_id),
        v_returned_uuid,
        'Returned UUID should match order UUID'
    );

    -- Verify addresses and notes stored
    SELECT shipping_address_id, billing_address_id, notes
    INTO v_stored_shipping_id, v_stored_billing_id, v_stored_notes
    FROM dirac.order WHERE id = v_order_id;

    RETURN NEXT is(
        v_stored_shipping_id,
        v_shipping_location_id,
        'Should use customer default shipping address'
    );

    RETURN NEXT is(
        v_stored_billing_id,
        v_billing_location_id,
        'Should store provided billing address'
    );

    RETURN NEXT is(
        v_stored_notes,
        v_notes,
        'Should store order notes'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
    DELETE FROM dirac.location WHERE id IN (v_shipping_location_id, v_billing_location_id);
END;
$$;


ALTER FUNCTION dirac.test_place_order_addresses_and_notes() OWNER TO postgres;

--
-- Name: test_place_order_email_not_verified(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_email_not_verified() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_order_id BIGINT;
    v_location_id BIGINT;
    v_country_code CHAR(2);
    v_error_message TEXT;
BEGIN
    SELECT iso_3166_2 INTO v_country_code FROM dirac.country LIMIT 1;

    INSERT INTO dirac.location (name, country, address, postcode)
    VALUES ('Unverified Location', v_country_code, '456 Test Ave', 'TS2 2ST')
    RETURNING id INTO v_location_id;

    INSERT INTO dirac.customer (name, email, shipping_location_id, embedding)
    VALUES ('Unverified Customer', 'unverified@test.com', v_location_id, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    -- Create user with email_verified = FALSE
    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('unverified@test.com', 'hash', FALSE, v_customer_id)
    RETURNING id INTO v_user_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Unverified Product', 'unverified-prod', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 1, 10.0000, 'USD');

    -- Try to place order (should fail)
    BEGIN
        PERFORM api.place_order(v_user_id, NULL::BIGINT, NULL::BIGINT, NULL::TEXT);
        RETURN NEXT fail('Should raise exception when email not verified');
    EXCEPTION
        WHEN SQLSTATE 'P0004' THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Cannot place order: email address must be verified',
                'Should raise email verification error'
            );
    END;

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
    DELETE FROM dirac.location WHERE id = v_location_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_email_not_verified() OWNER TO postgres;

--
-- Name: test_place_order_empty_basket(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_empty_basket() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_order_id BIGINT;
    v_location_id BIGINT;
    v_country_code CHAR(2);
    v_error_message TEXT;
BEGIN
    SELECT iso_3166_2 INTO v_country_code FROM dirac.country LIMIT 1;

    INSERT INTO dirac.location (name, country, address, postcode)
    VALUES ('Empty Basket Location', v_country_code, '789 Test Blvd', 'TS3 3ST')
    RETURNING id INTO v_location_id;

    INSERT INTO dirac.customer (name, email, shipping_location_id, embedding)
    VALUES ('Empty Basket Customer', 'emptybasket@test.com', v_location_id, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('emptybasket@test.com', 'hash', TRUE, v_customer_id)
    RETURNING id INTO v_user_id;

    -- Create basket with NO items
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Try to place empty order (should fail)
    BEGIN
        PERFORM api.place_order(v_user_id, NULL::BIGINT, NULL::BIGINT, NULL::TEXT);
        RETURN NEXT fail('Should raise exception for empty basket');
    EXCEPTION
        WHEN SQLSTATE 'P0004' THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Cannot place empty order',
                'Should raise empty order error'
            );
    END;

    -- Clean up
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
    DELETE FROM dirac.location WHERE id = v_location_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_empty_basket() OWNER TO postgres;

--
-- Name: test_place_order_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'api',
        'place_order',
        ARRAY['bigint', 'bigint', 'bigint', 'text'],
        'api.place_order function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_place_order_exists() OWNER TO postgres;

--
-- Name: test_place_order_invalid_billing_address(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_invalid_billing_address() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_order_id BIGINT;
    v_location_id BIGINT;
    v_country_code CHAR(2);
    v_invalid_location_id BIGINT := 999999999;
    v_error_message TEXT;
BEGIN
    SELECT iso_3166_2 INTO v_country_code FROM dirac.country LIMIT 1;

    INSERT INTO dirac.location (name, country, address, postcode)
    VALUES ('Valid Ship Location', v_country_code, '111 Valid St', 'TS5 5ST')
    RETURNING id INTO v_location_id;

    INSERT INTO dirac.customer (name, email, shipping_location_id, embedding)
    VALUES ('Invalid Bill Customer', 'invalidbill@test.com', v_location_id, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('invalidbill@test.com', 'hash', TRUE, v_customer_id)
    RETURNING id INTO v_user_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Invalid Bill Product', 'invalid-bill-prod', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 1, 10.0000, 'USD');

    -- Try to place order with invalid billing address
    BEGIN
        PERFORM api.place_order(v_user_id, NULL::BIGINT, v_invalid_location_id, NULL::TEXT);
        RETURN NEXT fail('Should raise exception for invalid billing address');
    EXCEPTION
        WHEN SQLSTATE 'P0002' THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Invalid billing address',
                'Should raise invalid billing address error'
            );
    END;

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
    DELETE FROM dirac.location WHERE id = v_location_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_invalid_billing_address() OWNER TO postgres;

--
-- Name: test_place_order_invalid_shipping_address(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_invalid_shipping_address() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_order_id BIGINT;
    v_invalid_location_id BIGINT := 999999999;
    v_error_message TEXT;
BEGIN
    INSERT INTO dirac.customer (name, email, embedding)
    VALUES ('Invalid Ship Customer', 'invalidship@test.com', array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('invalidship@test.com', 'hash', TRUE, v_customer_id)
    RETURNING id INTO v_user_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Invalid Ship Product', 'invalid-ship-prod', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 1, 10.0000, 'USD');

    -- Try to place order with invalid shipping address
    BEGIN
        PERFORM api.place_order(v_user_id, v_invalid_location_id, NULL::BIGINT, NULL::TEXT);
        RETURN NEXT fail('Should raise exception for invalid shipping address');
    EXCEPTION
        WHEN SQLSTATE 'P0002' THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Invalid shipping address',
                'Should raise invalid shipping address error'
            );
    END;

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_invalid_shipping_address() OWNER TO postgres;

--
-- Name: test_place_order_no_basket(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_no_basket() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_location_id BIGINT;
    v_country_code CHAR(2);
    v_error_message TEXT;
BEGIN
    SELECT iso_3166_2 INTO v_country_code FROM dirac.country LIMIT 1;

    INSERT INTO dirac.location (name, country, address, postcode)
    VALUES ('No Basket Location', v_country_code, '999 Test Rd', 'TS4 4ST')
    RETURNING id INTO v_location_id;

    INSERT INTO dirac.customer (name, email, shipping_location_id, embedding)
    VALUES ('No Basket Customer', 'nobasket@test.com', v_location_id, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('nobasket@test.com', 'hash', TRUE, v_customer_id)
    RETURNING id INTO v_user_id;

    -- Don't create any basket/order

    -- Try to place order (should fail)
    BEGIN
        PERFORM api.place_order(v_user_id, NULL::BIGINT, NULL::BIGINT, NULL::TEXT);
        RETURN NEXT fail('Should raise exception when no active basket');
    EXCEPTION
        WHEN SQLSTATE 'P0002' THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'No active basket found',
                'Should raise no basket error'
            );
    END;

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
    DELETE FROM dirac.location WHERE id = v_location_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_no_basket() OWNER TO postgres;

--
-- Name: test_place_order_no_customer(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_no_customer() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_order_id BIGINT;
    v_error_message TEXT;
BEGIN
    -- Create user WITHOUT customer_id
    INSERT INTO auth.user (email, password_hash, email_verified)
    VALUES ('nocustomer@test.com', 'hash', TRUE)
    RETURNING id INTO v_user_id;

    -- Create product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('No Customer Product', 'no-customer-prod', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Create basket
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 1, 10.0000, 'USD');

    -- Try to place order (should fail)
    BEGIN
        PERFORM api.place_order(v_user_id, NULL::BIGINT, NULL::BIGINT, NULL::TEXT);
        RETURN NEXT fail('Should raise exception when customer_id is NULL');
    EXCEPTION
        WHEN SQLSTATE 'P0004' THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Cannot place order: user account must be linked to a customer',
                'Should raise appropriate error message'
            );
    END;

    -- Verify order status unchanged
    RETURN NEXT is(
        (SELECT status FROM dirac.order WHERE id = v_order_id),
        'basket'::dirac.order_status,
        'Order should remain in basket status'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_no_customer() OWNER TO postgres;

--
-- Name: test_place_order_no_shipping_address(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_no_shipping_address() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_order_id BIGINT;
    v_error_message TEXT;
BEGIN
    -- Create customer WITHOUT shipping_location_id
    INSERT INTO dirac.customer (name, email, embedding)
    VALUES ('No Address Customer', 'noaddress@test.com', array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('noaddress@test.com', 'hash', TRUE, v_customer_id)
    RETURNING id INTO v_user_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('No Address Product', 'no-address-prod', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 1, 10.0000, 'USD');

    -- Try to place order without shipping address (should fail)
    BEGIN
        PERFORM api.place_order(v_user_id, NULL::BIGINT, NULL::BIGINT, NULL::TEXT);
        RETURN NEXT fail('Should raise exception when no shipping address');
    EXCEPTION
        WHEN SQLSTATE 'P0004' THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            RETURN NEXT is(
                v_error_message,
                'Cannot place order: shipping address required',
                'Should raise shipping address error'
            );
    END;

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_no_shipping_address() OWNER TO postgres;

--
-- Name: test_place_order_success(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_place_order_success() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_customer_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_order_id BIGINT;
    v_location_id BIGINT;
    v_country_code CHAR(2);
    v_returned_uuid UUID;
    v_order_status dirac.order_status;
    v_placed_at TIMESTAMPTZ;
BEGIN
    -- Get a valid country code
    SELECT iso_3166_2 INTO v_country_code FROM dirac.country LIMIT 1;

    -- Create location
    INSERT INTO dirac.location (name, country, address, postcode)
    VALUES ('Test Location', v_country_code, '123 Test St', 'TS1 1ST')
    RETURNING id INTO v_location_id;

    -- Create customer with shipping address
    INSERT INTO dirac.customer (name, email, shipping_location_id, embedding)
    VALUES ('Test Customer', 'placeorder1@test.com', v_location_id, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_customer_id;

    -- Create verified user linked to customer
    INSERT INTO auth.user (email, password_hash, email_verified, customer_id)
    VALUES ('placeorder1@test.com', 'hash', TRUE, v_customer_id)
    RETURNING id INTO v_user_id;

    -- Create product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Order Product', 'order-product-1', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Create basket with items
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency)
    VALUES (v_order_id, v_product_case_id, 10, 50.0000, 'USD');

    -- Place the order
    v_returned_uuid := api.place_order(v_user_id, NULL::BIGINT, NULL::BIGINT, 'Test order notes');

    RETURN NEXT ok(
        v_returned_uuid IS NOT NULL,
        'Should return order UUID'
    );

    -- Verify order status changed to placed
    SELECT status, placed_at INTO v_order_status, v_placed_at
    FROM dirac.order WHERE id = v_order_id;

    RETURN NEXT is(
        v_order_status,
        'placed'::dirac.order_status,
        'Order status should be changed to "placed"'
    );

    RETURN NEXT ok(
        v_placed_at IS NOT NULL,
        'placed_at timestamp should be set'
    );

    RETURN NEXT ok(
        v_placed_at <= NOW(),
        'placed_at should be at or before current time'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
    DELETE FROM dirac.customer WHERE id = v_customer_id;
    DELETE FROM dirac.location WHERE id = v_location_id;
END;
$$;


ALTER FUNCTION dirac.test_place_order_success() OWNER TO postgres;

--
-- Name: test_schema_validation(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_schema_validation() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Currency table tests
    RETURN NEXT has_table('dirac', 'currency', 'currency table should exist');
    RETURN NEXT has_column('dirac', 'currency', 'iso_4217', 'currency should have iso_4217 column');
    RETURN NEXT col_is_pk('dirac', 'currency', 'iso_4217', 'iso_4217 should be primary key');

    -- Add more table tests here
    RETURN NEXT has_table('dirac', 'country', 'country table should exist');
    RETURN NEXT has_table('dirac', 'product', 'product table should exist');
    RETURN NEXT has_table('dirac', 'customer', 'customer table should exist');
END;
$$;


ALTER FUNCTION dirac.test_schema_validation() OWNER TO postgres;

--
-- Name: test_to_cm(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_to_cm() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
	-- Test function exists
	RETURN NEXT has_function('dirac', 'to_cm', ARRAY['dirac.length'], 'to_cm function should exist');

	-- Test NULL handling
	RETURN NEXT is(
		dirac.to_cm(NULL::dirac.length),
		NULL::DECIMAL(19,4),
		'to_cm should return NULL for NULL input'
	);

	RETURN NEXT is(
		dirac.to_cm(ROW(NULL, 'cm')::dirac.length),
		NULL::DECIMAL(19,4),
		'to_cm should return NULL for NULL value'
	);

	-- Test millimeters to cm
	RETURN NEXT is(
		dirac.to_cm(ROW(100, 'mm')::dirac.length),
		10::DECIMAL(19,4),
		'100 mm should equal 10 cm'
	);

	-- Test cm to cm (identity)
	RETURN NEXT is(
		dirac.to_cm(ROW(25.5, 'cm')::dirac.length),
		25.5::DECIMAL(19,4),
		'25.5 cm should equal 25.5 cm'
	);

	-- Test meters to cm
	RETURN NEXT is(
		dirac.to_cm(ROW(1.5, 'm')::dirac.length),
		150::DECIMAL(19,4),
		'1.5 m should equal 150 cm'
	);

	-- Test kilometers to cm
	RETURN NEXT is(
		dirac.to_cm(ROW(0.001, 'km')::dirac.length),
		100::DECIMAL(19,4),
		'0.001 km should equal 100 cm'
	);

	-- Test inches to cm
	RETURN NEXT is(
		dirac.to_cm(ROW(10, 'in')::dirac.length),
		25.4::DECIMAL(19,4),
		'10 inches should equal 25.4 cm'
	);

	-- Test feet to cm
	RETURN NEXT is(
		dirac.to_cm(ROW(1, 'ft')::dirac.length),
		30.48::DECIMAL(19,4),
		'1 foot should equal 30.48 cm'
	);

	-- Test yards to cm
	RETURN NEXT is(
		dirac.to_cm(ROW(1, 'yd')::dirac.length),
		91.44::DECIMAL(19,4),
		'1 yard should equal 91.44 cm'
	);

	-- Test miles to cm
	RETURN NEXT is(
		dirac.to_cm(ROW(0.01, 'mi')::dirac.length),
		1609.34::DECIMAL(19,4),
		'0.01 miles should equal 1609.34 cm'
	);

	-- Test edge case: zero length
	RETURN NEXT is(
		dirac.to_cm(ROW(0, 'm')::dirac.length),
		0::DECIMAL(19,4),
		'0 m should equal 0 cm'
	);

	-- Test precision with small values
	RETURN NEXT is(
		dirac.to_cm(ROW(1, 'mm')::dirac.length),
		0.1::DECIMAL(19,4),
		'1 mm should equal 0.1 cm'
	);

	-- Test conversion accuracy (1 foot = 12 inches)
	RETURN NEXT is(
		ROUND(dirac.to_cm(ROW(1, 'ft')::dirac.length), 2),
		ROUND(dirac.to_cm(ROW(12, 'in')::dirac.length), 2),
		'1 foot should equal 12 inches'
	);

	-- Test conversion accuracy (1 yard = 3 feet)
	RETURN NEXT is(
		ROUND(dirac.to_cm(ROW(1, 'yd')::dirac.length), 2),
		ROUND(dirac.to_cm(ROW(3, 'ft')::dirac.length), 2),
		'1 yard should equal 3 feet'
	);
END;
$$;


ALTER FUNCTION dirac.test_to_cm() OWNER TO postgres;

--
-- Name: test_to_gtin_14(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_to_gtin_14() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
	-- Test everything exists
	RETURN NEXT has_table('dirac','barcode','dirac.barcode should exist');
	RETURN NEXT has_function('dirac', 'to_gtin_14', ARRAY['varchar'],'to_gtin_14 function should exist');

	-- Test 1: GTIN-14 (already 14 digits) - should return as-is
	-- Valid GTIN-14: 12345678901231
	RETURN NEXT results_eq(
		'SELECT dirac.to_gtin_14(''12345678901231'')',
		'SELECT ''12345678901231''::char(14)',
		'GTIN-14 should return unchanged'
	);

	-- Test 2: GTIN-13/EAN-13 (13 digits) - should add one leading zero
	-- Valid EAN-13: 4006381333931
	RETURN NEXT results_eq(
		'SELECT dirac.to_gtin_14(''4006381333931'')',
		'SELECT ''04006381333931''::char(14)',
		'GTIN-13/EAN-13 should add one leading zero'
	);

	-- Test 3: GTIN-12/UPC-A (12 digits) - should add two leading zeros
	-- Valid UPC-A: 036000291452
	RETURN NEXT results_eq(
		'SELECT dirac.to_gtin_14(''036000291452'')',
		'SELECT ''00036000291452''::char(14)',
		'GTIN-12/UPC-A should add two leading zeros'
	);

	-- Test 4: GTIN-8/EAN-8 (8 digits) - complex conversion
	-- Valid EAN-8: 96385074
	RETURN NEXT results_eq(
		'SELECT dirac.to_gtin_14(''96385074'')',
		'SELECT ''00000096385074''::char(14)',
		'GTIN-8/EAN-8 should convert to GTIN-14'
	);

	-- Test 5: ISBN-10 (10 digits) - should convert to ISBN-13 then to GTIN-14
	-- Using a valid ISBN-10: 0306406152
	RETURN NEXT results_eq(
		'SELECT dirac.to_gtin_14(''0306406152'')',
		'SELECT ''09780306406157''::char(14)',
		'ISBN-10 should convert to ISBN-13 then GTIN-14'
	);

	-- Test 6: Invalid barcode should raise error (non-numeric)
	RETURN NEXT throws_ok(
		'SELECT dirac.to_gtin_14(''INVALID'')',
		'XX000',
		NULL,
		'Non-numeric barcode should raise error'
	);

	-- Test 7: Empty string should raise error
	RETURN NEXT throws_ok(
		'SELECT dirac.to_gtin_14('''')',
		'XX000',
		NULL,
		'Empty barcode should raise error'
	);

	-- Test 8: Invalid check digit should raise error
	RETURN NEXT throws_ok(
		'SELECT dirac.to_gtin_14(''1234567890123'')',
		'XX000',
		NULL,
		'Invalid check digit should raise error'
	);

	-- Test 9: Invalid ISBN-10 should raise error
	RETURN NEXT throws_ok(
		'SELECT dirac.to_gtin_14(''0306406151'')',
		'XX000',
		NULL,
		'Invalid ISBN-10 should raise error'
	);

END;
$$;


ALTER FUNCTION dirac.test_to_gtin_14() OWNER TO postgres;

--
-- Name: test_to_kg(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_to_kg() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
	-- Test function exists
	RETURN NEXT has_function('dirac', 'to_kg', ARRAY['dirac.weight'], 'to_kg function should exist');

	-- Test NULL handling
	RETURN NEXT is(
		dirac.to_kg(NULL::dirac.weight),
		NULL::DECIMAL(19,4),
		'to_kg should return NULL for NULL input'
	);

	RETURN NEXT is(
		dirac.to_kg(ROW(NULL, 'kg')::dirac.weight),
		NULL::DECIMAL(19,4),
		'to_kg should return NULL for NULL value'
	);

	-- Test milligrams to kg
	RETURN NEXT is(
		dirac.to_kg(ROW(1000, 'mg')::dirac.weight),
		0.001::DECIMAL(19,4),
		'1000 mg should equal 0.001 kg'
	);

	-- Test grams to kg
	RETURN NEXT is(
		dirac.to_kg(ROW(500, 'g')::dirac.weight),
		0.5::DECIMAL(19,4),
		'500 g should equal 0.5 kg'
	);

	-- Test kg to kg (identity)
	RETURN NEXT is(
		dirac.to_kg(ROW(2.5, 'kg')::dirac.weight),
		2.5::DECIMAL(19,4),
		'2.5 kg should equal 2.5 kg'
	);

	-- Test ounces to kg
	RETURN NEXT is(
		ROUND(dirac.to_kg(ROW(16, 'oz')::dirac.weight), 4),
		0.4536::DECIMAL(19,4),
		'16 oz should equal approximately 0.4536 kg'
	);

	-- Test pounds to kg
	RETURN NEXT is(
		ROUND(dirac.to_kg(ROW(10, 'lb')::dirac.weight), 4),
		4.5359::DECIMAL(19,4),
		'10 lb should equal approximately 4.5359 kg'
	);

	-- Test metric tons to kg
	RETURN NEXT is(
		dirac.to_kg(ROW(0.5, 't')::dirac.weight),
		500::DECIMAL(19,4),
		'0.5 metric tons should equal 500 kg'
	);

	-- Test edge case: zero weight
	RETURN NEXT is(
		dirac.to_kg(ROW(0, 'g')::dirac.weight),
		0::DECIMAL(19,4),
		'0 g should equal 0 kg'
	);

	-- Test precision with small values (limited to 4 decimal places)
	RETURN NEXT is(
		dirac.to_kg(ROW(1, 'mg')::dirac.weight),
		0.0000::DECIMAL(19,4),
		'1 mg rounds to 0.0000 kg due to DECIMAL(19,4) precision'
	);

	-- Test value that fits within 4 decimal places
	RETURN NEXT is(
		dirac.to_kg(ROW(10, 'mg')::dirac.weight),
		0.0000::DECIMAL(19,4),
		'10 mg rounds to 0.0000 kg due to DECIMAL(19,4) precision'
	);

	RETURN NEXT is(
		dirac.to_kg(ROW(100, 'mg')::dirac.weight),
		0.0001::DECIMAL(19,4),
		'100 mg should equal 0.0001 kg'
	);

	-- Test large values
	RETURN NEXT is(
		dirac.to_kg(ROW(1000, 't')::dirac.weight),
		1000000::DECIMAL(19,4),
		'1000 metric tons should equal 1000000 kg'
	);
END;
$$;


ALTER FUNCTION dirac.test_to_kg() OWNER TO postgres;

--
-- Name: test_to_ml(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_to_ml() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
	-- Test function exists
	RETURN NEXT has_function('dirac', 'to_ml', ARRAY['dirac.volume'], 'to_ml function should exist');

	-- Test NULL handling
	RETURN NEXT is(
		dirac.to_ml(NULL::dirac.volume),
		NULL::DECIMAL(19,4),
		'to_ml should return NULL for NULL input'
	);

	RETURN NEXT is(
		dirac.to_ml(ROW(NULL, 'ml')::dirac.volume),
		NULL::DECIMAL(19,4),
		'to_ml should return NULL for NULL value'
	);

	-- Test ml to ml (identity)
	RETURN NEXT is(
		dirac.to_ml(ROW(250, 'ml')::dirac.volume),
		250::DECIMAL(19,4),
		'250 ml should equal 250 ml'
	);

	-- Test liters to ml
	RETURN NEXT is(
		dirac.to_ml(ROW(1.5, 'l')::dirac.volume),
		1500::DECIMAL(19,4),
		'1.5 liters should equal 1500 ml'
	);

	-- Test fluid ounces to ml
	RETURN NEXT is(
		ROUND(dirac.to_ml(ROW(8, 'fl_oz')::dirac.volume), 2),
		236.59::DECIMAL(19,4),
		'8 fl oz should equal approximately 236.59 ml'
	);

	-- Test cups to ml
	RETURN NEXT is(
		ROUND(dirac.to_ml(ROW(1, 'cup')::dirac.volume), 2),
		236.59::DECIMAL(19,4),
		'1 cup should equal approximately 236.59 ml'
	);

	-- Test pints to ml
	RETURN NEXT is(
		ROUND(dirac.to_ml(ROW(1, 'pt')::dirac.volume), 2),
		473.18::DECIMAL(19,4),
		'1 pint should equal approximately 473.18 ml'
	);

	-- Test quarts to ml
	RETURN NEXT is(
		ROUND(dirac.to_ml(ROW(1, 'qt')::dirac.volume), 2),
		946.35::DECIMAL(19,4),
		'1 quart should equal approximately 946.35 ml'
	);

	-- Test gallons to ml
	RETURN NEXT is(
		ROUND(dirac.to_ml(ROW(1, 'gal')::dirac.volume), 2),
		3785.41::DECIMAL(19,4),
		'1 gallon should equal approximately 3785.41 ml'
	);

	-- Test edge case: zero volume
	RETURN NEXT is(
		dirac.to_ml(ROW(0, 'l')::dirac.volume),
		0::DECIMAL(19,4),
		'0 liters should equal 0 ml'
	);

	-- Test fractional values
	RETURN NEXT is(
		dirac.to_ml(ROW(0.5, 'l')::dirac.volume),
		500::DECIMAL(19,4),
		'0.5 liters should equal 500 ml'
	);

	-- Test large values
	RETURN NEXT is(
		dirac.to_ml(ROW(100, 'gal')::dirac.volume),
		378541::DECIMAL(19,4),
		'100 gallons should equal 378541 ml'
	);

	-- Test conversion chain accuracy (1 gal = 4 qt = 8 pt = 16 cups)
	RETURN NEXT is(
		ROUND(dirac.to_ml(ROW(16, 'cup')::dirac.volume), 0),
		ROUND(dirac.to_ml(ROW(1, 'gal')::dirac.volume), 0),
		'16 cups should equal 1 gallon'
	);
END;
$$;


ALTER FUNCTION dirac.test_to_ml() OWNER TO postgres;

--
-- Name: test_update_order_total_basic(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_update_order_total_basic() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_stored_total_incl_vat DECIMAL(19,4);
    v_stored_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('updatetest1@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order with NULL totals initially
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Update Test Product', 'update-test-prod', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Add order item: 10 cases at $15.00 = $150.00 (no VAT)
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, uk_vat_fraction)
    VALUES (v_order_id, v_product_case_id, 10, 15.0000, 'USD', 0.00);

    -- Update the order total
    PERFORM dirac.update_order_total(v_order_id);

    -- Retrieve stored values
    SELECT total_amount_incl_vat, currency INTO v_stored_total_incl_vat, v_stored_currency
    FROM dirac.order WHERE id = v_order_id;

    RETURN NEXT is(
        v_stored_total_incl_vat,
        150.0000::DECIMAL(19,4),
        'Order total_amount_incl_vat should be updated to $150.00'
    );

    RETURN NEXT is(
        v_stored_currency,
        'USD'::CHAR(3),
        'Order currency should be updated to USD'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_update_order_total_basic() OWNER TO postgres;

--
-- Name: test_update_order_total_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_update_order_total_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'dirac',
        'update_order_total',
        ARRAY['bigint'],
        'dirac.update_order_total function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_update_order_total_exists() OWNER TO postgres;

--
-- Name: test_update_order_total_idempotent(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_update_order_total_idempotent() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_total_after_first DECIMAL(19,4);
    v_total_after_second DECIMAL(19,4);
    v_total_after_third DECIMAL(19,4);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('updatetest4@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Idempotent Test', 'idempotent-test', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Add order item (no VAT)
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, uk_vat_fraction)
    VALUES (v_order_id, v_product_case_id, 3, 25.0000, 'USD', 0.00);

    -- First update
    PERFORM dirac.update_order_total(v_order_id);
    SELECT total_amount_incl_vat INTO v_total_after_first FROM dirac.order WHERE id = v_order_id;

    -- Second update (no changes to items)
    PERFORM dirac.update_order_total(v_order_id);
    SELECT total_amount_incl_vat INTO v_total_after_second FROM dirac.order WHERE id = v_order_id;

    -- Third update (still no changes)
    PERFORM dirac.update_order_total(v_order_id);
    SELECT total_amount_incl_vat INTO v_total_after_third FROM dirac.order WHERE id = v_order_id;

    -- All three should be the same
    RETURN NEXT is(
        v_total_after_first,
        75.0000::DECIMAL(19,4),
        'First update should calculate correct total'
    );

    RETURN NEXT is(
        v_total_after_second,
        v_total_after_first,
        'Second update should produce same result (idempotent)'
    );

    RETURN NEXT is(
        v_total_after_third,
        v_total_after_first,
        'Third update should produce same result (idempotent)'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_update_order_total_idempotent() OWNER TO postgres;

--
-- Name: test_update_order_total_null(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_update_order_total_null() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_stored_total_incl_vat DECIMAL(19,4);
    v_stored_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('updatetest2@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create empty order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Update the order total (no items, should be NULL)
    PERFORM dirac.update_order_total(v_order_id);

    -- Retrieve stored values
    SELECT total_amount_incl_vat, currency INTO v_stored_total_incl_vat, v_stored_currency
    FROM dirac.order WHERE id = v_order_id;

    RETURN NEXT is(
        v_stored_total_incl_vat,
        NULL::DECIMAL(19,4),
        'Empty order should have NULL total_amount_incl_vat'
    );

    RETURN NEXT is(
        v_stored_currency,
        NULL::CHAR(3),
        'Empty order should have NULL currency'
    );

    -- Clean up
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_update_order_total_null() OWNER TO postgres;

--
-- Name: test_update_order_total_overwrite(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_update_order_total_overwrite() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product_id BIGINT;
    v_product_case_id BIGINT;
    v_stored_total_incl_vat DECIMAL(19,4);
    v_stored_currency CHAR(3);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('updatetest3@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order with initial bogus total
    INSERT INTO dirac.order (user_id, status, total_amount_incl_vat, currency)
    VALUES (v_user_id, 'basket', 999.9900, 'USD')
    RETURNING id INTO v_order_id;

    -- Create product
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Overwrite Test', 'overwrite-test', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product_id;

    -- Create product_case
    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product_id, 12)
    RETURNING id INTO v_product_case_id;

    -- Add order item: 5 cases at $20.00 = $100.00 (no VAT)
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, uk_vat_fraction)
    VALUES (v_order_id, v_product_case_id, 5, 20.0000, 'USD', 0.00);

    -- Update should overwrite the bogus values
    PERFORM dirac.update_order_total(v_order_id);

    -- Retrieve stored values
    SELECT total_amount_incl_vat, currency INTO v_stored_total_incl_vat, v_stored_currency
    FROM dirac.order WHERE id = v_order_id;

    RETURN NEXT is(
        v_stored_total_incl_vat,
        100.0000::DECIMAL(19,4),
        'Should overwrite previous total with calculated value'
    );

    RETURN NEXT is(
        v_stored_currency,
        'USD'::CHAR(3),
        'Should overwrite previous currency with calculated value'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id = v_product_case_id;
    DELETE FROM dirac.product WHERE id = v_product_id;
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_update_order_total_overwrite() OWNER TO postgres;

--
-- Name: test_update_order_total_reflects_changes(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_update_order_total_reflects_changes() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_user_id BIGINT;
    v_order_id BIGINT;
    v_product1_id BIGINT;
    v_product_case1_id BIGINT;
    v_product2_id BIGINT;
    v_product_case2_id BIGINT;
    v_total_initial DECIMAL(19,4);
    v_total_after_add DECIMAL(19,4);
    v_total_after_remove DECIMAL(19,4);
BEGIN
    -- Create test user
    INSERT INTO auth.user (email, password_hash)
    VALUES ('updatetest5@test.com', 'hash')
    RETURNING id INTO v_user_id;

    -- Create order
    INSERT INTO dirac.order (user_id, status)
    VALUES (v_user_id, 'basket')
    RETURNING id INTO v_order_id;

    -- Create products
    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Product 1', 'prod-1-update', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product1_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product1_id, 12)
    RETURNING id INTO v_product_case1_id;

    INSERT INTO dirac.product (name, slug, show_on_web, embedding)
    VALUES ('Product 2', 'prod-2-update', FALSE, array_fill(0, ARRAY[768])::vector(768))
    RETURNING id INTO v_product2_id;

    INSERT INTO dirac.product_case (product_id, units_per_case)
    VALUES (v_product2_id, 12)
    RETURNING id INTO v_product_case2_id;

    -- Add first item: 10 cases at $10 = $100 (no VAT)
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, uk_vat_fraction)
    VALUES (v_order_id, v_product_case1_id, 10, 10.0000, 'USD', 0.00);

    PERFORM dirac.update_order_total(v_order_id);
    SELECT total_amount_incl_vat INTO v_total_initial FROM dirac.order WHERE id = v_order_id;

    -- Add second item: 5 cases at $20 = $100 (total should now be $200, no VAT)
    INSERT INTO dirac.order_item (order_id, product_case_id, case_quantity, case_price, currency, uk_vat_fraction)
    VALUES (v_order_id, v_product_case2_id, 5, 20.0000, 'USD', 0.00);

    PERFORM dirac.update_order_total(v_order_id);
    SELECT total_amount_incl_vat INTO v_total_after_add FROM dirac.order WHERE id = v_order_id;

    -- Remove first item (total should now be $100)
    DELETE FROM dirac.order_item WHERE order_id = v_order_id AND product_case_id = v_product_case1_id;

    PERFORM dirac.update_order_total(v_order_id);
    SELECT total_amount_incl_vat INTO v_total_after_remove FROM dirac.order WHERE id = v_order_id;

    -- Verify the progression
    RETURN NEXT is(
        v_total_initial,
        100.0000::DECIMAL(19,4),
        'Initial total with one item should be $100'
    );

    RETURN NEXT is(
        v_total_after_add,
        200.0000::DECIMAL(19,4),
        'Total after adding second item should be $200'
    );

    RETURN NEXT is(
        v_total_after_remove,
        100.0000::DECIMAL(19,4),
        'Total after removing first item should be $100'
    );

    -- Clean up
    DELETE FROM dirac.order_item WHERE order_id = v_order_id;
    DELETE FROM dirac.order WHERE id = v_order_id;
    DELETE FROM dirac.product_case WHERE id IN (v_product_case1_id, v_product_case2_id);
    DELETE FROM dirac.product WHERE id IN (v_product1_id, v_product2_id);
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$_$;


ALTER FUNCTION dirac.test_update_order_total_reflects_changes() OWNER TO postgres;

--
-- Name: test_upsert_customer(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_upsert_customer() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_customer_id BIGINT;
    v_customer_id2 BIGINT;
    v_test_embedding vector(768);
    v_updated_embedding vector(768);
    v_stored_embedding vector(768);
BEGIN
    -- Create a test embedding (normally this would come from an ML model)
    -- Using array_fill to create a vector of 768 dimensions filled with 0.1
    v_test_embedding := array_fill(0.1::float4, ARRAY[768])::vector(768);
    v_updated_embedding := array_fill(0.2::float4, ARRAY[768])::vector(768);

    -- Test 1: Successfully create customer with embedding
    v_customer_id := dirac.upsert_customer('Test Customer Inc'::VARCHAR(255), NULL::INT, v_test_embedding);

    RETURN NEXT ok(v_customer_id IS NOT NULL, 'Should return customer ID when creating new customer');

    -- Verify customer was created with correct data
    RETURN NEXT results_eq(
        'SELECT name FROM dirac.customer WHERE id = ' || v_customer_id,
        'SELECT ''Test Customer Inc''::VARCHAR',
        'Customer name should match input'
    );

    -- Verify embedding was stored
    SELECT embedding INTO v_stored_embedding FROM dirac.customer WHERE id = v_customer_id;
    RETURN NEXT ok(v_stored_embedding IS NOT NULL, 'Embedding should be stored');

    -- Test 2: Upsert same customer updates embedding
    v_customer_id2 := dirac.upsert_customer('Test Customer Inc'::VARCHAR(255), 12345::INT, v_updated_embedding);

    RETURN NEXT is(v_customer_id2, v_customer_id, 'Should return same ID when upserting existing customer');

    -- Verify embedding was updated
    SELECT embedding INTO v_stored_embedding FROM dirac.customer WHERE id = v_customer_id;
    RETURN NEXT is(v_stored_embedding, v_updated_embedding, 'Embedding should be updated on upsert');

    -- Test 3: Error when embedding is NULL
    BEGIN
        PERFORM dirac.upsert_customer('Another Customer'::VARCHAR(255), NULL::INT, NULL::vector(768));
        RETURN NEXT fail('Should raise exception when embedding is NULL');
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NEXT ok(SQLERRM LIKE '%embedding cannot be null%', 'Should raise error for NULL embedding');
    END;

    -- Test 4: Error when customer name is NULL
    BEGIN
        PERFORM dirac.upsert_customer(NULL::VARCHAR(255), NULL::INT, v_test_embedding);
        RETURN NEXT fail('Should raise exception when customer name is NULL');
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NEXT ok(SQLERRM LIKE '%name cannot be null%', 'Should raise error for NULL name');
    END;

    -- Test 5: Error when customer name is empty
    BEGIN
        PERFORM dirac.upsert_customer(''::VARCHAR(255), NULL::INT, v_test_embedding);
        RETURN NEXT fail('Should raise exception when customer name is empty');
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NEXT ok(SQLERRM LIKE '%name cannot be null or empty%', 'Should raise error for empty name');
    END;

    -- Test 6: Trimming whitespace from names
    v_customer_id := dirac.upsert_customer('  Whitespace Customer  '::VARCHAR(255), NULL::INT, v_test_embedding);

    RETURN NEXT results_eq(
        'SELECT name FROM dirac.customer WHERE id = ' || v_customer_id,
        'SELECT ''Whitespace Customer''::VARCHAR',
        'Customer name should be trimmed'
    );
END;
$$;


ALTER FUNCTION dirac.test_upsert_customer() OWNER TO postgres;

--
-- Name: test_verify_email_token_already_verified(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_already_verified() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'alreadyverified@test.com';
    v_user_id BIGINT;
    v_token UUID := gen_random_uuid();
    v_expires_at TIMESTAMPTZ := NOW() + INTERVAL '24 hours';
    v_success BOOLEAN;
    v_returned_email TEXT;
    v_email_verified BOOLEAN;
BEGIN
    -- Create test user that is already verified
    INSERT INTO auth.user (
        email,
        password_hash,
        email_verified,
        email_verification_token,
        email_verification_expires_at
    )
    VALUES (v_email, 'hash', TRUE, v_token, v_expires_at)
    RETURNING id INTO v_user_id;

    -- Verify again with the token
    SELECT * INTO v_success, v_returned_email
    FROM api.verify_email_token(v_token);

    RETURN NEXT is(
        v_success,
        TRUE,
        'Verification should succeed even if already verified'
    );

    RETURN NEXT is(
        v_returned_email,
        v_email,
        'Should return email'
    );

    -- Verify user remains verified
    SELECT email_verified INTO v_email_verified
    FROM auth.user WHERE id = v_user_id;

    RETURN NEXT is(
        v_email_verified,
        TRUE,
        'User should remain verified (idempotent)'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_already_verified() OWNER TO postgres;

--
-- Name: test_verify_email_token_clears_token(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_clears_token() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'cleartoken@test.com';
    v_user_id BIGINT;
    v_token UUID := gen_random_uuid();
    v_expires_at TIMESTAMPTZ := NOW() + INTERVAL '24 hours';
    v_stored_token UUID;
    v_stored_expires TIMESTAMPTZ;
BEGIN
    -- Create test user with token
    INSERT INTO auth.user (
        email,
        password_hash,
        email_verified,
        email_verification_token,
        email_verification_expires_at
    )
    VALUES (v_email, 'hash', FALSE, v_token, v_expires_at)
    RETURNING id INTO v_user_id;

    -- Verify the token
    PERFORM api.verify_email_token(v_token);

    -- Check token and expiry were cleared
    SELECT email_verification_token, email_verification_expires_at
    INTO v_stored_token, v_stored_expires
    FROM auth.user WHERE id = v_user_id;

    RETURN NEXT is(
        v_stored_token,
        NULL::UUID,
        'Verification token should be NULL after successful verification'
    );

    RETURN NEXT is(
        v_stored_expires,
        NULL::TIMESTAMPTZ,
        'Token expiry should be NULL after successful verification'
    );

    -- Try to use the same token again (should fail since it's cleared)
    RETURN NEXT is(
        (SELECT success FROM api.verify_email_token(v_token)),
        FALSE,
        'Token should not work after being cleared'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_clears_token() OWNER TO postgres;

--
-- Name: test_verify_email_token_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'api',
        'verify_email_token',
        ARRAY['uuid'],
        'api.verify_email_token function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_exists() OWNER TO postgres;

--
-- Name: test_verify_email_token_expired(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_expired() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'expired@test.com';
    v_user_id BIGINT;
    v_token UUID := gen_random_uuid();
    v_expires_at TIMESTAMPTZ := NOW() - INTERVAL '1 hour';  -- Expired 1 hour ago
    v_success BOOLEAN;
    v_returned_email TEXT;
    v_email_verified BOOLEAN;
BEGIN
    -- Create test user with expired token
    INSERT INTO auth.user (
        email,
        password_hash,
        email_verified,
        email_verification_token,
        email_verification_expires_at
    )
    VALUES (v_email, 'hash', FALSE, v_token, v_expires_at)
    RETURNING id INTO v_user_id;

    -- Try to verify expired token
    SELECT * INTO v_success, v_returned_email
    FROM api.verify_email_token(v_token);

    RETURN NEXT is(
        v_success,
        FALSE,
        'Verification should fail for expired token'
    );

    RETURN NEXT is(
        v_returned_email,
        v_email,
        'Should return email even for expired token'
    );

    -- Verify user was NOT verified
    SELECT email_verified INTO v_email_verified
    FROM auth.user WHERE id = v_user_id;

    RETURN NEXT is(
        v_email_verified,
        FALSE,
        'User should remain unverified with expired token'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_expired() OWNER TO postgres;

--
-- Name: test_verify_email_token_expiry_edge(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_expiry_edge() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'edgecase@test.com';
    v_user_id BIGINT;
    v_token UUID := gen_random_uuid();
    v_expires_at TIMESTAMPTZ;
    v_success BOOLEAN;
BEGIN
    -- Set expiry to 1 second in the past to ensure it's expired
    v_expires_at := NOW() - INTERVAL '1 second';

    -- Create test user with expired token
    INSERT INTO auth.user (
        email,
        password_hash,
        email_verified,
        email_verification_token,
        email_verification_expires_at
    )
    VALUES (v_email, 'hash', FALSE, v_token, v_expires_at)
    RETURNING id INTO v_user_id;

    -- Try to verify (should fail since expires_at < NOW())
    SELECT success INTO v_success
    FROM api.verify_email_token(v_token);

    RETURN NEXT is(
        v_success,
        FALSE,
        'Token expired 1 second ago should fail verification'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_expiry_edge() OWNER TO postgres;

--
-- Name: test_verify_email_token_multiple_users(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_multiple_users() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user1_id BIGINT;
    v_user2_id BIGINT;
    v_token1 UUID := gen_random_uuid();
    v_token2 UUID := gen_random_uuid();
    v_expires TIMESTAMPTZ := NOW() + INTERVAL '24 hours';
BEGIN
    -- Create two users with different tokens
    INSERT INTO auth.user (email, password_hash, email_verified, email_verification_token, email_verification_expires_at)
    VALUES ('user1@test.com', 'hash', FALSE, v_token1, v_expires)
    RETURNING id INTO v_user1_id;

    INSERT INTO auth.user (email, password_hash, email_verified, email_verification_token, email_verification_expires_at)
    VALUES ('user2@test.com', 'hash', FALSE, v_token2, v_expires)
    RETURNING id INTO v_user2_id;

    -- Verify user1's token
    PERFORM api.verify_email_token(v_token1);

    -- Check user1 is verified
    RETURN NEXT is(
        (SELECT email_verified FROM auth.user WHERE id = v_user1_id),
        TRUE,
        'User 1 should be verified'
    );

    -- Check user2 is NOT verified
    RETURN NEXT is(
        (SELECT email_verified FROM auth.user WHERE id = v_user2_id),
        FALSE,
        'User 2 should remain unverified'
    );

    -- Verify user2's token
    PERFORM api.verify_email_token(v_token2);

    -- Check both are now verified
    RETURN NEXT is(
        (SELECT email_verified FROM auth.user WHERE id = v_user2_id),
        TRUE,
        'User 2 should now be verified'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id IN (v_user1_id, v_user2_id);
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_multiple_users() OWNER TO postgres;

--
-- Name: test_verify_email_token_not_found(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_not_found() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_nonexistent_token UUID := gen_random_uuid();
    v_success BOOLEAN;
    v_returned_email TEXT;
BEGIN
    -- Try to verify non-existent token
    SELECT * INTO v_success, v_returned_email
    FROM api.verify_email_token(v_nonexistent_token);

    RETURN NEXT is(
        v_success,
        FALSE,
        'Verification should fail for non-existent token'
    );

    RETURN NEXT is(
        v_returned_email,
        NULL::TEXT,
        'Should return NULL email for non-existent token'
    );
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_not_found() OWNER TO postgres;

--
-- Name: test_verify_email_token_success(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_email_token_success() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_email TEXT := 'verifytest1@test.com';
    v_user_id BIGINT;
    v_token UUID := gen_random_uuid();
    v_expires_at TIMESTAMPTZ := NOW() + INTERVAL '24 hours';
    v_success BOOLEAN;
    v_returned_email TEXT;
    v_email_verified BOOLEAN;
    v_stored_token UUID;
BEGIN
    -- Create test user with unverified email and token
    INSERT INTO auth.user (
        email,
        password_hash,
        email_verified,
        email_verification_token,
        email_verification_expires_at
    )
    VALUES (v_email, 'hash', FALSE, v_token, v_expires_at)
    RETURNING id INTO v_user_id;

    -- Verify the token
    SELECT * INTO v_success, v_returned_email
    FROM api.verify_email_token(v_token);

    RETURN NEXT is(
        v_success,
        TRUE,
        'Verification should succeed'
    );

    RETURN NEXT is(
        v_returned_email,
        v_email,
        'Should return the user email'
    );

    -- Check user record was updated
    SELECT email_verified, email_verification_token
    INTO v_email_verified, v_stored_token
    FROM auth.user WHERE id = v_user_id;

    RETURN NEXT is(
        v_email_verified,
        TRUE,
        'User email_verified should be set to TRUE'
    );

    RETURN NEXT is(
        v_stored_token,
        NULL::UUID,
        'Verification token should be cleared after success'
    );

    -- Clean up
    DELETE FROM auth.user WHERE id = v_user_id;
END;
$$;


ALTER FUNCTION dirac.test_verify_email_token_success() OWNER TO postgres;

--
-- Name: test_verify_password_correct(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_password_correct() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_password TEXT := 'MySecurePassword123!';
    v_hash TEXT;
BEGIN
    -- Hash the password
    v_hash := auth.hash_password(v_password);

    -- Verify correct password returns true
    RETURN NEXT is(
        auth.verify_password(v_password, v_hash),
        TRUE,
        'Correct password should verify as TRUE'
    );

    -- Test with different password complexities
    v_password := 'simple';
    v_hash := auth.hash_password(v_password);
    RETURN NEXT is(
        auth.verify_password(v_password, v_hash),
        TRUE,
        'Simple password should verify correctly'
    );

    v_password := 'P@$w0rd!#%&*()[]{}';
    v_hash := auth.hash_password(v_password);
    RETURN NEXT is(
        auth.verify_password(v_password, v_hash),
        TRUE,
        'Complex password with special chars should verify correctly'
    );
END;
$_$;


ALTER FUNCTION dirac.test_verify_password_correct() OWNER TO postgres;

--
-- Name: test_verify_password_edge_cases(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_password_edge_cases() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_password TEXT;
    v_hash TEXT;
BEGIN
    -- Empty password
    v_password := '';
    v_hash := auth.hash_password(v_password);
    RETURN NEXT is(
        auth.verify_password(v_password, v_hash),
        TRUE,
        'Empty password should verify correctly against its hash'
    );

    -- Very long password
    v_password := repeat('a', 500);
    v_hash := auth.hash_password(v_password);
    RETURN NEXT is(
        auth.verify_password(v_password, v_hash),
        TRUE,
        'Very long password should verify correctly'
    );

    -- Unicode password
    v_password := 'Ð¿Ð°Ñ€Ð¾Ð»ÑŒå¯†ç ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰';
    v_hash := auth.hash_password(v_password);
    RETURN NEXT is(
        auth.verify_password(v_password, v_hash),
        TRUE,
        'Unicode password should verify correctly'
    );

    -- Password with quotes
    v_password := 'pass"word''test';
    v_hash := auth.hash_password(v_password);
    RETURN NEXT is(
        auth.verify_password(v_password, v_hash),
        TRUE,
        'Password with quotes should verify correctly'
    );
END;
$$;


ALTER FUNCTION dirac.test_verify_password_edge_cases() OWNER TO postgres;

--
-- Name: test_verify_password_exists(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_password_exists() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_function(
        'auth',
        'verify_password',
        ARRAY['text', 'text'],
        'auth.verify_password function should exist'
    );
END;
$$;


ALTER FUNCTION dirac.test_verify_password_exists() OWNER TO postgres;

--
-- Name: test_verify_password_invalid_hash(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_password_invalid_hash() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
BEGIN
    -- Test with completely invalid hash
    RETURN NEXT is(
        auth.verify_password('password', 'not_a_valid_hash'),
        FALSE,
        'Invalid hash format should return FALSE'
    );

    -- Test with empty hash
    RETURN NEXT is(
        auth.verify_password('password', ''),
        FALSE,
        'Empty hash should return FALSE'
    );

    -- Test with hash from different algorithm (not Argon2)
    RETURN NEXT is(
        auth.verify_password('password', '$2a$10$abcdefghijklmnopqrstuv'),
        FALSE,
        'Hash from different algorithm should return FALSE'
    );
END;
$_$;


ALTER FUNCTION dirac.test_verify_password_invalid_hash() OWNER TO postgres;

--
-- Name: test_verify_password_null(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_password_null() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hash TEXT;
BEGIN
    v_hash := auth.hash_password('testpassword');

    -- Function is STRICT, so NULL inputs should return NULL
    RETURN NEXT is(
        auth.verify_password(NULL, v_hash),
        NULL,
        'NULL password should return NULL (STRICT function)'
    );

    RETURN NEXT is(
        auth.verify_password('testpassword', NULL),
        NULL,
        'NULL hash should return NULL (STRICT function)'
    );

    RETURN NEXT is(
        auth.verify_password(NULL, NULL),
        NULL,
        'Both NULL should return NULL (STRICT function)'
    );
END;
$$;


ALTER FUNCTION dirac.test_verify_password_null() OWNER TO postgres;

--
-- Name: test_verify_password_timing(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_password_timing() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_valid_hash TEXT;
    v_dummy_hash TEXT := '$argon2id$v=19$m=65536,t=3,p=4$p1xepijE7AcFb1mAUkn7wA$gXH7+03YO9EE9uVJ/i6VzSEk5GjhznJEiwAQRCtHNJE';
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
    v_valid_duration INTERVAL;
    v_invalid_duration INTERVAL;
BEGIN
    -- Create a valid hash
    v_valid_hash := auth.hash_password('testpassword');

    -- Note: This test is more of a demonstration that the function completes
    -- Actual timing attack resistance is provided by the Argon2 library

    -- Test with valid hash
    v_start_time := clock_timestamp();
    PERFORM auth.verify_password('wrongpassword', v_valid_hash);
    v_end_time := clock_timestamp();
    v_valid_duration := v_end_time - v_start_time;

    -- Test with dummy hash (simulating non-existent user)
    v_start_time := clock_timestamp();
    PERFORM auth.verify_password('wrongpassword', v_dummy_hash);
    v_end_time := clock_timestamp();
    v_invalid_duration := v_end_time - v_start_time;

    -- Both should complete (timing comparison is handled by Argon2)
    RETURN NEXT ok(
        v_valid_duration IS NOT NULL AND v_invalid_duration IS NOT NULL,
        'Both valid and dummy hash verifications should complete'
    );

    -- Verify dummy hash always returns false
    RETURN NEXT is(
        auth.verify_password('anypassword', v_dummy_hash),
        FALSE,
        'Dummy hash should always return FALSE'
    );
END;
$_$;


ALTER FUNCTION dirac.test_verify_password_timing() OWNER TO postgres;

--
-- Name: test_verify_password_wrong(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_verify_password_wrong() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_password TEXT := 'CorrectPassword123';
    v_wrong_password TEXT := 'WrongPassword123';
    v_hash TEXT;
BEGIN
    -- Hash the correct password
    v_hash := auth.hash_password(v_password);

    -- Verify wrong password returns false
    RETURN NEXT is(
        auth.verify_password(v_wrong_password, v_hash),
        FALSE,
        'Wrong password should verify as FALSE'
    );

    -- Test variations of wrong passwords
    RETURN NEXT is(
        auth.verify_password('correctpassword123', v_hash), -- Different case
        FALSE,
        'Password with different case should fail'
    );

    RETURN NEXT is(
        auth.verify_password('CorrectPassword', v_hash), -- Missing chars
        FALSE,
        'Password missing characters should fail'
    );

    RETURN NEXT is(
        auth.verify_password('CorrectPassword1234', v_hash), -- Extra chars
        FALSE,
        'Password with extra characters should fail'
    );

    RETURN NEXT is(
        auth.verify_password(' CorrectPassword123', v_hash), -- Leading space
        FALSE,
        'Password with leading space should fail'
    );

    RETURN NEXT is(
        auth.verify_password('CorrectPassword123 ', v_hash), -- Trailing space
        FALSE,
        'Password with trailing space should fail'
    );
END;
$$;


ALTER FUNCTION dirac.test_verify_password_wrong() OWNER TO postgres;

--
-- Name: test_weight_volume_types(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.test_weight_volume_types() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
	-- Test weight type exists
	RETURN NEXT has_type('dirac', 'weight', 'weight composite type should exist');
	RETURN NEXT has_type('dirac', 'weight_unit', 'weight_unit enum should exist');

	-- Test volume type exists
	RETURN NEXT has_type('dirac', 'volume', 'volume composite type should exist');
	RETURN NEXT has_type('dirac', 'volume_unit', 'volume_unit enum should exist');

	-- Test length type exists
	RETURN NEXT has_type('dirac', 'length', 'length composite type should exist');
	RETURN NEXT has_type('dirac', 'length_unit', 'length_unit enum should exist');

	-- Test product quantity types
	RETURN NEXT has_type('dirac', 'product_quantity', 'product_quantity composite type should exist');
	RETURN NEXT has_type('dirac', 'product_quantity_unit', 'product_quantity_unit enum should exist');

	-- Test creating weight values
	RETURN NEXT lives_ok(
		'SELECT ROW(100, ''kg'')::dirac.weight',
		'Should be able to create weight with kg'
	);

	RETURN NEXT lives_ok(
		'SELECT ROW(5.5, ''lb'')::dirac.weight',
		'Should be able to create weight with lb'
	);

	-- Test creating volume values
	RETURN NEXT lives_ok(
		'SELECT ROW(500, ''ml'')::dirac.volume',
		'Should be able to create volume with ml'
	);

	RETURN NEXT lives_ok(
		'SELECT ROW(2.5, ''gal'')::dirac.volume',
		'Should be able to create volume with gal'
	);

	-- Test creating product quantity values
	RETURN NEXT lives_ok(
		'SELECT ROW(10, ''case'')::dirac.product_quantity',
		'Should be able to create product quantity with cases'
	);

	RETURN NEXT lives_ok(
		'SELECT ROW(1, ''pallet'')::dirac.product_quantity',
		'Should be able to create product quantity with pallet'
	);

	-- Test weight composite type structure
	RETURN NEXT results_eq(
		'SELECT (ROW(10.5, ''kg'')::dirac.weight).value',
		'SELECT 10.5::DECIMAL(19,4)',
		'Weight value should be accessible'
	);

	RETURN NEXT results_eq(
		'SELECT (ROW(10.5, ''kg'')::dirac.weight).unit::text',
		'SELECT ''kg''::text',
		'Weight unit should be accessible'
	);

	-- Test volume composite type structure
	RETURN NEXT results_eq(
		'SELECT (ROW(250.5, ''ml'')::dirac.volume).value',
		'SELECT 250.5::DECIMAL(19,4)',
		'Volume value should be accessible'
	);

	RETURN NEXT results_eq(
		'SELECT (ROW(250.5, ''ml'')::dirac.volume).unit::text',
		'SELECT ''ml''::text',
		'Volume unit should be accessible'
	);

	-- Test product quantity composite type structure
	RETURN NEXT results_eq(
		'SELECT (ROW(100, ''unit'')::dirac.product_quantity).quantity',
		'SELECT 100::DECIMAL(19,4)',
		'Product quantity value should be accessible'
	);

	RETURN NEXT results_eq(
		'SELECT (ROW(100, ''unit'')::dirac.product_quantity).unit::text',
		'SELECT ''unit''::text',
		'Product quantity unit should be accessible'
	);
END;
$$;


ALTER FUNCTION dirac.test_weight_volume_types() OWNER TO postgres;

--
-- Name: to_cm(dirac.length); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.to_cm(l dirac.length) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	IF l IS NULL OR l.value IS NULL THEN
		RETURN NULL;
	END IF;

	RETURN CASE l.unit
		WHEN 'mm' THEN l.value / 10
		WHEN 'cm' THEN l.value
		WHEN 'm' THEN l.value * 100
		WHEN 'km' THEN l.value * 100000
		WHEN 'in' THEN l.value * 2.54
		WHEN 'ft' THEN l.value * 30.48
		WHEN 'yd' THEN l.value * 91.44
		WHEN 'mi' THEN l.value * 160934
	END;
END;
$$;


ALTER FUNCTION dirac.to_cm(l dirac.length) OWNER TO postgres;

--
-- Name: to_gtin_14(character varying); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.to_gtin_14(barcode character varying) RETURNS character
    LANGUAGE plpython3u IMMUTABLE
    AS $$
	# use SD for import plpy
	# use SD for from biip.gtin import Gtin
	# use SD for import isbnlib

	imports = ['plpy','Gtin','isbnlib']
	if any(k not in SD for k in imports):
		import plpy
		SD['plpy'] = plpy
		from biip.gtin import Gtin
		SD['Gtin'] = Gtin
		import isbnlib
		SD['isbnlib'] = isbnlib

	def to_gtin_14(barcode) -> str:
		"""
		Companies like amazon use gtin_14 as their barocode primary key. We want to take:

		GTIN Family (Global Trade Item Numbers)
		â”œâ”€â”€ GTIN-14 (14 digits) â† TARGET FORMAT
		â”œâ”€â”€ GTIN-13 / EAN-13 (13 digits) â† Add ONE leading zero
		â”œâ”€â”€ GTIN-12 / UPC-A (12 digits) â† Add TWO leading zeros
		â””â”€â”€ GTIN-8 / EAN-8 (8 digits) â† COMPLEX: recalculate checksum + pad to 14

		UPC Family (Universal Product Codes)
		â”œâ”€â”€ UPC-A (12 digits) â†’ Same as GTIN-12 â† Add TWO leading zeros
		â””â”€â”€ UPC-E (8 digits, compressed) â†’ COMPLEX: Expand to UPC-A first, THEN convert NOT SUPPORTED

		EAN Family (European Article Numbers)
		â”œâ”€â”€ EAN-13 (13 digits) â†’ Same as GTIN-13 â† Add ONE leading zero
		â””â”€â”€ EAN-8 (8 digits) â†’ Same as GTIN-8 â† COMPLEX conversion

		ISBN Family (International Standard Book Numbers)
		â”œâ”€â”€ ISBN-13 (13 digits) â†’ Same as GTIN-13 â† Add ONE leading zero
		â””â”€â”€ ISBN-10 (10 digits) â†’ COMPLEX: Convert to ISBN-13 first, recalculate checksum USES isbnlib

		Raises error if barcode is invalid
		"""
		if len(barcode) == 10:
			barcode = SD['isbnlib'].to_isbn13(barcode)
		gtin = SD['Gtin'].parse(barcode)
		return gtin.as_gtin_14()

	try:
		return to_gtin_14(barcode)
	except Exception as e:
		SD['plpy'].error(f"Invalid barcode {barcode}: {e}")
$$;


ALTER FUNCTION dirac.to_gtin_14(barcode character varying) OWNER TO postgres;

--
-- Name: to_kg(dirac.weight); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.to_kg(w dirac.weight) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	IF w IS NULL OR w.value IS NULL THEN
		RETURN NULL;
	END IF;

	RETURN (CASE w.unit
		WHEN 'mg' THEN w.value / 1000000
		WHEN 'g' THEN w.value / 1000
		WHEN 'kg' THEN w.value
		WHEN 'oz' THEN w.value * 0.0283495
		WHEN 'lb' THEN w.value * 0.453592
		WHEN 't' THEN w.value * 1000
	END)::DECIMAL(19,4);
END;
$$;


ALTER FUNCTION dirac.to_kg(w dirac.weight) OWNER TO postgres;

--
-- Name: to_ml(dirac.volume); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.to_ml(v dirac.volume) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	IF v IS NULL OR v.value IS NULL THEN
		RETURN NULL;
	END IF;

	RETURN CASE v.unit
		WHEN 'ml' THEN v.value
		WHEN 'l' THEN v.value * 1000
		WHEN 'fl_oz' THEN v.value * 29.5735
		WHEN 'cup' THEN v.value * 236.588
		WHEN 'pt' THEN v.value * 473.176
		WHEN 'qt' THEN v.value * 946.353
		WHEN 'gal' THEN v.value * 3785.41
	END;
END;
$$;


ALTER FUNCTION dirac.to_ml(v dirac.volume) OWNER TO postgres;

--
-- Name: trigger_update_order_total(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.trigger_update_order_total() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF TG_OP = 'DELETE' THEN
		PERFORM dirac.update_order_total(OLD.order_id);
		RETURN OLD;
	ELSE
		PERFORM dirac.update_order_total(NEW.order_id);
		RETURN NEW;
	END IF;
END;
$$;


ALTER FUNCTION dirac.trigger_update_order_total() OWNER TO postgres;

--
-- Name: update_order_total(bigint); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.update_order_total(p_order_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_total_excl_vat DECIMAL(19,4);
	v_total_vat DECIMAL(19,4);
	v_total_incl_vat DECIMAL(19,4);
	v_currency CHAR(3);
BEGIN
	SELECT total_excl_vat, total_vat, total_incl_vat, currency
	INTO v_total_excl_vat, v_total_vat, v_total_incl_vat, v_currency
	FROM dirac.calculate_order_total(p_order_id);

	UPDATE dirac.order
	SET total_amount_excl_vat = v_total_excl_vat,
	    total_vat_amount = v_total_vat,
	    total_amount_incl_vat = v_total_incl_vat,
	    currency = v_currency
	WHERE id = p_order_id;
END;
$$;


ALTER FUNCTION dirac.update_order_total(p_order_id bigint) OWNER TO postgres;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
NEW.updated_at = CURRENT_TIMESTAMP;
RETURN NEW;
END;
$$;


ALTER FUNCTION dirac.update_updated_at_column() OWNER TO postgres;

--
-- Name: upsert_brand(character varying, public.vector, bigint); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.upsert_brand(p_name character varying, p_embedding public.vector, p_supplier_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_brand_id BIGINT;
    v_slug VARCHAR(255);
BEGIN
    IF p_name IS NULL OR trim(p_name) = '' THEN
        RAISE EXCEPTION 'Brand name cannot be null or empty';
    END IF;

    IF p_embedding IS NULL THEN
        RAISE EXCEPTION 'Brand embedding cannot be null';
    END IF;

    v_slug := dirac.generate_slug(trim(p_name));

    INSERT INTO dirac.brand (name, slug, embedding, owner_supplier_id)
    VALUES (trim(p_name), v_slug, p_embedding, p_supplier_id)
    ON CONFLICT (name) DO UPDATE
        SET embedding = EXCLUDED.embedding,
            owner_supplier_id = COALESCE(EXCLUDED.owner_supplier_id, dirac.brand.owner_supplier_id)
    RETURNING id INTO v_brand_id;

    RETURN v_brand_id;
END;
$$;


ALTER FUNCTION dirac.upsert_brand(p_name character varying, p_embedding public.vector, p_supplier_id bigint) OWNER TO postgres;

--
-- Name: upsert_customer(character varying, integer, public.vector, character varying, character varying, character varying, character varying, character, text); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.upsert_customer(p_name character varying, p_pipedrive_deal_id integer, p_embedding public.vector, p_email character varying DEFAULT NULL::character varying, p_business_registration_number character varying DEFAULT NULL::character varying, p_website_url character varying DEFAULT NULL::character varying, p_phone_number character varying DEFAULT NULL::character varying, p_country_code character DEFAULT NULL::bpchar, p_customer_notes text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_customer_id BIGINT;
BEGIN
    IF p_name IS NULL OR trim(p_name) = '' THEN
        RAISE EXCEPTION 'Customer name cannot be null or empty';
    END IF;

    IF p_embedding IS NULL THEN
        RAISE EXCEPTION 'Customer embedding cannot be null';
    END IF;

    INSERT INTO dirac.customer (
        name,
        pipedrive_deal_id,
        embedding,
        email,
        business_registration_number,
        website_url,
        phone_number,
        country_code,
        customer_notes
    )
    VALUES (
        trim(p_name),
        p_pipedrive_deal_id,
        p_embedding,
        p_email,
        p_business_registration_number,
        p_website_url,
        p_phone_number,
        p_country_code,
        p_customer_notes
    )
    ON CONFLICT (name) DO UPDATE
    SET
        embedding = EXCLUDED.embedding,
        pipedrive_deal_id = EXCLUDED.pipedrive_deal_id,
        email = COALESCE(EXCLUDED.email, dirac.customer.email),
        business_registration_number = COALESCE(EXCLUDED.business_registration_number, dirac.customer.business_registration_number),
        website_url = COALESCE(EXCLUDED.website_url, dirac.customer.website_url),
        phone_number = COALESCE(EXCLUDED.phone_number, dirac.customer.phone_number),
        country_code = COALESCE(EXCLUDED.country_code, dirac.customer.country_code),
        customer_notes = COALESCE(EXCLUDED.customer_notes, dirac.customer.customer_notes)
    RETURNING id INTO v_customer_id;

    RETURN v_customer_id;
END;
$$;


ALTER FUNCTION dirac.upsert_customer(p_name character varying, p_pipedrive_deal_id integer, p_embedding public.vector, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text) OWNER TO postgres;

--
-- Name: validate_discounts(dirac.discount_range[]); Type: FUNCTION; Schema: dirac; Owner: postgres
--

CREATE FUNCTION dirac.validate_discounts(discounts dirac.discount_range[]) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		v_coverage text;
	BEGIN
		-- Check empty
		IF discounts IS NULL OR array_length(discounts, 1) IS NULL THEN
		  RETURN FALSE;
		END IF;

		-- Check each has exactly one discount type
		IF EXISTS (
		  SELECT 1 FROM unnest(discounts) AS d
		  WHERE NOT (
		      (d.discount_absolute IS NOT NULL AND d.discount_fraction IS NULL) OR
		      (d.discount_absolute IS NULL AND d.discount_fraction IS NOT NULL)
		  )
		) THEN
		  RETURN FALSE;
		END IF;

		-- Check no overlaps (without GiST)
		IF EXISTS (
		  SELECT 1
		  FROM unnest(discounts) AS d1
		  JOIN unnest(discounts) AS d2
		  ON d1.qty_range && d2.qty_range  -- Range overlap operator
		  AND d1 < d2  -- Avoid duplicate pairs
		) THEN
		  RETURN FALSE;
		END IF;

		-- Check coverage is [0,infinity)
		SELECT (range_agg(d.qty_range))::text INTO v_coverage
		FROM unnest(discounts) AS d;

		RETURN v_coverage = '{[0,)}';
	END;
$$;


ALTER FUNCTION dirac.validate_discounts(discounts dirac.discount_range[]) OWNER TO postgres;

--
-- Name: get_organizations_for_persona_search(text); Type: FUNCTION; Schema: enrichment; Owner: postgres
--

CREATE FUNCTION enrichment.get_organizations_for_persona_search(persona_name text) RETURNS TABLE(apollo_org_id text, org_id bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_persona_id BIGINT;
BEGIN
    SELECT id INTO v_persona_id FROM enrichment.persona WHERE name = persona_name;
    IF v_persona_id IS NULL THEN
        RAISE EXCEPTION 'Persona % not found', persona_name;
    END IF;

    RETURN QUERY
    SELECT o.apollo_org_id, o.id
    FROM enrichment.organization o
    WHERE NOT EXISTS (
        SELECT 1 FROM enrichment.organization_persona_search ops
        WHERE ops.organization_id = o.id AND ops.persona_id = v_persona_id
    );
END;
$$;


ALTER FUNCTION enrichment.get_organizations_for_persona_search(persona_name text) OWNER TO postgres;

--
-- Name: get_persona_filters(text); Type: FUNCTION; Schema: enrichment; Owner: postgres
--

CREATE FUNCTION enrichment.get_persona_filters(persona_name text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_payload JSONB;
BEGIN
    SELECT payload INTO v_payload FROM enrichment.persona WHERE name = persona_name;
    IF v_payload IS NULL THEN
        RAISE EXCEPTION 'Persona % not found', persona_name;
    END IF;
    RETURN v_payload;
END;
$$;


ALTER FUNCTION enrichment.get_persona_filters(persona_name text) OWNER TO postgres;

--
-- Name: get_unenriched_domains(text[]); Type: FUNCTION; Schema: enrichment; Owner: postgres
--

CREATE FUNCTION enrichment.get_unenriched_domains(domains text[]) RETURNS TABLE(domain text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT unnest(domains)
    EXCEPT
    SELECT o.domain FROM enrichment.organization o WHERE o.domain = ANY(domains);
END;
$$;


ALTER FUNCTION enrichment.get_unenriched_domains(domains text[]) OWNER TO postgres;

--
-- Name: mark_persona_searched(bigint[], text); Type: FUNCTION; Schema: enrichment; Owner: postgres
--

CREATE FUNCTION enrichment.mark_persona_searched(org_ids bigint[], persona_name text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_persona_id BIGINT;
    v_org_id BIGINT;
BEGIN
    SELECT id INTO v_persona_id FROM enrichment.persona WHERE name = persona_name;
    IF v_persona_id IS NULL THEN
        RAISE EXCEPTION 'Persona % not found', persona_name;
    END IF;

    FOREACH v_org_id IN ARRAY org_ids
    LOOP
        INSERT INTO enrichment.organization_persona_search (organization_id, persona_id)
        VALUES (v_org_id, v_persona_id)
        ON CONFLICT (organization_id, persona_id) DO NOTHING;
    END LOOP;
END;
$$;


ALTER FUNCTION enrichment.mark_persona_searched(org_ids bigint[], persona_name text) OWNER TO postgres;

--
-- Name: upsert_organizations(jsonb); Type: FUNCTION; Schema: enrichment; Owner: postgres
--

CREATE FUNCTION enrichment.upsert_organizations(orgs jsonb) RETURNS TABLE(_apollo_org_id text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    org JSONB;
BEGIN
    FOR org IN SELECT * FROM jsonb_array_elements(orgs)
    LOOP
        INSERT INTO enrichment.organization (apollo_org_id, domain, linkedin_slug, payload)
        VALUES (
            org->>'id',
            org->>'primary_domain',
            dirac.extract_linkedin_slug(org->>'linkedin_url'),
            org
        )
        ON CONFLICT (apollo_org_id) DO UPDATE SET
            domain = COALESCE(EXCLUDED.domain, enrichment.organization.domain),
            linkedin_slug = COALESCE(EXCLUDED.linkedin_slug, enrichment.organization.linkedin_slug),
            payload = EXCLUDED.payload;

        RETURN QUERY SELECT org->>'id';
    END LOOP;
END;
$$;


ALTER FUNCTION enrichment.upsert_organizations(orgs jsonb) OWNER TO postgres;

--
-- Name: upsert_people(jsonb); Type: FUNCTION; Schema: enrichment; Owner: postgres
--

CREATE FUNCTION enrichment.upsert_people(people jsonb) RETURNS TABLE(_apollo_person_id text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    person JSONB;
    email_val TEXT;
BEGIN
    FOR person IN SELECT * FROM jsonb_array_elements(people)
    LOOP
        email_val := person->>'email';
        IF email_val IS NOT NULL AND (email_val LIKE '%not_unlocked%' OR email_val LIKE '%@domain.com') THEN
            email_val := NULL;
        END IF;

        INSERT INTO enrichment.person (apollo_person_id, email, linkedin_slug, payload)
        VALUES (
            person->>'id',
            email_val,
            dirac.extract_linkedin_slug(person->>'linkedin_url'),
            person
        )
        ON CONFLICT (apollo_person_id) DO UPDATE SET
            email = COALESCE(EXCLUDED.email, enrichment.person.email),
            linkedin_slug = COALESCE(EXCLUDED.linkedin_slug, enrichment.person.linkedin_slug),
            payload = EXCLUDED.payload;

        RETURN QUERY SELECT person->>'id';
    END LOOP;
END;
$$;


ALTER FUNCTION enrichment.upsert_people(people jsonb) OWNER TO postgres;

--
-- Name: parse_relative_timestamp(text); Type: FUNCTION; Schema: linkedin; Owner: postgres
--

CREATE FUNCTION linkedin.parse_relative_timestamp(p_relative_time text) RETURNS timestamp with time zone
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    v_number INTEGER;
    v_unit TEXT;
    v_interval INTERVAL;
BEGIN
    -- Return NULL if input is NULL or empty
    IF p_relative_time IS NULL OR p_relative_time = '' THEN
        RETURN NULL;
    END IF;

    -- Handle special cases
    IF p_relative_time = 'now' THEN
        RETURN NOW();
    END IF;

    -- Extract number and unit from patterns like "3d", "21h", "2w"
    -- Also handle "3 days ago", "2 hours ago" format
    IF p_relative_time ~ '^\d+[hdwmy]$' THEN
        -- Simple format: "3d"
        v_number := SUBSTRING(p_relative_time FROM '^\d+')::INTEGER;
        v_unit := SUBSTRING(p_relative_time FROM '\d+(.*)$');
    ELSIF p_relative_time ~ '^\d+\s+(hour|day|week|month|year)s?\s+ago$' THEN
        -- Verbose format: "3 days ago"
        v_number := SUBSTRING(p_relative_time FROM '^\d+')::INTEGER;
        v_unit := SUBSTRING(p_relative_time FROM '\d+\s+([a-z]+)');
        -- Convert to single letter
        v_unit := CASE v_unit
            WHEN 'hour' THEN 'h'
            WHEN 'day' THEN 'd'
            WHEN 'week' THEN 'w'
            WHEN 'month' THEN 'mo'
            WHEN 'year' THEN 'y'
            ELSE v_unit
        END;
    ELSE
        -- If we can't parse it, return NULL
        RETURN NULL;
    END IF;

    -- Convert to interval based on unit
    v_interval := CASE v_unit
        WHEN 'h' THEN v_number * INTERVAL '1 hour'
        WHEN 'd' THEN v_number * INTERVAL '1 day'
        WHEN 'w' THEN v_number * INTERVAL '1 week'
        WHEN 'mo' THEN v_number * INTERVAL '1 month'
        WHEN 'm' THEN v_number * INTERVAL '1 month'  -- Sometimes "m" for month
        WHEN 'y' THEN v_number * INTERVAL '1 year'
        ELSE NULL
    END;

    -- Return current time minus the interval
    IF v_interval IS NOT NULL THEN
        RETURN NOW() - v_interval;
    ELSE
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        -- If any error occurs during parsing, return NULL
        RETURN NULL;
END;
$_$;


ALTER FUNCTION linkedin.parse_relative_timestamp(p_relative_time text) OWNER TO postgres;

--
-- Name: upsert_search_extraction(jsonb); Type: FUNCTION; Schema: linkedin; Owner: postgres
--

CREATE FUNCTION linkedin.upsert_search_extraction(p_extraction_data jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    v_search_result_id BIGINT;
    v_search_data JSONB;
    v_people JSONB;
    v_companies JSONB;
    v_groups JSONB;
    v_posts JSONB;
    v_person JSONB;
    v_company JSONB;
    v_group JSONB;
    v_post JSONB;
    v_person_id BIGINT;
    v_company_id BIGINT;
    v_group_id BIGINT;
    v_post_id BIGINT;
    v_author_id BIGINT;
    v_is_company BOOLEAN;
    v_result JSONB;
BEGIN
    -- Extract search metadata
    v_search_data := p_extraction_data->'search_metadata';

    -- Insert search result record
    INSERT INTO linkedin.search_result (
        search_query,
        search_type,
        current_page,
        total_pages,
        total_results,
        keywords,
        author_company_ids,
        author_industry_ids,
        author_job_title,
        content_type,
        date_posted,
        from_member_ids,
        mentions_member_ids,
        mentions_organization_ids,
        posted_by,
        sort_by,
        search_url,
        extracted_at
    ) VALUES (
        v_search_data->>'search_query',
        v_search_data->>'search_type',
        (v_search_data->>'current_page')::INTEGER,
        (v_search_data->>'total_pages')::INTEGER,
        (v_search_data->>'total_results')::INTEGER,
        v_search_data->>'keywords',
        CASE WHEN v_search_data->'author_company_ids' IS NOT NULL
            THEN ARRAY(SELECT jsonb_array_elements_text(v_search_data->'author_company_ids'))::BIGINT[]
            ELSE NULL END,
        CASE WHEN v_search_data->'author_industry_ids' IS NOT NULL
            THEN ARRAY(SELECT jsonb_array_elements_text(v_search_data->'author_industry_ids'))::INTEGER[]
            ELSE NULL END,
        v_search_data->>'author_job_title',
        v_search_data->>'content_type',
        v_search_data->>'date_posted',
        CASE WHEN v_search_data->'from_member_ids' IS NOT NULL
            THEN ARRAY(SELECT jsonb_array_elements_text(v_search_data->'from_member_ids'))
            ELSE NULL END,
        CASE WHEN v_search_data->'mentions_member_ids' IS NOT NULL
            THEN ARRAY(SELECT jsonb_array_elements_text(v_search_data->'mentions_member_ids'))
            ELSE NULL END,
        CASE WHEN v_search_data->'mentions_organization_ids' IS NOT NULL
            THEN ARRAY(SELECT jsonb_array_elements_text(v_search_data->'mentions_organization_ids'))::BIGINT[]
            ELSE NULL END,
        CASE WHEN v_search_data->'posted_by' IS NOT NULL
            THEN ARRAY(SELECT jsonb_array_elements_text(v_search_data->'posted_by'))
            ELSE NULL END,
        v_search_data->>'sort_by',
        v_search_data->>'search_url',
        NOW()
    ) RETURNING id INTO v_search_result_id;

    -- Process people
    v_people := p_extraction_data->'people';
    IF v_people IS NOT NULL AND jsonb_array_length(v_people) > 0 THEN
        FOR v_person IN SELECT * FROM jsonb_array_elements(v_people)
        LOOP
            -- Upsert person
            IF v_person->>'member_id' IS NOT NULL THEN
                INSERT INTO linkedin.person (slug, member_id, name, title, company, location, followers, is_premium)
                VALUES (
                    v_person->>'slug',
                    v_person->>'member_id',
                    v_person->>'name',
                    v_person->>'title',
                    v_person->>'company',
                    v_person->>'location',
                    v_person->>'followers',
                    COALESCE((v_person->>'is_premium')::BOOLEAN, FALSE)
                )
                ON CONFLICT (member_id) DO UPDATE SET
                    slug = COALESCE(EXCLUDED.slug, person.slug),
                    name = EXCLUDED.name,
                    title = EXCLUDED.title,
                    company = EXCLUDED.company,
                    location = EXCLUDED.location,
                    followers = EXCLUDED.followers,
                    is_premium = EXCLUDED.is_premium
                RETURNING id INTO v_person_id;
            ELSIF v_person->>'slug' IS NOT NULL THEN
                INSERT INTO linkedin.person (slug, member_id, name, title, company, location, followers, is_premium)
                VALUES (
                    v_person->>'slug',
                    v_person->>'member_id',
                    v_person->>'name',
                    v_person->>'title',
                    v_person->>'company',
                    v_person->>'location',
                    v_person->>'followers',
                    COALESCE((v_person->>'is_premium')::BOOLEAN, FALSE)
                )
                ON CONFLICT (slug) DO UPDATE SET
                    member_id = COALESCE(EXCLUDED.member_id, person.member_id),
                    name = EXCLUDED.name,
                    title = EXCLUDED.title,
                    company = EXCLUDED.company,
                    location = EXCLUDED.location,
                    followers = EXCLUDED.followers,
                    is_premium = EXCLUDED.is_premium
                RETURNING id INTO v_person_id;
            ELSE
                -- No unique identifier, just insert
                INSERT INTO linkedin.person (slug, member_id, name, title, company, location, followers, is_premium)
                VALUES (
                    v_person->>'slug',
                    v_person->>'member_id',
                    v_person->>'name',
                    v_person->>'title',
                    v_person->>'company',
                    v_person->>'location',
                    v_person->>'followers',
                    COALESCE((v_person->>'is_premium')::BOOLEAN, FALSE)
                ) RETURNING id INTO v_person_id;
            END IF;
        END LOOP;
    END IF;

    -- Process companies
    v_companies := p_extraction_data->'companies';
    IF v_companies IS NOT NULL AND jsonb_array_length(v_companies) > 0 THEN
        FOR v_company IN SELECT * FROM jsonb_array_elements(v_companies)
        LOOP
            -- Upsert company
            IF v_company->>'company_id' IS NOT NULL THEN
                INSERT INTO linkedin.company (slug, company_id, name, industry, location, followers, description)
                VALUES (
                    v_company->>'slug',
                    (v_company->>'company_id')::BIGINT,
                    v_company->>'name',
                    v_company->>'industry',
                    v_company->>'location',
                    v_company->>'followers',
                    v_company->>'description'
                )
                ON CONFLICT (company_id) DO UPDATE SET
                    slug = COALESCE(EXCLUDED.slug, company.slug),
                    name = EXCLUDED.name,
                    industry = EXCLUDED.industry,
                    location = EXCLUDED.location,
                    followers = EXCLUDED.followers,
                    description = EXCLUDED.description
                RETURNING id INTO v_company_id;
            ELSIF v_company->>'slug' IS NOT NULL THEN
                INSERT INTO linkedin.company (slug, company_id, name, industry, location, followers, description)
                VALUES (
                    v_company->>'slug',
                    (v_company->>'company_id')::BIGINT,
                    v_company->>'name',
                    v_company->>'industry',
                    v_company->>'location',
                    v_company->>'followers',
                    v_company->>'description'
                )
                ON CONFLICT (slug) DO UPDATE SET
                    company_id = COALESCE(EXCLUDED.company_id, company.company_id),
                    name = EXCLUDED.name,
                    industry = EXCLUDED.industry,
                    location = EXCLUDED.location,
                    followers = EXCLUDED.followers,
                    description = EXCLUDED.description
                RETURNING id INTO v_company_id;
            ELSE
                -- No unique identifier, just insert
                INSERT INTO linkedin.company (slug, company_id, name, industry, location, followers, description)
                VALUES (
                    v_company->>'slug',
                    (v_company->>'company_id')::BIGINT,
                    v_company->>'name',
                    v_company->>'industry',
                    v_company->>'location',
                    v_company->>'followers',
                    v_company->>'description'
                ) RETURNING id INTO v_company_id;
            END IF;
        END LOOP;
    END IF;

    -- Process groups
    v_groups := p_extraction_data->'groups';
    IF v_groups IS NOT NULL AND jsonb_array_length(v_groups) > 0 THEN
        FOR v_group IN SELECT * FROM jsonb_array_elements(v_groups)
        LOOP
            IF v_group->>'group_id' IS NOT NULL THEN
                INSERT INTO linkedin.group (id, name, description, member_count)
                VALUES (
                    (v_group->>'group_id')::BIGINT,
                    v_group->>'name',
                    v_group->>'description',
                    v_group->>'member_count'
                )
                ON CONFLICT (id) DO UPDATE SET
                    name = EXCLUDED.name,
                    description = EXCLUDED.description,
                    member_count = EXCLUDED.member_count
                RETURNING id INTO v_group_id;
            END IF;
        END LOOP;
    END IF;

    -- Process posts
    v_posts := p_extraction_data->'posts';
    IF v_posts IS NOT NULL AND jsonb_array_length(v_posts) > 0 THEN
        FOR v_post IN SELECT * FROM jsonb_array_elements(v_posts)
        LOOP
            -- First handle the author
            v_is_company := (v_post->'author'->>'profile_type' = 'company');

            IF v_is_company THEN
                -- Upsert company author
                IF v_post->'author'->>'company_id' IS NOT NULL THEN
                    INSERT INTO linkedin.company (slug, company_id, name, industry, location, followers, description)
                    VALUES (
                        v_post->'author'->>'slug',
                        (v_post->'author'->>'company_id')::BIGINT,
                        v_post->'author'->>'name',
                        v_post->'author'->>'industry',
                        v_post->'author'->>'location',
                        v_post->'author'->>'followers',
                        v_post->'author'->>'description'
                    )
                    ON CONFLICT (company_id) DO UPDATE SET
                        slug = COALESCE(EXCLUDED.slug, company.slug),
                        name = EXCLUDED.name
                    RETURNING id INTO v_author_id;
                ELSIF v_post->'author'->>'slug' IS NOT NULL THEN
                    INSERT INTO linkedin.company (slug, company_id, name, industry, location, followers, description)
                    VALUES (
                        v_post->'author'->>'slug',
                        NULL,
                        v_post->'author'->>'name',
                        v_post->'author'->>'industry',
                        v_post->'author'->>'location',
                        v_post->'author'->>'followers',
                        v_post->'author'->>'description'
                    )
                    ON CONFLICT (slug) DO UPDATE SET
                        name = EXCLUDED.name
                    RETURNING id INTO v_author_id;
                ELSE
                    INSERT INTO linkedin.company (slug, company_id, name, industry, location, followers, description)
                    VALUES (
                        NULL,
                        NULL,
                        v_post->'author'->>'name',
                        v_post->'author'->>'industry',
                        v_post->'author'->>'location',
                        v_post->'author'->>'followers',
                        v_post->'author'->>'description'
                    ) RETURNING id INTO v_author_id;
                END IF;
            ELSE
                -- Upsert person author
                IF v_post->'author'->>'member_id' IS NOT NULL THEN
                    INSERT INTO linkedin.person (slug, member_id, name, title, company, location, followers, is_premium)
                    VALUES (
                        v_post->'author'->>'slug',
                        v_post->'author'->>'member_id',
                        v_post->'author'->>'name',
                        v_post->'author'->>'title',
                        v_post->'author'->>'company',
                        v_post->'author'->>'location',
                        v_post->'author'->>'followers',
                        COALESCE((v_post->'author'->>'is_premium')::BOOLEAN, FALSE)
                    )
                    ON CONFLICT (member_id) DO UPDATE SET
                        slug = COALESCE(EXCLUDED.slug, person.slug),
                        name = EXCLUDED.name
                    RETURNING id INTO v_author_id;
                ELSIF v_post->'author'->>'slug' IS NOT NULL THEN
                    INSERT INTO linkedin.person (slug, member_id, name, title, company, location, followers, is_premium)
                    VALUES (
                        v_post->'author'->>'slug',
                        NULL,
                        v_post->'author'->>'name',
                        v_post->'author'->>'title',
                        v_post->'author'->>'company',
                        v_post->'author'->>'location',
                        v_post->'author'->>'followers',
                        COALESCE((v_post->'author'->>'is_premium')::BOOLEAN, FALSE)
                    )
                    ON CONFLICT (slug) DO UPDATE SET
                        name = EXCLUDED.name
                    RETURNING id INTO v_author_id;
                ELSE
                    INSERT INTO linkedin.person (slug, member_id, name, title, company, location, followers, is_premium)
                    VALUES (
                        NULL,
                        NULL,
                        v_post->'author'->>'name',
                        v_post->'author'->>'title',
                        v_post->'author'->>'company',
                        v_post->'author'->>'location',
                        v_post->'author'->>'followers',
                        COALESCE((v_post->'author'->>'is_premium')::BOOLEAN, FALSE)
                    ) RETURNING id INTO v_author_id;
                END IF;
            END IF;

            -- Insert or update the post (with deduplication on urn)
            INSERT INTO linkedin.post (
                company_id,
                person_id,
                search_result_id,
                content,
                hashtags,
                mentions,
                links,
                timestamp,
                posted_at,
                url,
                urn
            ) VALUES (
                CASE WHEN v_is_company THEN v_author_id ELSE NULL END,
                CASE WHEN NOT v_is_company THEN v_author_id ELSE NULL END,
                v_search_result_id,
                v_post->>'content',
                CASE WHEN v_post->'hashtags' IS NOT NULL
                    THEN ARRAY(SELECT jsonb_array_elements_text(v_post->'hashtags'))
                    ELSE NULL END,
                CASE WHEN v_post->'mentions' IS NOT NULL
                    THEN ARRAY(SELECT jsonb_array_elements_text(v_post->'mentions'))
                    ELSE NULL END,
                CASE WHEN v_post->'links' IS NOT NULL
                    THEN ARRAY(SELECT jsonb_array_elements_text(v_post->'links'))
                    ELSE NULL END,
                v_post->>'timestamp',
                -- Convert relative timestamp to actual timestamp, fallback to NOW() if parsing fails
                COALESCE(linkedin.parse_relative_timestamp(v_post->>'timestamp'), NOW()),
                v_post->>'post_url',
                -- Extract URN from post_url if not provided directly
                CASE
                    WHEN v_post->>'post_urn' IS NOT NULL THEN v_post->>'post_urn'
                    WHEN v_post->>'post_url' IS NOT NULL THEN
                        regexp_replace(v_post->>'post_url', '^.*/feed/update/(urn:li:[^/]+).*$', '\1')
                    ELSE NULL
                END
            )
            ON CONFLICT (urn) DO UPDATE SET
                -- Update fields that might have changed
                content = EXCLUDED.content,
                hashtags = EXCLUDED.hashtags,
                mentions = EXCLUDED.mentions,
                links = EXCLUDED.links,
                timestamp = EXCLUDED.timestamp
            RETURNING id INTO v_post_id;
        END LOOP;
    END IF;

    -- Return summary
    v_result := jsonb_build_object(
        'search_result_id', v_search_result_id,
        'people_processed', COALESCE(jsonb_array_length(v_people), 0),
        'companies_processed', COALESCE(jsonb_array_length(v_companies), 0),
        'groups_processed', COALESCE(jsonb_array_length(v_groups), 0),
        'posts_processed', COALESCE(jsonb_array_length(v_posts), 0)
    );

    RETURN v_result;
END;
$_$;


ALTER FUNCTION linkedin.upsert_search_extraction(p_extraction_data jsonb) OWNER TO postgres;

--
-- Name: complete_call(integer, character varying, text, integer); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.complete_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer DEFAULT NULL::integer) RETURNS TABLE(success boolean, message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_locked_by VARCHAR(100);
BEGIN
    SELECT locked_by INTO v_locked_by
    FROM outbound.calls
    WHERE id = p_call_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Call not found';
        RETURN;
    END IF;

    IF v_locked_by != p_user_id THEN
        RETURN QUERY SELECT FALSE, 'You do not have permission to complete this call';
        RETURN;
    END IF;

    UPDATE outbound.calls
    SET call_status = 'completed',
        call_completed_at = CURRENT_TIMESTAMP,
        call_notes = p_notes,
        pipedrive_activity_id = p_activity_id,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_call_id;

    RETURN QUERY SELECT TRUE, 'Call completed successfully';
END;
$$;


ALTER FUNCTION outbound.complete_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer) OWNER TO postgres;

--
-- Name: get_available_calls(); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.get_available_calls() RETURNS TABLE(id integer, pipedrive_person_id integer, pipedrive_org_id integer, person_name character varying, organization_name character varying, phone_number character varying, timezone character varying, timezone_offset integer, call_status character varying, locked_by character varying, locked_by_name character varying, call_notes text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id,
        c.pipedrive_person_id,
        c.pipedrive_org_id,
        c.person_name,
        c.organization_name,
        c.phone_number,
        c.timezone,
        c.timezone_offset,
        c.call_status,
        c.locked_by,
        u.name AS locked_by_name,
        c.call_notes
    FROM outbound.calls c
    LEFT JOIN outbound.users u ON c.locked_by = u.google_id
    WHERE c.call_status IN ('pending', 'in_progress')
    ORDER BY c.timezone_offset DESC, c.created_at ASC;
END;
$$;


ALTER FUNCTION outbound.get_available_calls() OWNER TO postgres;

--
-- Name: get_user_by_google_id(character varying); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.get_user_by_google_id(p_google_id character varying) RETURNS TABLE(id integer, google_id character varying, email character varying, name character varying, picture text, goto_token jsonb, goto_line text, goto_line_display character varying, created_at timestamp without time zone, last_login timestamp without time zone, is_active boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.id,
        u.google_id,
        u.email,
        u.name,
        u.picture,
        u.goto_token,
        u.goto_line,
        u.goto_line_display,
        u.created_at,
        u.last_login,
        u.is_active
    FROM outbound.users u
    WHERE u.google_id = p_google_id
    AND u.is_active = true;
END;
$$;


ALTER FUNCTION outbound.get_user_by_google_id(p_google_id character varying) OWNER TO postgres;

--
-- Name: get_user_goto_info(character varying); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.get_user_goto_info(p_google_id character varying) RETURNS TABLE(goto_token jsonb, goto_line text, goto_line_display character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT u.goto_token, u.goto_line, u.goto_line_display
    FROM outbound.users u
    WHERE u.google_id = p_google_id
    AND u.is_active = true;
END;
$$;


ALTER FUNCTION outbound.get_user_goto_info(p_google_id character varying) OWNER TO postgres;

--
-- Name: get_user_goto_token(character varying); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.get_user_goto_token(p_google_id character varying) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_token JSONB;
BEGIN
    SELECT u.goto_token INTO v_token
    FROM outbound.users u
    WHERE u.google_id = p_google_id
    AND u.is_active = true;

    RETURN v_token;
END;
$$;


ALTER FUNCTION outbound.get_user_goto_token(p_google_id character varying) OWNER TO postgres;

--
-- Name: lock_call_for_initiation(integer, character varying); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.lock_call_for_initiation(p_call_id integer, p_user_id character varying) RETURNS TABLE(success boolean, message text, call_data json)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_current_status VARCHAR(20);
    v_locked_by VARCHAR(100);
    v_call_record RECORD;
BEGIN
    -- Check current status and lock
    SELECT call_status, locked_by INTO v_current_status, v_locked_by
    FROM outbound.calls
    WHERE id = p_call_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Call not found', NULL::JSON;
        RETURN;
    END IF;

    IF v_current_status != 'pending' THEN
        RETURN QUERY SELECT FALSE, 'Call is already ' || v_current_status, NULL::JSON;
        RETURN;
    END IF;

    IF v_locked_by IS NOT NULL AND v_locked_by != p_user_id THEN
        RETURN QUERY SELECT FALSE, 'Call is locked by another user', NULL::JSON;
        RETURN;
    END IF;

    -- Lock the call but keep status as pending
    UPDATE outbound.calls
    SET locked_by = p_user_id,
        locked_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_call_id
    RETURNING * INTO v_call_record;

    RETURN QUERY SELECT
        TRUE,
        'Call locked successfully',
        row_to_json(v_call_record)::JSON;
END;
$$;


ALTER FUNCTION outbound.lock_call_for_initiation(p_call_id integer, p_user_id character varying) OWNER TO postgres;

--
-- Name: lock_call_for_user(integer, character varying); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.lock_call_for_user(p_call_id integer, p_user_id character varying) RETURNS TABLE(success boolean, message text, call_data json)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_current_status VARCHAR(20);
    v_locked_by VARCHAR(100);
    v_call_record RECORD;
BEGIN
    -- Check current status and lock
    SELECT call_status, locked_by INTO v_current_status, v_locked_by
    FROM outbound.calls
    WHERE id = p_call_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Call not found', NULL::JSON;
        RETURN;
    END IF;

    IF v_current_status != 'pending' THEN
        RETURN QUERY SELECT FALSE, 'Call is already ' || v_current_status, NULL::JSON;
        RETURN;
    END IF;

    IF v_locked_by IS NOT NULL AND v_locked_by != p_user_id THEN
        RETURN QUERY SELECT FALSE, 'Call is locked by another user', NULL::JSON;
        RETURN;
    END IF;

    -- Lock the call
    UPDATE outbound.calls
    SET call_status = 'in_progress',
        locked_by = p_user_id,
        locked_at = CURRENT_TIMESTAMP,
        call_started_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_call_id
    RETURNING * INTO v_call_record;

    RETURN QUERY SELECT
        TRUE,
        'Call locked successfully',
        row_to_json(v_call_record)::JSON;
END;
$$;


ALTER FUNCTION outbound.lock_call_for_user(p_call_id integer, p_user_id character varying) OWNER TO postgres;

--
-- Name: mark_call_in_progress(integer, character varying); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.mark_call_in_progress(p_call_id integer, p_user_id character varying) RETURNS TABLE(success boolean, message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_locked_by VARCHAR(100);
    v_current_status VARCHAR(20);
BEGIN
    SELECT locked_by, call_status INTO v_locked_by, v_current_status
    FROM outbound.calls
    WHERE id = p_call_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Call not found';
        RETURN;
    END IF;

    IF v_locked_by != p_user_id THEN
        RETURN QUERY SELECT FALSE, 'You do not have permission to modify this call';
        RETURN;
    END IF;

    IF v_current_status != 'pending' THEN
        RETURN QUERY SELECT FALSE, 'Call is not in pending status';
        RETURN;
    END IF;

    UPDATE outbound.calls
    SET call_status = 'in_progress',
        call_started_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_call_id;

    RETURN QUERY SELECT TRUE, 'Call marked as in progress';
END;
$$;


ALTER FUNCTION outbound.mark_call_in_progress(p_call_id integer, p_user_id character varying) OWNER TO postgres;

--
-- Name: mark_missing_persons_as_gone(integer[]); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.mark_missing_persons_as_gone(p_pipedrive_person_ids integer[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_updated_count INTEGER;
BEGIN
    -- Update all calls that are NOT in the provided list and are NOT already opted_out
    -- Set their status to 'gone'
    UPDATE outbound.calls
    SET call_status = 'gone',
        updated_at = NOW()
    WHERE pipedrive_person_id NOT IN (SELECT UNNEST(p_pipedrive_person_ids))
      AND call_status != 'opted_out'
      AND call_status != 'gone';

    GET DIAGNOSTICS v_updated_count = ROW_COUNT;

    RETURN v_updated_count;
END;
$$;


ALTER FUNCTION outbound.mark_missing_persons_as_gone(p_pipedrive_person_ids integer[]) OWNER TO postgres;

--
-- Name: opt_out_call(integer, character varying, text, integer); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.opt_out_call(p_call_id integer, p_user_id character varying, p_notes text DEFAULT NULL::text, p_activity_id integer DEFAULT NULL::integer) RETURNS TABLE(success boolean, message text, pipedrive_person_id integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_current_status VARCHAR(20);
    v_current_locked_by VARCHAR(100);
    v_pipedrive_person_id INTEGER;
BEGIN
    -- Get current call status and lock info
    SELECT call_status, locked_by, c.pipedrive_person_id
    INTO v_current_status, v_current_locked_by, v_pipedrive_person_id
    FROM outbound.calls c
    WHERE id = p_call_id;

    -- Check if call exists
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Call not found', NULL::INTEGER;
        RETURN;
    END IF;

    -- Check if call is in progress and locked by this user
    IF v_current_status != 'in_progress' THEN
        RETURN QUERY SELECT FALSE, 'Call is not in progress', v_pipedrive_person_id;
        RETURN;
    END IF;

    IF v_current_locked_by != p_user_id THEN
        RETURN QUERY SELECT FALSE, 'Call is not locked by you', v_pipedrive_person_id;
        RETURN;
    END IF;

    -- Update call to opted_out status
    UPDATE outbound.calls
    SET call_status = 'opted_out',
        call_notes = p_notes,
        call_completed_at = NOW(),
        pipedrive_activity_id = p_activity_id
    WHERE id = p_call_id;

    RETURN QUERY SELECT TRUE, 'Call marked as opted out', v_pipedrive_person_id;
END;
$$;


ALTER FUNCTION outbound.opt_out_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer) OWNER TO postgres;

--
-- Name: unlock_stale_calls(); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.unlock_stale_calls() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    rows_updated INTEGER;
BEGIN
    UPDATE outbound.calls
    SET call_status = 'pending',
        locked_by = NULL,
        locked_at = NULL,
        call_started_at = NULL
    WHERE call_status = 'in_progress'
    AND locked_at < CURRENT_TIMESTAMP - INTERVAL '30 minutes';

    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RETURN rows_updated;
END;
$$;


ALTER FUNCTION outbound.unlock_stale_calls() OWNER TO postgres;

--
-- Name: update_user_goto_line(character varying, text, character varying); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.update_user_goto_line(p_google_id character varying, p_goto_line text, p_goto_line_display character varying DEFAULT NULL::character varying) RETURNS TABLE(id integer, google_id character varying, email character varying, name character varying, picture text, goto_token jsonb, goto_line text, goto_line_display character varying, created_at timestamp without time zone, last_login timestamp without time zone, is_active boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    UPDATE outbound.users u
    SET goto_line = p_goto_line,
        goto_line_display = p_goto_line_display
    WHERE u.google_id = p_google_id
    RETURNING
        u.id,
        u.google_id,
        u.email,
        u.name,
        u.picture,
        u.goto_token,
        u.goto_line,
        u.goto_line_display,
        u.created_at,
        u.last_login,
        u.is_active;
END;
$$;


ALTER FUNCTION outbound.update_user_goto_line(p_google_id character varying, p_goto_line text, p_goto_line_display character varying) OWNER TO postgres;

--
-- Name: update_user_goto_token(character varying, jsonb); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.update_user_goto_token(p_google_id character varying, p_goto_token jsonb) RETURNS TABLE(id integer, google_id character varying, email character varying, name character varying, picture text, goto_token jsonb, goto_line text, goto_line_display character varying, created_at timestamp without time zone, last_login timestamp without time zone, is_active boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    UPDATE outbound.users u
    SET goto_token = p_goto_token
    WHERE u.google_id = p_google_id
    RETURNING
        u.id,
        u.google_id,
        u.email,
        u.name,
        u.picture,
        u.goto_token,
        u.goto_line,
        u.goto_line_display,
        u.created_at,
        u.last_login,
        u.is_active;
END;
$$;


ALTER FUNCTION outbound.update_user_goto_token(p_google_id character varying, p_goto_token jsonb) OWNER TO postgres;

--
-- Name: upsert_pipedrive_person(integer, integer, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.upsert_pipedrive_person(p_pipedrive_person_id integer, p_pipedrive_org_id integer, p_person_name character varying, p_organization_name character varying, p_phone_number character varying, p_timezone character varying, p_timezone_offset integer) RETURNS TABLE(id integer, is_new boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_call_id INTEGER;
    v_is_new BOOLEAN := FALSE;
BEGIN
    -- Check if call already exists for this person
    SELECT c.id INTO v_call_id
    FROM outbound.calls c
    WHERE c.pipedrive_person_id = p_pipedrive_person_id
    AND c.call_status != 'completed'
    LIMIT 1;

    IF v_call_id IS NULL THEN
        -- Insert new call record
        INSERT INTO outbound.calls (
            pipedrive_person_id,
            pipedrive_org_id,
            person_name,
            organization_name,
            phone_number,
            timezone,
            timezone_offset
        ) VALUES (
            p_pipedrive_person_id,
            p_pipedrive_org_id,
            p_person_name,
            p_organization_name,
            p_phone_number,
            p_timezone,
            p_timezone_offset
        ) RETURNING outbound.calls.id INTO v_call_id;
        v_is_new := TRUE;
    ELSE
        -- Update existing record
        UPDATE outbound.calls
        SET person_name = p_person_name,
            organization_name = p_organization_name,
            phone_number = p_phone_number,
            timezone = p_timezone,
            timezone_offset = p_timezone_offset,
            updated_at = CURRENT_TIMESTAMP,
            call_status = CASE
                WHEN call_status='gone' THEN 'pending'
                ELSE call_status
            END
        WHERE outbound.calls.id = v_call_id;
    END IF;

    RETURN QUERY SELECT v_call_id, v_is_new;
END;
$$;


ALTER FUNCTION outbound.upsert_pipedrive_person(p_pipedrive_person_id integer, p_pipedrive_org_id integer, p_person_name character varying, p_organization_name character varying, p_phone_number character varying, p_timezone character varying, p_timezone_offset integer) OWNER TO postgres;

--
-- Name: upsert_user(character varying, character varying, character varying, text); Type: FUNCTION; Schema: outbound; Owner: postgres
--

CREATE FUNCTION outbound.upsert_user(in_google_id character varying, in_email character varying, in_name character varying, in_picture text DEFAULT NULL::text) RETURNS TABLE(out_id integer, out_google_id character varying, out_email character varying, out_name character varying, out_picture text, out_goto_token jsonb, out_goto_line text, out_goto_line_display character varying, out_created_at timestamp without time zone, out_last_login timestamp without time zone, out_is_active boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    INSERT INTO outbound.users (google_id, email, name, picture, last_login)
    VALUES (in_google_id, in_email, in_name, in_picture, CURRENT_TIMESTAMP)
    ON CONFLICT (google_id)
    DO UPDATE SET
        email = EXCLUDED.email,
        name = EXCLUDED.name,
        picture = EXCLUDED.picture,
        last_login = CURRENT_TIMESTAMP
    RETURNING
        id AS out_id,
        google_id AS out_google_id,
        email AS out_email,
        name AS out_name,
        picture AS out_picture,
        goto_token AS out_goto_token,
        goto_line AS out_goto_line,
        goto_line_display AS out_goto_line_display,
        created_at AS out_created_at,
        last_login AS out_last_login,
        is_active AS out_is_active;
END;
$$;


ALTER FUNCTION outbound.upsert_user(in_google_id character varying, in_email character varying, in_name character varying, in_picture text) OWNER TO postgres;

--
-- Name: check_email(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_email(email_address text) RETURNS boolean
    LANGUAGE plpython3u IMMUTABLE STRICT
    AS $$
	# use SD for from email_validator import validate_email, EmailNotValidError,EmailUndeliverableError
	imports = ['validate_email','EmailNotValidError','EmailUndeliverableError']

	if any(k not in SD for k in imports):
		from email_validator import validate_email,EmailNotValidError,EmailUndeliverableError
		SD['validate_email'] = validate_email
		SD['EmailNotValidError'] = EmailNotValidError
		SD['EmailUndeliverableError'] = EmailUndeliverableError

	if not email_address:
		return False

	try:
		# this will raise EmailUndeliverableError if no DNS records exist,
		# EmailNotValidError for simple syntax problems.
		SD['validate_email'](email_address, check_deliverability=True)
	except (SD['EmailUndeliverableError'],SD['EmailNotValidError']) as e:
		return False

	return True
$$;


ALTER FUNCTION public.check_email(email_address text) OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: admin_session; Type: TABLE; Schema: auth; Owner: postgres
--

CREATE TABLE auth.admin_session (
    uuid uuid DEFAULT gen_random_uuid() NOT NULL,
    admin_user_id bigint NOT NULL,
    ip inet NOT NULL,
    user_agent text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone NOT NULL
);


ALTER TABLE auth.admin_session OWNER TO postgres;

--
-- Name: admin_user; Type: TABLE; Schema: auth; Owner: postgres
--

CREATE TABLE auth.admin_user (
    id bigint NOT NULL,
    email public.email NOT NULL,
    full_name text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    last_login timestamp with time zone,
    google_id character varying(255)
);


ALTER TABLE auth.admin_user OWNER TO postgres;

--
-- Name: admin_user_id_seq; Type: SEQUENCE; Schema: auth; Owner: postgres
--

ALTER TABLE auth.admin_user ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME auth.admin_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: user; Type: TABLE; Schema: auth; Owner: postgres
--

CREATE TABLE auth."user" (
    id bigint NOT NULL,
    email public.email NOT NULL,
    password_hash text NOT NULL,
    customer_id bigint,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    last_login timestamp with time zone DEFAULT now() NOT NULL,
    email_verified boolean DEFAULT false,
    email_verification_token uuid,
    email_verification_expires_at timestamp with time zone,
    CONSTRAINT check_token_expires_at_not_null_together CHECK (((email_verification_token IS NULL) = (email_verification_expires_at IS NULL)))
);


ALTER TABLE auth."user" OWNER TO postgres;

--
-- Name: user_id_seq; Type: SEQUENCE; Schema: auth; Owner: postgres
--

ALTER TABLE auth."user" ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME auth.user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: web_session; Type: TABLE; Schema: auth; Owner: postgres
--

CREATE TABLE auth.web_session (
    uuid uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id bigint NOT NULL,
    ip inet NOT NULL,
    user_agent text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone NOT NULL
);


ALTER TABLE auth.web_session OWNER TO postgres;

--
-- Name: barcode; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.barcode (
    gtin_14 character(14) NOT NULL
);


ALTER TABLE dirac.barcode OWNER TO postgres;

--
-- Name: brand; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.brand (
    id bigint NOT NULL,
    name character varying(255) NOT NULL,
    owner_supplier_id bigint,
    embedding public.vector(768) NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    slug character varying(255) NOT NULL,
    CONSTRAINT brand_slug_check CHECK (dirac.is_valid_slug((slug)::text))
);


ALTER TABLE dirac.brand OWNER TO postgres;

--
-- Name: brand_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.brand ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.brand_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: country; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.country (
    iso_3166_2 character(2) NOT NULL,
    iso_3166_3 character(3) NOT NULL,
    name character varying(255) NOT NULL,
    official_name character varying(255) NOT NULL,
    currency character(3) NOT NULL
);


ALTER TABLE dirac.country OWNER TO postgres;

--
-- Name: currency; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.currency (
    iso_4217 character(3) NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE dirac.currency OWNER TO postgres;

--
-- Name: customer; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.customer (
    id bigint NOT NULL,
    pipedrive_deal_id integer,
    name character varying(255) NOT NULL,
    embedding public.vector(768) NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    email character varying(255),
    business_registration_number character varying(255),
    website_url character varying(500),
    phone_number character varying(50),
    country_code character(2),
    customer_notes text,
    contact_person_name character varying(255),
    delivery_instructions text,
    billing_location_id bigint,
    shipping_location_id bigint,
    vat_number character varying(50),
    stripe_customer_id character varying(255),
    stripe_sync_status character varying(50) DEFAULT 'pending'::character varying,
    stripe_sync_error text,
    stripe_synced_at timestamp with time zone,
    default_delivery_instructions text
);


ALTER TABLE dirac.customer OWNER TO postgres;

--
-- Name: customer_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.customer ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.customer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: customer_store; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.customer_store (
    id bigint NOT NULL,
    customer_id bigint NOT NULL,
    location_id bigint NOT NULL
);


ALTER TABLE dirac.customer_store OWNER TO postgres;

--
-- Name: customer_store_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.customer_store ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.customer_store_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: customs_territory; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.customs_territory (
    code character varying(10) NOT NULL,
    name character varying(255) NOT NULL,
    harmonization_depth integer,
    tariff_schedule_name character varying(50),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE dirac.customs_territory OWNER TO postgres;

--
-- Name: customs_territory_member; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.customs_territory_member (
    customs_territory_code character varying(10) NOT NULL,
    country_code character(2) NOT NULL
);


ALTER TABLE dirac.customs_territory_member OWNER TO postgres;

--
-- Name: demand_request; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.demand_request (
    id bigint NOT NULL,
    customer_id bigint NOT NULL,
    brand_id bigint,
    product_id bigint,
    quantity dirac.product_quantity NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    owner_admin_id bigint,
    target_unit_price numeric(19,4),
    target_unit_price_currency character(3),
    notes text,
    source character varying(255),
    eu_goods_tier dirac.eu_goods_tier,
    country_of_origin character(2),
    CONSTRAINT check_brand_or_product CHECK (((brand_id IS NOT NULL) <> (product_id IS NOT NULL))),
    CONSTRAINT unit_price_money CHECK (((target_unit_price IS NULL) = (target_unit_price_currency IS NULL)))
);


ALTER TABLE dirac.demand_request OWNER TO postgres;

--
-- Name: demand_request_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.demand_request ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.demand_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: demand_request_submission; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.demand_request_submission (
    id bigint NOT NULL,
    customer_name character varying(255) NOT NULL,
    email character varying(255),
    business_registration_number character varying(255),
    website_url character varying(500),
    phone_number character varying(50),
    country_code character(2),
    customer_notes text,
    request_type character varying(10) NOT NULL,
    item_name character varying(255) NOT NULL,
    brand_name character varying(255),
    barcode character varying(14),
    quantity dirac.product_quantity NOT NULL,
    request_notes text,
    target_unit_price numeric(19,4),
    target_unit_price_currency character(3),
    status character varying(20) DEFAULT 'pending'::character varying,
    rejection_reason text,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    processed_at timestamp with time zone,
    processed_by_admin_id bigint,
    created_customer_id bigint,
    created_demand_request_id bigint,
    CONSTRAINT demand_request_submission_request_type_check CHECK (((request_type)::text = ANY ((ARRAY['product'::character varying, 'brand'::character varying])::text[]))),
    CONSTRAINT demand_request_submission_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'confirmed'::character varying, 'rejected'::character varying])::text[]))),
    CONSTRAINT target_price_currency_check CHECK (((target_unit_price IS NULL) = (target_unit_price_currency IS NULL)))
);


ALTER TABLE dirac.demand_request_submission OWNER TO postgres;

--
-- Name: demand_request_submission_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.demand_request_submission ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.demand_request_submission_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: discount_function; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.discount_function (
    id bigint NOT NULL,
    name character varying(255),
    description text,
    discounts dirac.discount_range[],
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT discounts_must_be_valid CHECK (dirac.validate_discounts(discounts))
);


ALTER TABLE dirac.discount_function OWNER TO postgres;

--
-- Name: discount_function_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.discount_function ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.discount_function_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: image; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.image (
    id bigint NOT NULL,
    uuid uuid DEFAULT gen_random_uuid() NOT NULL,
    blob bytea NOT NULL,
    width_px integer NOT NULL,
    height_px integer NOT NULL,
    image_type dirac.image_type NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT image_height_px_check CHECK ((height_px > 0)),
    CONSTRAINT image_width_px_check CHECK ((width_px > 0))
);


ALTER TABLE dirac.image OWNER TO postgres;

--
-- Name: image_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.image ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.image_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: location; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.location (
    id bigint NOT NULL,
    name character varying(255) NOT NULL,
    country character(2) NOT NULL,
    region character varying(100),
    address text,
    postcode character varying(15),
    google_place_id character varying(63),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE dirac.location OWNER TO postgres;

--
-- Name: location_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.location ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.location_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: supplier; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.supplier (
    id bigint NOT NULL,
    name character varying(255) NOT NULL,
    default_moq numeric(19,4),
    default_moq_currency character(3),
    credit_terms_days integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    discount_function_id bigint DEFAULT 1,
    embedding public.vector(768) NOT NULL,
    CONSTRAINT default_moq_money CHECK ((((default_moq IS NOT NULL) AND (default_moq_currency IS NOT NULL)) OR ((default_moq IS NULL) AND (default_moq_currency IS NULL))))
);


ALTER TABLE dirac.supplier OWNER TO postgres;

--
-- Name: manufacturer_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.supplier ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.manufacturer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: supplier_store; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.supplier_store (
    id bigint NOT NULL,
    supplier_id bigint NOT NULL,
    location_id bigint NOT NULL
);


ALTER TABLE dirac.supplier_store OWNER TO postgres;

--
-- Name: manufacturer_store_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.supplier_store ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.manufacturer_store_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: margin_estimate; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.margin_estimate (
    id bigint NOT NULL,
    company_name character varying(255) NOT NULL,
    company_domain character varying(255),
    p20 numeric(5,4),
    p50 numeric(5,4),
    p80 numeric(5,4),
    ignore boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT margin_estimate_p20_check CHECK (((p20 IS NULL) OR ((p20 >= (0)::numeric) AND (p20 <= (1)::numeric)))),
    CONSTRAINT margin_estimate_p50_check CHECK (((p50 IS NULL) OR ((p50 >= (0)::numeric) AND (p50 <= (1)::numeric)))),
    CONSTRAINT margin_estimate_p80_check CHECK (((p80 IS NULL) OR ((p80 >= (0)::numeric) AND (p80 <= (1)::numeric))))
);


ALTER TABLE dirac.margin_estimate OWNER TO postgres;

--
-- Name: margin_estimate_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.margin_estimate ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.margin_estimate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: order; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac."order" (
    id bigint NOT NULL,
    uuid uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id bigint NOT NULL,
    status dirac.order_status DEFAULT 'basket'::dirac.order_status NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    placed_at timestamp with time zone,
    confirmed_at timestamp with time zone,
    shipped_at timestamp with time zone,
    delivered_at timestamp with time zone,
    cancelled_at timestamp with time zone,
    total_amount_excl_vat numeric(19,4),
    currency character(3),
    notes text,
    shipping_address_id bigint,
    billing_address_id bigint,
    payment_id bigint,
    total_vat_amount numeric(19,4),
    total_amount_incl_vat numeric(19,4),
    shipping_cost_amount numeric(19,4),
    shipping_cost_currency character(3),
    shipping_pallets integer,
    shipping_cost_calculated_at timestamp with time zone,
    paid_at timestamp with time zone,
    stripe_checkout_session_id character varying(255),
    delivery_instructions text,
    CONSTRAINT check_shipping_currency_matches CHECK (((shipping_cost_currency IS NULL) OR (currency IS NULL) OR (shipping_cost_currency = currency)))
);


ALTER TABLE dirac."order" OWNER TO postgres;

--
-- Name: COLUMN "order".total_amount_excl_vat; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".total_amount_excl_vat IS 'Total excluding VAT (subtotal)';


--
-- Name: COLUMN "order".total_vat_amount; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".total_vat_amount IS 'Total VAT amount across all items';


--
-- Name: COLUMN "order".total_amount_incl_vat; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".total_amount_incl_vat IS 'Grand total including VAT';


--
-- Name: COLUMN "order".shipping_cost_amount; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".shipping_cost_amount IS 'Calculated shipping cost for this order';


--
-- Name: COLUMN "order".shipping_cost_currency; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".shipping_cost_currency IS 'Currency for shipping cost (typically GBP for UK orders)';


--
-- Name: COLUMN "order".shipping_pallets; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".shipping_pallets IS 'Number of pallets required for this order';


--
-- Name: COLUMN "order".shipping_cost_calculated_at; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".shipping_cost_calculated_at IS 'Timestamp when shipping cost was calculated';


--
-- Name: COLUMN "order".paid_at; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".paid_at IS 'Timestamp when payment was successfully completed via Stripe';


--
-- Name: COLUMN "order".stripe_checkout_session_id; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".stripe_checkout_session_id IS 'Stripe Checkout Session ID for payment reconciliation';


--
-- Name: COLUMN "order".delivery_instructions; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac."order".delivery_instructions IS 'Specific delivery instructions for this order (e.g., "Leave at reception", "Call on arrival")';


--
-- Name: order_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac."order" ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: order_item; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.order_item (
    id bigint NOT NULL,
    order_id bigint NOT NULL,
    product_case_id bigint NOT NULL,
    case_quantity numeric(19,4) NOT NULL,
    case_price numeric(19,4) NOT NULL,
    currency character(3) NOT NULL,
    discount_applied numeric(19,4),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    uk_vat_fraction numeric(5,4),
    vat_amount numeric(19,4),
    CONSTRAINT order_item_quantity_check CHECK ((case_quantity > (0)::numeric)),
    CONSTRAINT order_item_unit_price_check CHECK ((case_price >= (0)::numeric))
);


ALTER TABLE dirac.order_item OWNER TO postgres;

--
-- Name: COLUMN order_item.uk_vat_fraction; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac.order_item.uk_vat_fraction IS 'Snapshot of UK VAT rate at order time as a fraction (0.20 = 20%). VAT amount calculated on the fly from this fraction.';


--
-- Name: COLUMN order_item.vat_amount; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac.order_item.vat_amount IS 'Calculated VAT amount for this line item';


--
-- Name: order_item_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.order_item ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.order_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: payment; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.payment (
    id bigint NOT NULL,
    order_id bigint NOT NULL,
    stripe_payment_intent_id character varying(255) NOT NULL,
    amount numeric(19,4) NOT NULL,
    currency character(3) NOT NULL,
    status character varying(50) NOT NULL,
    stripe_status character varying(50),
    payment_method character varying(50),
    failure_reason text,
    metadata jsonb,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE dirac.payment OWNER TO postgres;

--
-- Name: payment_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.payment ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: pricing_constants; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.pricing_constants (
    id bigint NOT NULL,
    min_margin numeric(5,4) NOT NULL,
    margin_below_competitors numeric(10,2) NOT NULL,
    competitive_price_metric character varying(20) DEFAULT 'median'::character varying NOT NULL,
    competitive_price_percentile character varying(10) DEFAULT 'p50'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT pricing_constants_min_margin_check CHECK (((min_margin >= (0)::numeric) AND (min_margin <= (1)::numeric)))
);


ALTER TABLE dirac.pricing_constants OWNER TO postgres;

--
-- Name: pricing_constants_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.pricing_constants ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.pricing_constants_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: pricing_job; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.pricing_job (
    id character varying(255) NOT NULL,
    admin_id bigint NOT NULL,
    status dirac.pricing_job_status DEFAULT 'pending'::dirac.pricing_job_status NOT NULL,
    products_count integer NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    error_message text,
    results jsonb
);


ALTER TABLE dirac.pricing_job OWNER TO postgres;

--
-- Name: product; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.product (
    id bigint NOT NULL,
    name character varying(255) NOT NULL,
    brand_id bigint,
    show_on_web boolean DEFAULT false NOT NULL,
    barcode character(14),
    embedding public.vector(768) NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    slug character varying(255) NOT NULL,
    image_id bigint,
    web_unit_price numeric(19,4),
    web_unit_price_currency character(3),
    web_discount bigint,
    web_discount_unit dirac.product_quantity_unit,
    web_product_case_id bigint,
    uk_vat_fraction numeric(5,4) DEFAULT 0.20 NOT NULL,
    CONSTRAINT check_has_price_if_web CHECK (((NOT show_on_web) OR (web_unit_price IS NOT NULL))),
    CONSTRAINT check_has_unit_if_discount CHECK (((web_discount IS NULL) = (web_discount_unit IS NULL))),
    CONSTRAINT check_web_price_is_gbp CHECK (((NOT show_on_web) OR (web_unit_price_currency = 'GBP'::bpchar))),
    CONSTRAINT product_slug_check CHECK (dirac.is_valid_slug((slug)::text)),
    CONSTRAINT web_unit_price_money CHECK (((web_unit_price IS NULL) = (web_unit_price_currency IS NULL)))
);


ALTER TABLE dirac.product OWNER TO postgres;

--
-- Name: COLUMN product.uk_vat_fraction; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac.product.uk_vat_fraction IS 'UK VAT rate as a fraction (0.20 = 20%). Alcohol is standard rate (20%). Zero-rated products use 0.00';


--
-- Name: product_case; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.product_case (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    case_barcode character(14),
    weight_kg numeric(19,4),
    height_cm numeric(19,4),
    width_cm numeric(19,4),
    length_cm numeric(19,4),
    units_per_case integer NOT NULL,
    cases_per_layer integer,
    layers_per_pallet integer
);


ALTER TABLE dirac.product_case OWNER TO postgres;

--
-- Name: product_case_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.product_case ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.product_case_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_detail; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.product_detail (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    shelf_life_days integer,
    is_gluten_free boolean,
    volume_ml numeric(19,4),
    weight_g numeric(19,4),
    pack_size integer
);


ALTER TABLE dirac.product_detail OWNER TO postgres;

--
-- Name: product_detail_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.product_detail ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.product_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.product ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_offer; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.product_offer (
    id bigint NOT NULL,
    sku character varying(127),
    supplier_id bigint NOT NULL,
    product_id bigint NOT NULL,
    case_price_base numeric(19,4) NOT NULL,
    case_price_currency character(3) NOT NULL,
    country_of_origin character(2),
    moq_cases integer,
    is_active boolean DEFAULT true NOT NULL,
    added_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    product_level_discount_function_id bigint DEFAULT 1,
    brand_level_discount_function_id bigint DEFAULT 1,
    eu_goods_tier dirac.eu_goods_tier,
    product_case_id bigint NOT NULL
);


ALTER TABLE dirac.product_offer OWNER TO postgres;

--
-- Name: product_offer_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.product_offer ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.product_offer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_tariff_classification; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.product_tariff_classification (
    tariff_code_id bigint NOT NULL,
    product_id bigint NOT NULL
);


ALTER TABLE dirac.product_tariff_classification OWNER TO postgres;

--
-- Name: tariff_code; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.tariff_code (
    id bigint NOT NULL,
    code character varying(10) NOT NULL,
    country character(2),
    customs_territory_code character varying(10),
    depth integer NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT tariff_code_code_check CHECK (((code)::text ~ '^[0-9]+$'::text)),
    CONSTRAINT tariff_code_depth_check CHECK ((depth = ANY (ARRAY[4, 6, 8, 10])))
);


ALTER TABLE dirac.tariff_code OWNER TO postgres;

--
-- Name: tariff_code_id_seq; Type: SEQUENCE; Schema: dirac; Owner: postgres
--

ALTER TABLE dirac.tariff_code ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME dirac.tariff_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: vat_rate; Type: TABLE; Schema: dirac; Owner: postgres
--

CREATE TABLE dirac.vat_rate (
    fraction numeric(5,4) NOT NULL,
    name character varying(100) NOT NULL,
    description text,
    stripe_tax_rate_id character varying(255),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE dirac.vat_rate OWNER TO postgres;

--
-- Name: TABLE vat_rate; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON TABLE dirac.vat_rate IS 'Centralized VAT rate definitions with Stripe tax rate integration';


--
-- Name: COLUMN vat_rate.fraction; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac.vat_rate.fraction IS 'VAT rate as fraction (0.20 = 20%)';


--
-- Name: COLUMN vat_rate.name; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac.vat_rate.name IS 'Display name (e.g., "Standard-Rate", "Zero-Rated")';


--
-- Name: COLUMN vat_rate.stripe_tax_rate_id; Type: COMMENT; Schema: dirac; Owner: postgres
--

COMMENT ON COLUMN dirac.vat_rate.stripe_tax_rate_id IS 'Stripe tax rate ID, auto-populated on first use';


--
-- Name: organization; Type: TABLE; Schema: enrichment; Owner: postgres
--

CREATE TABLE enrichment.organization (
    id bigint NOT NULL,
    apollo_org_id text,
    domain text,
    linkedin_slug character varying(255),
    payload jsonb,
    added_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT organization_linkedin_slug_check CHECK (dirac.is_valid_slug((linkedin_slug)::text))
);


ALTER TABLE enrichment.organization OWNER TO postgres;

--
-- Name: organization_id_seq; Type: SEQUENCE; Schema: enrichment; Owner: postgres
--

ALTER TABLE enrichment.organization ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME enrichment.organization_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: organization_persona_search; Type: TABLE; Schema: enrichment; Owner: postgres
--

CREATE TABLE enrichment.organization_persona_search (
    organization_id bigint NOT NULL,
    persona_id bigint NOT NULL,
    searched_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE enrichment.organization_persona_search OWNER TO postgres;

--
-- Name: person; Type: TABLE; Schema: enrichment; Owner: postgres
--

CREATE TABLE enrichment.person (
    id bigint NOT NULL,
    apollo_person_id text,
    email text,
    linkedin_slug character varying(255),
    payload jsonb,
    added_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT person_linkedin_slug_check CHECK (dirac.is_valid_slug((linkedin_slug)::text))
);


ALTER TABLE enrichment.person OWNER TO postgres;

--
-- Name: person_id_seq; Type: SEQUENCE; Schema: enrichment; Owner: postgres
--

ALTER TABLE enrichment.person ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME enrichment.person_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: persona; Type: TABLE; Schema: enrichment; Owner: postgres
--

CREATE TABLE enrichment.persona (
    id bigint NOT NULL,
    name text NOT NULL,
    payload jsonb NOT NULL
);


ALTER TABLE enrichment.persona OWNER TO postgres;

--
-- Name: persona_id_seq; Type: SEQUENCE; Schema: enrichment; Owner: postgres
--

ALTER TABLE enrichment.persona ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME enrichment.persona_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product; Type: TABLE; Schema: google; Owner: postgres
--

CREATE TABLE google.product (
    id bigint NOT NULL,
    page_token character varying(1023) NOT NULL,
    payload jsonb NOT NULL
);


ALTER TABLE google.product OWNER TO postgres;

--
-- Name: product_id_seq; Type: SEQUENCE; Schema: google; Owner: postgres
--

ALTER TABLE google.product ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME google.product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_search; Type: TABLE; Schema: google; Owner: postgres
--

CREATE TABLE google.product_search (
    id bigint NOT NULL,
    query character varying(255) NOT NULL,
    payload jsonb NOT NULL,
    added_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE google.product_search OWNER TO postgres;

--
-- Name: product_search_id_seq; Type: SEQUENCE; Schema: google; Owner: postgres
--

ALTER TABLE google.product_search ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME google.product_search_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: company; Type: TABLE; Schema: linkedin; Owner: postgres
--

CREATE TABLE linkedin.company (
    id bigint NOT NULL,
    slug character varying(255),
    company_id bigint,
    name character varying(255) NOT NULL,
    industry character varying(255),
    location character varying(255),
    followers character varying(50),
    description text,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT company_slug_check CHECK (dirac.is_valid_slug((slug)::text))
);


ALTER TABLE linkedin.company OWNER TO postgres;

--
-- Name: company_id_seq; Type: SEQUENCE; Schema: linkedin; Owner: postgres
--

ALTER TABLE linkedin.company ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME linkedin.company_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: group; Type: TABLE; Schema: linkedin; Owner: postgres
--

CREATE TABLE linkedin."group" (
    id bigint NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    member_count character varying(50),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE linkedin."group" OWNER TO postgres;

--
-- Name: person; Type: TABLE; Schema: linkedin; Owner: postgres
--

CREATE TABLE linkedin.person (
    id bigint NOT NULL,
    slug character varying(255),
    member_id text,
    name character varying(255) NOT NULL,
    title text,
    company character varying(255),
    location character varying(255),
    followers character varying(50),
    is_premium boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT person_slug_check CHECK (dirac.is_valid_slug((slug)::text))
);


ALTER TABLE linkedin.person OWNER TO postgres;

--
-- Name: person_id_seq; Type: SEQUENCE; Schema: linkedin; Owner: postgres
--

ALTER TABLE linkedin.person ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME linkedin.person_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: post; Type: TABLE; Schema: linkedin; Owner: postgres
--

CREATE TABLE linkedin.post (
    id bigint NOT NULL,
    company_id bigint,
    person_id bigint,
    search_result_id bigint,
    content text,
    hashtags text[],
    mentions text[],
    links text[],
    "timestamp" character varying(50),
    posted_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    url character varying(500),
    urn character varying(100),
    CONSTRAINT check_company_or_person CHECK (((company_id IS NULL) <> (person_id IS NULL)))
);


ALTER TABLE linkedin.post OWNER TO postgres;

--
-- Name: post_id_seq; Type: SEQUENCE; Schema: linkedin; Owner: postgres
--

ALTER TABLE linkedin.post ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME linkedin.post_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: search_result; Type: TABLE; Schema: linkedin; Owner: postgres
--

CREATE TABLE linkedin.search_result (
    id bigint NOT NULL,
    search_query text,
    search_type character varying(50),
    current_page integer,
    total_pages integer,
    total_results integer,
    keywords text,
    author_company_ids bigint[],
    author_industry_ids integer[],
    author_job_title text,
    content_type character varying(50),
    date_posted character varying(50),
    from_member_ids text[],
    mentions_member_ids text[],
    mentions_organization_ids bigint[],
    posted_by text[],
    sort_by character varying(50),
    search_url text,
    extracted_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT search_result_search_type_check CHECK (((search_type)::text = ANY ((ARRAY['people'::character varying, 'companies'::character varying, 'posts'::character varying, 'groups'::character varying, 'all'::character varying, 'content'::character varying])::text[])))
);


ALTER TABLE linkedin.search_result OWNER TO postgres;

--
-- Name: search_result_id_seq; Type: SEQUENCE; Schema: linkedin; Owner: postgres
--

ALTER TABLE linkedin.search_result ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME linkedin.search_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: calls; Type: TABLE; Schema: outbound; Owner: postgres
--

CREATE TABLE outbound.calls (
    id integer NOT NULL,
    pipedrive_person_id integer NOT NULL,
    pipedrive_org_id integer,
    person_name character varying(255) NOT NULL,
    organization_name character varying(255),
    phone_number character varying(50) NOT NULL,
    timezone character varying(50) NOT NULL,
    timezone_offset integer NOT NULL,
    call_status character varying(20) DEFAULT 'pending'::character varying,
    call_started_at timestamp with time zone,
    call_completed_at timestamp with time zone,
    call_notes text,
    locked_by character varying(100),
    locked_at timestamp with time zone,
    pipedrive_activity_id integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT calls_call_status_check CHECK (((call_status)::text = ANY ((ARRAY['pending'::character varying, 'in_progress'::character varying, 'completed'::character varying, 'failed'::character varying, 'opted_out'::character varying, 'gone'::character varying])::text[])))
);


ALTER TABLE outbound.calls OWNER TO postgres;

--
-- Name: calls_id_seq; Type: SEQUENCE; Schema: outbound; Owner: postgres
--

CREATE SEQUENCE outbound.calls_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE outbound.calls_id_seq OWNER TO postgres;

--
-- Name: calls_id_seq; Type: SEQUENCE OWNED BY; Schema: outbound; Owner: postgres
--

ALTER SEQUENCE outbound.calls_id_seq OWNED BY outbound.calls.id;


--
-- Name: users; Type: TABLE; Schema: outbound; Owner: postgres
--

CREATE TABLE outbound.users (
    id integer NOT NULL,
    google_id character varying(255) NOT NULL,
    email character varying(255) NOT NULL,
    name character varying(255) NOT NULL,
    picture text,
    goto_token jsonb,
    goto_line text,
    goto_line_display character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    last_login timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    is_active boolean DEFAULT true
);


ALTER TABLE outbound.users OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: outbound; Owner: postgres
--

CREATE SEQUENCE outbound.users_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE outbound.users_id_seq OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: outbound; Owner: postgres
--

ALTER SEQUENCE outbound.users_id_seq OWNED BY outbound.users.id;


--
-- Name: goose_db_version; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.goose_db_version (
    id integer NOT NULL,
    version_id bigint NOT NULL,
    is_applied boolean NOT NULL,
    tstamp timestamp without time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.goose_db_version OWNER TO postgres;

--
-- Name: goose_db_version_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.goose_db_version ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.goose_db_version_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: v_brand_count; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.v_brand_count (
    count bigint
);


ALTER TABLE public.v_brand_count OWNER TO postgres;

--
-- Name: calls id; Type: DEFAULT; Schema: outbound; Owner: postgres
--

ALTER TABLE ONLY outbound.calls ALTER COLUMN id SET DEFAULT nextval('outbound.calls_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: outbound; Owner: postgres
--

ALTER TABLE ONLY outbound.users ALTER COLUMN id SET DEFAULT nextval('outbound.users_id_seq'::regclass);


--
-- Name: admin_session admin_session_pkey; Type: CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth.admin_session
    ADD CONSTRAINT admin_session_pkey PRIMARY KEY (uuid);


--
-- Name: admin_user admin_user_email_key; Type: CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth.admin_user
    ADD CONSTRAINT admin_user_email_key UNIQUE (email);


--
-- Name: admin_user admin_user_google_id_key; Type: CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth.admin_user
    ADD CONSTRAINT admin_user_google_id_key UNIQUE (google_id);


--
-- Name: admin_user admin_user_pkey; Type: CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth.admin_user
    ADD CONSTRAINT admin_user_pkey PRIMARY KEY (id);


--
-- Name: user user_email_key; Type: CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth."user"
    ADD CONSTRAINT user_email_key UNIQUE (email);


--
-- Name: user user_pkey; Type: CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- Name: web_session web_session_pkey; Type: CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth.web_session
    ADD CONSTRAINT web_session_pkey PRIMARY KEY (uuid);


--
-- Name: barcode barcode_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.barcode
    ADD CONSTRAINT barcode_pkey PRIMARY KEY (gtin_14);


--
-- Name: brand brand_name_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.brand
    ADD CONSTRAINT brand_name_key UNIQUE (name);


--
-- Name: brand brand_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.brand
    ADD CONSTRAINT brand_pkey PRIMARY KEY (id);


--
-- Name: brand brand_slug_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.brand
    ADD CONSTRAINT brand_slug_key UNIQUE (slug);


--
-- Name: country country_iso_3166_3_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.country
    ADD CONSTRAINT country_iso_3166_3_key UNIQUE (iso_3166_3);


--
-- Name: country country_name_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.country
    ADD CONSTRAINT country_name_key UNIQUE (name);


--
-- Name: country country_official_name_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.country
    ADD CONSTRAINT country_official_name_key UNIQUE (official_name);


--
-- Name: country country_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.country
    ADD CONSTRAINT country_pkey PRIMARY KEY (iso_3166_2);


--
-- Name: currency currency_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.currency
    ADD CONSTRAINT currency_pkey PRIMARY KEY (iso_4217);


--
-- Name: customer customer_name_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer
    ADD CONSTRAINT customer_name_key UNIQUE (name);


--
-- Name: customer customer_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer
    ADD CONSTRAINT customer_pkey PRIMARY KEY (id);


--
-- Name: customer_store customer_store_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer_store
    ADD CONSTRAINT customer_store_pkey PRIMARY KEY (id);


--
-- Name: customer customer_stripe_customer_id_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer
    ADD CONSTRAINT customer_stripe_customer_id_key UNIQUE (stripe_customer_id);


--
-- Name: customs_territory_member customs_territory_member_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customs_territory_member
    ADD CONSTRAINT customs_territory_member_pkey PRIMARY KEY (customs_territory_code, country_code);


--
-- Name: customs_territory customs_territory_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customs_territory
    ADD CONSTRAINT customs_territory_pkey PRIMARY KEY (code);


--
-- Name: demand_request demand_request_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT demand_request_pkey PRIMARY KEY (id);


--
-- Name: demand_request_submission demand_request_submission_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request_submission
    ADD CONSTRAINT demand_request_submission_pkey PRIMARY KEY (id);


--
-- Name: discount_function discount_function_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.discount_function
    ADD CONSTRAINT discount_function_pkey PRIMARY KEY (id);


--
-- Name: image image_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.image
    ADD CONSTRAINT image_pkey PRIMARY KEY (id);


--
-- Name: location location_address_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.location
    ADD CONSTRAINT location_address_key UNIQUE (address);


--
-- Name: location location_google_place_id_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.location
    ADD CONSTRAINT location_google_place_id_key UNIQUE (google_place_id);


--
-- Name: location location_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.location
    ADD CONSTRAINT location_pkey PRIMARY KEY (id);


--
-- Name: location location_postcode_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.location
    ADD CONSTRAINT location_postcode_key UNIQUE (postcode);


--
-- Name: supplier manufacturer_name_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier
    ADD CONSTRAINT manufacturer_name_key UNIQUE (name);


--
-- Name: supplier manufacturer_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier
    ADD CONSTRAINT manufacturer_pkey PRIMARY KEY (id);


--
-- Name: supplier_store manufacturer_store_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier_store
    ADD CONSTRAINT manufacturer_store_pkey PRIMARY KEY (id);


--
-- Name: margin_estimate margin_estimate_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.margin_estimate
    ADD CONSTRAINT margin_estimate_pkey PRIMARY KEY (id);


--
-- Name: order_item order_item_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.order_item
    ADD CONSTRAINT order_item_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (id);


--
-- Name: order order_stripe_checkout_session_id_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_stripe_checkout_session_id_key UNIQUE (stripe_checkout_session_id);


--
-- Name: order order_uuid_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_uuid_key UNIQUE (uuid);


--
-- Name: payment payment_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.payment
    ADD CONSTRAINT payment_pkey PRIMARY KEY (id);


--
-- Name: payment payment_stripe_payment_intent_id_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.payment
    ADD CONSTRAINT payment_stripe_payment_intent_id_key UNIQUE (stripe_payment_intent_id);


--
-- Name: pricing_constants pricing_constants_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.pricing_constants
    ADD CONSTRAINT pricing_constants_pkey PRIMARY KEY (id);


--
-- Name: pricing_job pricing_job_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.pricing_job
    ADD CONSTRAINT pricing_job_pkey PRIMARY KEY (id);


--
-- Name: product product_barcode_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_barcode_key UNIQUE (barcode);


--
-- Name: product_case product_case_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_case
    ADD CONSTRAINT product_case_pkey PRIMARY KEY (id);


--
-- Name: product_detail product_detail_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_detail
    ADD CONSTRAINT product_detail_pkey PRIMARY KEY (id);


--
-- Name: product_detail product_detail_product_id_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_detail
    ADD CONSTRAINT product_detail_product_id_key UNIQUE (product_id);


--
-- Name: product product_name_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_name_key UNIQUE (name);


--
-- Name: product_offer product_offer_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: product product_slug_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_slug_key UNIQUE (slug);


--
-- Name: product_tariff_classification product_tariff_classification_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_tariff_classification
    ADD CONSTRAINT product_tariff_classification_pkey PRIMARY KEY (tariff_code_id, product_id);


--
-- Name: tariff_code tariff_code_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.tariff_code
    ADD CONSTRAINT tariff_code_pkey PRIMARY KEY (id);


--
-- Name: margin_estimate unique_company_name; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.margin_estimate
    ADD CONSTRAINT unique_company_name UNIQUE (company_name);


--
-- Name: demand_request unique_customer_brand; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT unique_customer_brand UNIQUE (brand_id, customer_id);


--
-- Name: customer_store unique_customer_id_location_id; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer_store
    ADD CONSTRAINT unique_customer_id_location_id UNIQUE (customer_id, location_id);


--
-- Name: demand_request unique_customer_product; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT unique_customer_product UNIQUE (customer_id, product_id);


--
-- Name: supplier_store unique_manufacturer_id_location_id; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier_store
    ADD CONSTRAINT unique_manufacturer_id_location_id UNIQUE (supplier_id, location_id);


--
-- Name: product_offer unique_manufacturer_id_product_id_product_variant_id; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT unique_manufacturer_id_product_id_product_variant_id UNIQUE (supplier_id, product_id);


--
-- Name: order_item unique_order_product_case; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.order_item
    ADD CONSTRAINT unique_order_product_case UNIQUE (order_id, product_case_id);


--
-- Name: product_case unique_product_units_per_case; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_case
    ADD CONSTRAINT unique_product_units_per_case UNIQUE (product_id, units_per_case);


--
-- Name: product_offer unique_sku_per_manufacturer; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT unique_sku_per_manufacturer UNIQUE (sku, supplier_id);


--
-- Name: tariff_code unique_territory_code; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.tariff_code
    ADD CONSTRAINT unique_territory_code UNIQUE (country, code);


--
-- Name: vat_rate vat_rate_pkey; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.vat_rate
    ADD CONSTRAINT vat_rate_pkey PRIMARY KEY (fraction);


--
-- Name: vat_rate vat_rate_stripe_tax_rate_id_key; Type: CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.vat_rate
    ADD CONSTRAINT vat_rate_stripe_tax_rate_id_key UNIQUE (stripe_tax_rate_id);


--
-- Name: organization organization_apollo_org_id_key; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.organization
    ADD CONSTRAINT organization_apollo_org_id_key UNIQUE (apollo_org_id);


--
-- Name: organization organization_domain_key; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.organization
    ADD CONSTRAINT organization_domain_key UNIQUE (domain);


--
-- Name: organization organization_linkedin_slug_key; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.organization
    ADD CONSTRAINT organization_linkedin_slug_key UNIQUE (linkedin_slug);


--
-- Name: organization_persona_search organization_persona_search_pkey; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.organization_persona_search
    ADD CONSTRAINT organization_persona_search_pkey PRIMARY KEY (organization_id, persona_id);


--
-- Name: organization organization_pkey; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.organization
    ADD CONSTRAINT organization_pkey PRIMARY KEY (id);


--
-- Name: person person_apollo_person_id_key; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.person
    ADD CONSTRAINT person_apollo_person_id_key UNIQUE (apollo_person_id);


--
-- Name: person person_email_key; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.person
    ADD CONSTRAINT person_email_key UNIQUE (email);


--
-- Name: person person_linkedin_slug_key; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.person
    ADD CONSTRAINT person_linkedin_slug_key UNIQUE (linkedin_slug);


--
-- Name: person person_pkey; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.person
    ADD CONSTRAINT person_pkey PRIMARY KEY (id);


--
-- Name: persona persona_name_key; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.persona
    ADD CONSTRAINT persona_name_key UNIQUE (name);


--
-- Name: persona persona_pkey; Type: CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.persona
    ADD CONSTRAINT persona_pkey PRIMARY KEY (id);


--
-- Name: product product_page_token_key; Type: CONSTRAINT; Schema: google; Owner: postgres
--

ALTER TABLE ONLY google.product
    ADD CONSTRAINT product_page_token_key UNIQUE (page_token);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: google; Owner: postgres
--

ALTER TABLE ONLY google.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: product_search product_search_pkey; Type: CONSTRAINT; Schema: google; Owner: postgres
--

ALTER TABLE ONLY google.product_search
    ADD CONSTRAINT product_search_pkey PRIMARY KEY (id);


--
-- Name: product_search product_search_query_key; Type: CONSTRAINT; Schema: google; Owner: postgres
--

ALTER TABLE ONLY google.product_search
    ADD CONSTRAINT product_search_query_key UNIQUE (query);


--
-- Name: company company_company_id_key; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.company
    ADD CONSTRAINT company_company_id_key UNIQUE (company_id);


--
-- Name: company company_pkey; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.company
    ADD CONSTRAINT company_pkey PRIMARY KEY (id);


--
-- Name: company company_slug_key; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.company
    ADD CONSTRAINT company_slug_key UNIQUE (slug);


--
-- Name: group group_pkey; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin."group"
    ADD CONSTRAINT group_pkey PRIMARY KEY (id);


--
-- Name: person person_member_id_key; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.person
    ADD CONSTRAINT person_member_id_key UNIQUE (member_id);


--
-- Name: person person_pkey; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.person
    ADD CONSTRAINT person_pkey PRIMARY KEY (id);


--
-- Name: person person_slug_key; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.person
    ADD CONSTRAINT person_slug_key UNIQUE (slug);


--
-- Name: post post_pkey; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.post
    ADD CONSTRAINT post_pkey PRIMARY KEY (id);


--
-- Name: search_result search_result_pkey; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.search_result
    ADD CONSTRAINT search_result_pkey PRIMARY KEY (id);


--
-- Name: post unique_post_urn; Type: CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.post
    ADD CONSTRAINT unique_post_urn UNIQUE (urn);


--
-- Name: calls calls_pkey; Type: CONSTRAINT; Schema: outbound; Owner: postgres
--

ALTER TABLE ONLY outbound.calls
    ADD CONSTRAINT calls_pkey PRIMARY KEY (id);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: outbound; Owner: postgres
--

ALTER TABLE ONLY outbound.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_google_id_key; Type: CONSTRAINT; Schema: outbound; Owner: postgres
--

ALTER TABLE ONLY outbound.users
    ADD CONSTRAINT users_google_id_key UNIQUE (google_id);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: outbound; Owner: postgres
--

ALTER TABLE ONLY outbound.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: goose_db_version goose_db_version_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.goose_db_version
    ADD CONSTRAINT goose_db_version_pkey PRIMARY KEY (id);


--
-- Name: idx_admin_session_admin_user_id; Type: INDEX; Schema: auth; Owner: postgres
--

CREATE INDEX idx_admin_session_admin_user_id ON auth.admin_session USING btree (admin_user_id);


--
-- Name: idx_admin_session_expires_at; Type: INDEX; Schema: auth; Owner: postgres
--

CREATE INDEX idx_admin_session_expires_at ON auth.admin_session USING btree (expires_at);


--
-- Name: idx_user_email; Type: INDEX; Schema: auth; Owner: postgres
--

CREATE INDEX idx_user_email ON auth."user" USING btree (email);


--
-- Name: idx_user_email_verification_token; Type: INDEX; Schema: auth; Owner: postgres
--

CREATE INDEX idx_user_email_verification_token ON auth."user" USING btree (email_verification_token) WHERE (email_verification_token IS NOT NULL);


--
-- Name: idx_web_session_expires_at; Type: INDEX; Schema: auth; Owner: postgres
--

CREATE INDEX idx_web_session_expires_at ON auth.web_session USING btree (expires_at);


--
-- Name: idx_web_session_user_id; Type: INDEX; Schema: auth; Owner: postgres
--

CREATE INDEX idx_web_session_user_id ON auth.web_session USING btree (user_id);


--
-- Name: idx_brand_name_trgm; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_brand_name_trgm ON dirac.brand USING gin (name public.gin_trgm_ops);


--
-- Name: idx_customer_email_unique; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE UNIQUE INDEX idx_customer_email_unique ON dirac.customer USING btree (email) WHERE (email IS NOT NULL);


--
-- Name: idx_customer_stripe_id; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_customer_stripe_id ON dirac.customer USING btree (stripe_customer_id);


--
-- Name: idx_customer_stripe_sync_status; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_customer_stripe_sync_status ON dirac.customer USING btree (stripe_sync_status);


--
-- Name: idx_demand_request_owner; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_demand_request_owner ON dirac.demand_request USING btree (owner_admin_id) WHERE (owner_admin_id IS NOT NULL);


--
-- Name: idx_demand_request_submission_created_at; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_demand_request_submission_created_at ON dirac.demand_request_submission USING btree (created_at DESC);


--
-- Name: idx_demand_request_submission_status; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_demand_request_submission_status ON dirac.demand_request_submission USING btree (status) WHERE ((status)::text = 'pending'::text);


--
-- Name: idx_image_uuid; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE UNIQUE INDEX idx_image_uuid ON dirac.image USING btree (uuid);


--
-- Name: idx_margin_estimate_company_domain; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_margin_estimate_company_domain ON dirac.margin_estimate USING btree (company_domain) WHERE (company_domain IS NOT NULL);


--
-- Name: idx_margin_estimate_company_name; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_margin_estimate_company_name ON dirac.margin_estimate USING btree (company_name);


--
-- Name: idx_order_created_at; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_order_created_at ON dirac."order" USING btree (created_at);


--
-- Name: idx_order_item_order; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_order_item_order ON dirac.order_item USING btree (order_id);


--
-- Name: idx_order_item_product_case; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_order_item_product_case ON dirac.order_item USING btree (product_case_id);


--
-- Name: idx_order_status; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_order_status ON dirac."order" USING btree (status);


--
-- Name: idx_order_stripe_session; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_order_stripe_session ON dirac."order" USING btree (stripe_checkout_session_id);


--
-- Name: idx_order_user; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_order_user ON dirac."order" USING btree (user_id);


--
-- Name: idx_order_uuid; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE UNIQUE INDEX idx_order_uuid ON dirac."order" USING btree (uuid);


--
-- Name: idx_payment_order; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_payment_order ON dirac.payment USING btree (order_id);


--
-- Name: idx_payment_status; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_payment_status ON dirac.payment USING btree (status);


--
-- Name: idx_payment_stripe_intent; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_payment_stripe_intent ON dirac.payment USING btree (stripe_payment_intent_id);


--
-- Name: idx_pricing_job_admin; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_pricing_job_admin ON dirac.pricing_job USING btree (admin_id);


--
-- Name: idx_pricing_job_created; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_pricing_job_created ON dirac.pricing_job USING btree (created_at DESC);


--
-- Name: idx_pricing_job_status; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_pricing_job_status ON dirac.pricing_job USING btree (status);


--
-- Name: idx_product_brand_id; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_product_brand_id ON dirac.product USING btree (brand_id);


--
-- Name: idx_product_created_at; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_product_created_at ON dirac.product USING btree (created_at DESC);


--
-- Name: idx_product_name_trgm; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_product_name_trgm ON dirac.product USING gin (name public.gin_trgm_ops);


--
-- Name: idx_product_offer_active; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_product_offer_active ON dirac.product_offer USING btree (product_id, is_active, case_price_base) WHERE (is_active = true);


--
-- Name: idx_product_show_on_web; Type: INDEX; Schema: dirac; Owner: postgres
--

CREATE INDEX idx_product_show_on_web ON dirac.product USING btree (show_on_web) WHERE (show_on_web = true);


--
-- Name: idx_enrichment_org_apollo_id; Type: INDEX; Schema: enrichment; Owner: postgres
--

CREATE INDEX idx_enrichment_org_apollo_id ON enrichment.organization USING btree (apollo_org_id);


--
-- Name: idx_enrichment_org_domain; Type: INDEX; Schema: enrichment; Owner: postgres
--

CREATE INDEX idx_enrichment_org_domain ON enrichment.organization USING btree (domain);


--
-- Name: idx_enrichment_org_linkedin_slug; Type: INDEX; Schema: enrichment; Owner: postgres
--

CREATE INDEX idx_enrichment_org_linkedin_slug ON enrichment.organization USING btree (linkedin_slug);


--
-- Name: idx_enrichment_person_apollo_id; Type: INDEX; Schema: enrichment; Owner: postgres
--

CREATE INDEX idx_enrichment_person_apollo_id ON enrichment.person USING btree (apollo_person_id);


--
-- Name: idx_enrichment_person_email; Type: INDEX; Schema: enrichment; Owner: postgres
--

CREATE INDEX idx_enrichment_person_email ON enrichment.person USING btree (email);


--
-- Name: idx_enrichment_person_linkedin_slug; Type: INDEX; Schema: enrichment; Owner: postgres
--

CREATE INDEX idx_enrichment_person_linkedin_slug ON enrichment.person USING btree (linkedin_slug);


--
-- Name: idx_linkedin_company_name; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_company_name ON linkedin.company USING btree (name);


--
-- Name: idx_linkedin_group_name; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_group_name ON linkedin."group" USING btree (name);


--
-- Name: idx_linkedin_person_company; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_person_company ON linkedin.person USING btree (company);


--
-- Name: idx_linkedin_person_location; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_person_location ON linkedin.person USING btree (location);


--
-- Name: idx_linkedin_person_name; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_person_name ON linkedin.person USING btree (name);


--
-- Name: idx_linkedin_post_company_id; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_post_company_id ON linkedin.post USING btree (company_id);


--
-- Name: idx_linkedin_post_hashtags; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_post_hashtags ON linkedin.post USING gin (hashtags);


--
-- Name: idx_linkedin_post_mentions; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_post_mentions ON linkedin.post USING gin (mentions);


--
-- Name: idx_linkedin_post_person_id; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_post_person_id ON linkedin.post USING btree (person_id);


--
-- Name: idx_linkedin_post_posted_at; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_post_posted_at ON linkedin.post USING btree (posted_at DESC);


--
-- Name: idx_linkedin_post_search_result_id; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_post_search_result_id ON linkedin.post USING btree (search_result_id);


--
-- Name: idx_linkedin_post_urn; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_post_urn ON linkedin.post USING btree (urn);


--
-- Name: idx_linkedin_search_result_author_companies; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_author_companies ON linkedin.search_result USING gin (author_company_ids);


--
-- Name: idx_linkedin_search_result_content_type; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_content_type ON linkedin.search_result USING btree (content_type);


--
-- Name: idx_linkedin_search_result_date_posted; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_date_posted ON linkedin.search_result USING btree (date_posted);


--
-- Name: idx_linkedin_search_result_extracted_at; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_extracted_at ON linkedin.search_result USING btree (extracted_at DESC);


--
-- Name: idx_linkedin_search_result_from_members; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_from_members ON linkedin.search_result USING gin (from_member_ids);


--
-- Name: idx_linkedin_search_result_keywords; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_keywords ON linkedin.search_result USING btree (keywords);


--
-- Name: idx_linkedin_search_result_query; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_query ON linkedin.search_result USING btree (search_query);


--
-- Name: idx_linkedin_search_result_type; Type: INDEX; Schema: linkedin; Owner: postgres
--

CREATE INDEX idx_linkedin_search_result_type ON linkedin.search_result USING btree (search_type);


--
-- Name: idx_calls_locked_by; Type: INDEX; Schema: outbound; Owner: postgres
--

CREATE INDEX idx_calls_locked_by ON outbound.calls USING btree (locked_by);


--
-- Name: idx_calls_pipedrive_person; Type: INDEX; Schema: outbound; Owner: postgres
--

CREATE INDEX idx_calls_pipedrive_person ON outbound.calls USING btree (pipedrive_person_id);


--
-- Name: idx_calls_status; Type: INDEX; Schema: outbound; Owner: postgres
--

CREATE INDEX idx_calls_status ON outbound.calls USING btree (call_status);


--
-- Name: idx_calls_timezone; Type: INDEX; Schema: outbound; Owner: postgres
--

CREATE INDEX idx_calls_timezone ON outbound.calls USING btree (timezone_offset);


--
-- Name: idx_users_email; Type: INDEX; Schema: outbound; Owner: postgres
--

CREATE INDEX idx_users_email ON outbound.users USING btree (email);


--
-- Name: idx_users_google_id; Type: INDEX; Schema: outbound; Owner: postgres
--

CREATE INDEX idx_users_google_id ON outbound.users USING btree (google_id);


--
-- Name: brand generate_brand_slug_trigger; Type: TRIGGER; Schema: dirac; Owner: postgres
--

CREATE TRIGGER generate_brand_slug_trigger BEFORE INSERT OR UPDATE ON dirac.brand FOR EACH ROW EXECUTE FUNCTION dirac.generate_slug();


--
-- Name: product generate_product_slug_trigger; Type: TRIGGER; Schema: dirac; Owner: postgres
--

CREATE TRIGGER generate_product_slug_trigger BEFORE INSERT OR UPDATE ON dirac.product FOR EACH ROW EXECUTE FUNCTION dirac.generate_slug();


--
-- Name: order_item order_item_currency_check; Type: TRIGGER; Schema: dirac; Owner: postgres
--

CREATE TRIGGER order_item_currency_check BEFORE INSERT OR UPDATE OF currency ON dirac.order_item FOR EACH ROW EXECUTE FUNCTION dirac.check_order_item_currency();


--
-- Name: order_item order_item_update_total; Type: TRIGGER; Schema: dirac; Owner: postgres
--

CREATE TRIGGER order_item_update_total AFTER INSERT OR DELETE OR UPDATE ON dirac.order_item FOR EACH ROW EXECUTE FUNCTION dirac.trigger_update_order_total();


--
-- Name: image trigger_regenerate_image_uuid; Type: TRIGGER; Schema: dirac; Owner: postgres
--

CREATE TRIGGER trigger_regenerate_image_uuid BEFORE UPDATE ON dirac.image FOR EACH ROW EXECUTE FUNCTION dirac.regenerate_image_uuid();


--
-- Name: order update_order_updated_at; Type: TRIGGER; Schema: dirac; Owner: postgres
--

CREATE TRIGGER update_order_updated_at BEFORE UPDATE ON dirac."order" FOR EACH ROW EXECUTE FUNCTION dirac.update_updated_at_column();


--
-- Name: product_offer update_product_offer_updated_at; Type: TRIGGER; Schema: dirac; Owner: postgres
--

CREATE TRIGGER update_product_offer_updated_at BEFORE UPDATE ON dirac.product_offer FOR EACH ROW EXECUTE FUNCTION dirac.update_updated_at_column();


--
-- Name: admin_session admin_session_admin_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth.admin_session
    ADD CONSTRAINT admin_session_admin_user_id_fkey FOREIGN KEY (admin_user_id) REFERENCES auth.admin_user(id) ON DELETE CASCADE;


--
-- Name: user user_customer_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth."user"
    ADD CONSTRAINT user_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES dirac.customer(id);


--
-- Name: web_session web_session_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: postgres
--

ALTER TABLE ONLY auth.web_session
    ADD CONSTRAINT web_session_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth."user"(id) ON DELETE CASCADE;


--
-- Name: brand brand_owner_manufacturer_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.brand
    ADD CONSTRAINT brand_owner_manufacturer_id_fkey FOREIGN KEY (owner_supplier_id) REFERENCES dirac.supplier(id);


--
-- Name: country country_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.country
    ADD CONSTRAINT country_currency_fkey FOREIGN KEY (currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: customer customer_billing_location_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer
    ADD CONSTRAINT customer_billing_location_id_fkey FOREIGN KEY (billing_location_id) REFERENCES dirac.location(id);


--
-- Name: customer customer_shipping_location_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer
    ADD CONSTRAINT customer_shipping_location_id_fkey FOREIGN KEY (shipping_location_id) REFERENCES dirac.location(id);


--
-- Name: customer_store customer_store_customer_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer_store
    ADD CONSTRAINT customer_store_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES dirac.customer(id);


--
-- Name: customer_store customer_store_location_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customer_store
    ADD CONSTRAINT customer_store_location_id_fkey FOREIGN KEY (location_id) REFERENCES dirac.location(id);


--
-- Name: customs_territory_member customs_territory_member_country_code_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customs_territory_member
    ADD CONSTRAINT customs_territory_member_country_code_fkey FOREIGN KEY (country_code) REFERENCES dirac.country(iso_3166_2);


--
-- Name: customs_territory_member customs_territory_member_customs_territory_code_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.customs_territory_member
    ADD CONSTRAINT customs_territory_member_customs_territory_code_fkey FOREIGN KEY (customs_territory_code) REFERENCES dirac.customs_territory(code);


--
-- Name: demand_request demand_request_brand_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT demand_request_brand_id_fkey FOREIGN KEY (brand_id) REFERENCES dirac.brand(id);


--
-- Name: demand_request demand_request_country_of_origin_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT demand_request_country_of_origin_fkey FOREIGN KEY (country_of_origin) REFERENCES dirac.country(iso_3166_2);


--
-- Name: demand_request demand_request_created_by_admin_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT demand_request_created_by_admin_id_fkey FOREIGN KEY (owner_admin_id) REFERENCES auth.admin_user(id);


--
-- Name: demand_request demand_request_customer_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT demand_request_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES dirac.customer(id);


--
-- Name: demand_request demand_request_product_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT demand_request_product_id_fkey FOREIGN KEY (product_id) REFERENCES dirac.product(id);


--
-- Name: demand_request_submission demand_request_submission_created_customer_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request_submission
    ADD CONSTRAINT demand_request_submission_created_customer_id_fkey FOREIGN KEY (created_customer_id) REFERENCES dirac.customer(id);


--
-- Name: demand_request_submission demand_request_submission_created_demand_request_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request_submission
    ADD CONSTRAINT demand_request_submission_created_demand_request_id_fkey FOREIGN KEY (created_demand_request_id) REFERENCES dirac.demand_request(id);


--
-- Name: demand_request_submission demand_request_submission_processed_by_admin_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request_submission
    ADD CONSTRAINT demand_request_submission_processed_by_admin_id_fkey FOREIGN KEY (processed_by_admin_id) REFERENCES auth.admin_user(id);


--
-- Name: demand_request demand_request_target_unit_price_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.demand_request
    ADD CONSTRAINT demand_request_target_unit_price_currency_fkey FOREIGN KEY (target_unit_price_currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: order_item fk_order_item_vat_rate; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.order_item
    ADD CONSTRAINT fk_order_item_vat_rate FOREIGN KEY (uk_vat_fraction) REFERENCES dirac.vat_rate(fraction);


--
-- Name: product fk_product_vat_rate; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT fk_product_vat_rate FOREIGN KEY (uk_vat_fraction) REFERENCES dirac.vat_rate(fraction);


--
-- Name: location location_country_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.location
    ADD CONSTRAINT location_country_fkey FOREIGN KEY (country) REFERENCES dirac.country(iso_3166_2);


--
-- Name: supplier manufacturer_default_moq_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier
    ADD CONSTRAINT manufacturer_default_moq_currency_fkey FOREIGN KEY (default_moq_currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: supplier manufacturer_discount_function_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier
    ADD CONSTRAINT manufacturer_discount_function_id_fkey FOREIGN KEY (discount_function_id) REFERENCES dirac.discount_function(id);


--
-- Name: supplier_store manufacturer_store_location_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier_store
    ADD CONSTRAINT manufacturer_store_location_id_fkey FOREIGN KEY (location_id) REFERENCES dirac.location(id);


--
-- Name: supplier_store manufacturer_store_manufacturer_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.supplier_store
    ADD CONSTRAINT manufacturer_store_manufacturer_id_fkey FOREIGN KEY (supplier_id) REFERENCES dirac.supplier(id);


--
-- Name: order order_billing_address_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_billing_address_id_fkey FOREIGN KEY (billing_address_id) REFERENCES dirac.location(id);


--
-- Name: order order_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_currency_fkey FOREIGN KEY (currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: order_item order_item_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.order_item
    ADD CONSTRAINT order_item_currency_fkey FOREIGN KEY (currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: order_item order_item_order_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.order_item
    ADD CONSTRAINT order_item_order_id_fkey FOREIGN KEY (order_id) REFERENCES dirac."order"(id) ON DELETE CASCADE;


--
-- Name: order_item order_item_product_case_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.order_item
    ADD CONSTRAINT order_item_product_case_id_fkey FOREIGN KEY (product_case_id) REFERENCES dirac.product_case(id);


--
-- Name: order order_payment_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_payment_id_fkey FOREIGN KEY (payment_id) REFERENCES dirac.payment(id);


--
-- Name: order order_shipping_address_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_shipping_address_id_fkey FOREIGN KEY (shipping_address_id) REFERENCES dirac.location(id);


--
-- Name: order order_shipping_cost_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_shipping_cost_currency_fkey FOREIGN KEY (shipping_cost_currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: order order_user_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac."order"
    ADD CONSTRAINT order_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth."user"(id);


--
-- Name: payment payment_order_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.payment
    ADD CONSTRAINT payment_order_id_fkey FOREIGN KEY (order_id) REFERENCES dirac."order"(id) ON DELETE CASCADE;


--
-- Name: pricing_job pricing_job_admin_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.pricing_job
    ADD CONSTRAINT pricing_job_admin_id_fkey FOREIGN KEY (admin_id) REFERENCES auth."user"(id);


--
-- Name: product product_barcode_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_barcode_fkey FOREIGN KEY (barcode) REFERENCES dirac.barcode(gtin_14);


--
-- Name: product product_brand_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_brand_id_fkey FOREIGN KEY (brand_id) REFERENCES dirac.brand(id);


--
-- Name: product_case product_case_case_barcode_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_case
    ADD CONSTRAINT product_case_case_barcode_fkey FOREIGN KEY (case_barcode) REFERENCES dirac.barcode(gtin_14);


--
-- Name: product_case product_case_product_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_case
    ADD CONSTRAINT product_case_product_id_fkey FOREIGN KEY (product_id) REFERENCES dirac.product(id);


--
-- Name: product_detail product_detail_product_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_detail
    ADD CONSTRAINT product_detail_product_id_fkey FOREIGN KEY (product_id) REFERENCES dirac.product(id);


--
-- Name: product product_image_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_image_id_fkey FOREIGN KEY (image_id) REFERENCES dirac.image(id);


--
-- Name: product_offer product_offer_brand_level_discount_function_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_brand_level_discount_function_id_fkey FOREIGN KEY (brand_level_discount_function_id) REFERENCES dirac.discount_function(id);


--
-- Name: product_offer product_offer_case_price_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_case_price_currency_fkey FOREIGN KEY (case_price_currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: product_offer product_offer_country_of_origin_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_country_of_origin_fkey FOREIGN KEY (country_of_origin) REFERENCES dirac.country(iso_3166_2);


--
-- Name: product_offer product_offer_manufacturer_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_manufacturer_id_fkey FOREIGN KEY (supplier_id) REFERENCES dirac.supplier(id);


--
-- Name: product_offer product_offer_product_case_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_product_case_id_fkey FOREIGN KEY (product_case_id) REFERENCES dirac.product_case(id);


--
-- Name: product_offer product_offer_product_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_product_id_fkey FOREIGN KEY (product_id) REFERENCES dirac.product(id);


--
-- Name: product_offer product_offer_product_level_discount_function_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_offer
    ADD CONSTRAINT product_offer_product_level_discount_function_id_fkey FOREIGN KEY (product_level_discount_function_id) REFERENCES dirac.discount_function(id);


--
-- Name: product_tariff_classification product_tariff_classification_product_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_tariff_classification
    ADD CONSTRAINT product_tariff_classification_product_id_fkey FOREIGN KEY (product_id) REFERENCES dirac.product(id);


--
-- Name: product_tariff_classification product_tariff_classification_tariff_code_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product_tariff_classification
    ADD CONSTRAINT product_tariff_classification_tariff_code_id_fkey FOREIGN KEY (tariff_code_id) REFERENCES dirac.tariff_code(id);


--
-- Name: product product_web_discount_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_web_discount_fkey FOREIGN KEY (web_discount) REFERENCES dirac.discount_function(id);


--
-- Name: product product_web_product_case_id_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_web_product_case_id_fkey FOREIGN KEY (web_product_case_id) REFERENCES dirac.product_case(id);


--
-- Name: product product_web_unit_price_currency_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.product
    ADD CONSTRAINT product_web_unit_price_currency_fkey FOREIGN KEY (web_unit_price_currency) REFERENCES dirac.currency(iso_4217);


--
-- Name: tariff_code tariff_code_country_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.tariff_code
    ADD CONSTRAINT tariff_code_country_fkey FOREIGN KEY (country) REFERENCES dirac.country(iso_3166_2);


--
-- Name: tariff_code tariff_code_customs_territory_code_fkey; Type: FK CONSTRAINT; Schema: dirac; Owner: postgres
--

ALTER TABLE ONLY dirac.tariff_code
    ADD CONSTRAINT tariff_code_customs_territory_code_fkey FOREIGN KEY (customs_territory_code) REFERENCES dirac.customs_territory(code);


--
-- Name: organization_persona_search organization_persona_search_organization_id_fkey; Type: FK CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.organization_persona_search
    ADD CONSTRAINT organization_persona_search_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES enrichment.organization(id) ON DELETE CASCADE;


--
-- Name: organization_persona_search organization_persona_search_persona_id_fkey; Type: FK CONSTRAINT; Schema: enrichment; Owner: postgres
--

ALTER TABLE ONLY enrichment.organization_persona_search
    ADD CONSTRAINT organization_persona_search_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES enrichment.persona(id) ON DELETE CASCADE;


--
-- Name: post post_company_id_fkey; Type: FK CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.post
    ADD CONSTRAINT post_company_id_fkey FOREIGN KEY (company_id) REFERENCES linkedin.company(id);


--
-- Name: post post_person_id_fkey; Type: FK CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.post
    ADD CONSTRAINT post_person_id_fkey FOREIGN KEY (person_id) REFERENCES linkedin.person(id);


--
-- Name: post post_search_result_id_fkey; Type: FK CONSTRAINT; Schema: linkedin; Owner: postgres
--

ALTER TABLE ONLY linkedin.post
    ADD CONSTRAINT post_search_result_id_fkey FOREIGN KEY (search_result_id) REFERENCES linkedin.search_result(id);


--
-- Name: SCHEMA admin; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA admin TO admin;


--
-- Name: SCHEMA api; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA api TO api;
GRANT USAGE ON SCHEMA api TO admin;


--
-- Name: SCHEMA dirac; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA dirac TO api;
GRANT USAGE ON SCHEMA dirac TO admin;
GRANT USAGE ON SCHEMA dirac TO linkedin;


--
-- Name: SCHEMA linkedin; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA linkedin TO linkedin;
GRANT USAGE ON SCHEMA linkedin TO admin;


--
-- Name: SCHEMA outbound; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA outbound TO outbound_user;


--
-- Name: FUNCTION add_customer_store(p_customer_id bigint, p_location_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.add_customer_store(p_customer_id bigint, p_location_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.add_customer_store(p_customer_id bigint, p_location_id bigint) TO admin;


--
-- Name: FUNCTION add_demand_request(p_admin_id bigint, p_quantity dirac.product_quantity, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_notes text, p_source character varying, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.add_demand_request(p_admin_id bigint, p_quantity dirac.product_quantity, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_notes text, p_source character varying, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.add_demand_request(p_admin_id bigint, p_quantity dirac.product_quantity, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_notes text, p_source character varying, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character) TO admin;


--
-- Name: FUNCTION add_image(p_blob bytea, p_width_px integer, p_height_px integer, p_image_type dirac.image_type); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.add_image(p_blob bytea, p_width_px integer, p_height_px integer, p_image_type dirac.image_type) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.add_image(p_blob bytea, p_width_px integer, p_height_px integer, p_image_type dirac.image_type) TO admin;


--
-- Name: FUNCTION add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying) TO admin;


--
-- Name: FUNCTION add_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.add_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.add_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) TO admin;


--
-- Name: FUNCTION add_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.add_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.add_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) TO admin;


--
-- Name: FUNCTION bulk_upsert_products_json(products_json jsonb); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.bulk_upsert_products_json(products_json jsonb) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.bulk_upsert_products_json(products_json jsonb) TO admin;


--
-- Name: FUNCTION confirm_submission(p_admin_id bigint, p_submission_id bigint, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.confirm_submission(p_admin_id bigint, p_submission_id bigint, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.confirm_submission(p_admin_id bigint, p_submission_id bigint, p_customer_id bigint, p_customer_name character varying, p_customer_embedding public.vector, p_customer_pipedrive_deal_id integer, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_product_id bigint, p_product_name character varying, p_product_embedding public.vector, p_product_barcode character varying, p_brand_id bigint, p_brand_name character varying, p_brand_embedding public.vector, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character) TO admin;


--
-- Name: FUNCTION count_incomplete_margins(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.count_incomplete_margins() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.count_incomplete_margins() TO admin;


--
-- Name: FUNCTION delete_margin_estimate(p_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.delete_margin_estimate(p_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.delete_margin_estimate(p_id bigint) TO admin;


--
-- Name: FUNCTION delete_product_case(p_case_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.delete_product_case(p_case_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.delete_product_case(p_case_id bigint) TO admin;


--
-- Name: FUNCTION find_or_create_discount_function(p_discount_tiers dirac.discount_range[]); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.find_or_create_discount_function(p_discount_tiers dirac.discount_range[]) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.find_or_create_discount_function(p_discount_tiers dirac.discount_range[]) TO admin;


--
-- Name: FUNCTION find_similar_products_batch(product_names text[], product_embeddings public.vector[]); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.find_similar_products_batch(product_names text[], product_embeddings public.vector[]) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.find_similar_products_batch(product_names text[], product_embeddings public.vector[]) TO admin;


--
-- Name: FUNCTION get_active_admins(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_active_admins() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_active_admins() TO admin;


--
-- Name: FUNCTION get_admin_from_session(_session_id uuid); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_admin_from_session(_session_id uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_admin_from_session(_session_id uuid) TO admin;


--
-- Name: FUNCTION get_customer_by_email(p_email character varying); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_customer_by_email(p_email character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_customer_by_email(p_email character varying) TO admin;


--
-- Name: FUNCTION get_customer_by_id(p_customer_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_customer_by_id(p_customer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_customer_by_id(p_customer_id bigint) TO admin;


--
-- Name: FUNCTION get_customer_stores(p_customer_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_customer_stores(p_customer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_customer_stores(p_customer_id bigint) TO admin;


--
-- Name: FUNCTION get_customers_with_demand_stats(p_limit integer, p_offset integer, p_search text); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_customers_with_demand_stats(p_limit integer, p_offset integer, p_search text) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_customers_with_demand_stats(p_limit integer, p_offset integer, p_search text) TO admin;


--
-- Name: FUNCTION get_demand_request_by_id(p_request_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_demand_request_by_id(p_request_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_demand_request_by_id(p_request_id bigint) TO admin;


--
-- Name: FUNCTION get_demand_requests(p_limit integer, p_offset integer, p_customer_id bigint, p_search text); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_demand_requests(p_limit integer, p_offset integer, p_customer_id bigint, p_search text) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_demand_requests(p_limit integer, p_offset integer, p_customer_id bigint, p_search text) TO admin;


--
-- Name: FUNCTION get_demand_stats(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_demand_stats() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_demand_stats() TO admin;


--
-- Name: FUNCTION get_discount_function(p_discount_function_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_discount_function(p_discount_function_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_discount_function(p_discount_function_id bigint) TO admin;


--
-- Name: FUNCTION get_locations(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_locations() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_locations() TO admin;


--
-- Name: FUNCTION get_manufacturer_by_id(p_manufacturer_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_manufacturer_by_id(p_manufacturer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_manufacturer_by_id(p_manufacturer_id bigint) TO admin;


--
-- Name: FUNCTION get_manufacturer_stores(p_manufacturer_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_manufacturer_stores(p_manufacturer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_manufacturer_stores(p_manufacturer_id bigint) TO admin;


--
-- Name: FUNCTION get_manufacturers(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_manufacturers() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_manufacturers() TO admin;


--
-- Name: FUNCTION get_manufacturers_with_stats(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_manufacturers_with_stats() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_manufacturers_with_stats() TO admin;


--
-- Name: FUNCTION get_margin_estimates(p_company_names character varying[], p_company_domains character varying[]); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_margin_estimates(p_company_names character varying[], p_company_domains character varying[]) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_margin_estimates(p_company_names character varying[], p_company_domains character varying[]) TO admin;


--
-- Name: FUNCTION get_order_admin_details(p_order_uuid uuid); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_order_admin_details(p_order_uuid uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_order_admin_details(p_order_uuid uuid) TO admin;


--
-- Name: FUNCTION get_order_items(p_order_uuid uuid); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_order_items(p_order_uuid uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_order_items(p_order_uuid uuid) TO admin;
GRANT ALL ON FUNCTION admin.get_order_items(p_order_uuid uuid) TO api;


--
-- Name: FUNCTION get_order_items_admin(p_order_uuid uuid); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_order_items_admin(p_order_uuid uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_order_items_admin(p_order_uuid uuid) TO admin;


--
-- Name: FUNCTION get_order_stats(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_order_stats() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_order_stats() TO admin;


--
-- Name: FUNCTION get_pending_submissions(p_limit integer, p_offset integer, p_status character varying); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_pending_submissions(p_limit integer, p_offset integer, p_status character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_pending_submissions(p_limit integer, p_offset integer, p_status character varying) TO admin;


--
-- Name: FUNCTION get_pending_submissions_count(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_pending_submissions_count() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_pending_submissions_count() TO admin;


--
-- Name: FUNCTION get_pricing_constants(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_pricing_constants() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_pricing_constants() TO admin;


--
-- Name: FUNCTION get_pricing_job(p_job_id character varying); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_pricing_job(p_job_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_pricing_job(p_job_id character varying) TO admin;


--
-- Name: FUNCTION get_product_basic_info(p_product_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_basic_info(p_product_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_basic_info(p_product_id bigint) TO admin;


--
-- Name: FUNCTION get_product_cases(p_product_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_cases(p_product_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_cases(p_product_id bigint) TO admin;


--
-- Name: FUNCTION get_product_detail(product_slug character varying); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_detail(product_slug character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_detail(product_slug character varying) TO admin;


--
-- Name: FUNCTION get_product_id_by_slug(p_slug character varying); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_id_by_slug(p_slug character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_id_by_slug(p_slug character varying) TO admin;


--
-- Name: FUNCTION get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector) TO admin;


--
-- Name: FUNCTION get_product_offer(p_offer_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_offer(p_offer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_offer(p_offer_id bigint) TO admin;


--
-- Name: FUNCTION get_product_offers_by_manufacturer(p_manufacturer_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_offers_by_manufacturer(p_manufacturer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_offers_by_manufacturer(p_manufacturer_id bigint) TO admin;


--
-- Name: FUNCTION get_product_offers_by_product(p_product_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_offers_by_product(p_product_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_offers_by_product(p_product_id bigint) TO admin;


--
-- Name: FUNCTION get_product_offers_by_supplier(p_supplier_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_offers_by_supplier(p_supplier_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_offers_by_supplier(p_supplier_id bigint) TO admin;


--
-- Name: FUNCTION get_product_offers_for_demand_request(p_demand_request_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_offers_for_demand_request(p_demand_request_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_offers_for_demand_request(p_demand_request_id bigint) TO admin;


--
-- Name: FUNCTION get_product_slug_by_id(p_product_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_slug_by_id(p_product_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_slug_by_id(p_product_id bigint) TO admin;


--
-- Name: FUNCTION get_product_tariff_codes(product_id bigint, country_filter character, customs_territory_filter character varying, depth_filter integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_product_tariff_codes(product_id bigint, country_filter character, customs_territory_filter character varying, depth_filter integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_product_tariff_codes(product_id bigint, country_filter character, customs_territory_filter character varying, depth_filter integer) TO admin;


--
-- Name: FUNCTION get_products_with_discounts(p_search text, p_limit integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_products_with_discounts(p_search text, p_limit integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_products_with_discounts(p_search text, p_limit integer) TO admin;


--
-- Name: FUNCTION get_supplier_by_id(p_supplier_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_supplier_by_id(p_supplier_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_supplier_by_id(p_supplier_id bigint) TO admin;


--
-- Name: FUNCTION get_supplier_stores(p_supplier_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_supplier_stores(p_supplier_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_supplier_stores(p_supplier_id bigint) TO admin;


--
-- Name: FUNCTION get_suppliers(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_suppliers() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_suppliers() TO admin;


--
-- Name: FUNCTION get_suppliers_with_stats(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.get_suppliers_with_stats() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.get_suppliers_with_stats() TO admin;


--
-- Name: FUNCTION is_session_valid(_session_id uuid, _ip inet, _user_agent text); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.is_session_valid(_session_id uuid, _ip inet, _user_agent text) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.is_session_valid(_session_id uuid, _ip inet, _user_agent text) TO admin;


--
-- Name: FUNCTION list_all_orders(p_status dirac.order_status, p_customer_search text, p_date_from timestamp with time zone, p_date_to timestamp with time zone, p_limit integer, p_offset integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.list_all_orders(p_status dirac.order_status, p_customer_search text, p_date_from timestamp with time zone, p_date_to timestamp with time zone, p_limit integer, p_offset integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.list_all_orders(p_status dirac.order_status, p_customer_search text, p_date_from timestamp with time zone, p_date_to timestamp with time zone, p_limit integer, p_offset integer) TO admin;


--
-- Name: FUNCTION list_margin_estimates(p_limit integer, p_offset integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.list_margin_estimates(p_limit integer, p_offset integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.list_margin_estimates(p_limit integer, p_offset integer) TO admin;


--
-- Name: FUNCTION list_pricing_jobs(p_admin_id bigint, p_status dirac.pricing_job_status, p_limit integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.list_pricing_jobs(p_admin_id bigint, p_status dirac.pricing_job_status, p_limit integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.list_pricing_jobs(p_admin_id bigint, p_status dirac.pricing_job_status, p_limit integer) TO admin;


--
-- Name: FUNCTION login(_email text, _google_id character varying, _ip inet, _user_agent text); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.login(_email text, _google_id character varying, _ip inet, _user_agent text) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.login(_email text, _google_id character varying, _ip inet, _user_agent text) TO admin;


--
-- Name: FUNCTION reject_submission(p_admin_id bigint, p_submission_id bigint, p_rejection_reason text); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.reject_submission(p_admin_id bigint, p_submission_id bigint, p_rejection_reason text) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.reject_submission(p_admin_id bigint, p_submission_id bigint, p_rejection_reason text) TO admin;


--
-- Name: FUNCTION remove_customer_store(p_customer_id bigint, p_location_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.remove_customer_store(p_customer_id bigint, p_location_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.remove_customer_store(p_customer_id bigint, p_location_id bigint) TO admin;


--
-- Name: FUNCTION remove_demand_request(p_admin_id bigint, p_request_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.remove_demand_request(p_admin_id bigint, p_request_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.remove_demand_request(p_admin_id bigint, p_request_id bigint) TO admin;


--
-- Name: FUNCTION remove_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.remove_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.remove_manufacturer_store(p_manufacturer_id bigint, p_location_id bigint) TO admin;


--
-- Name: FUNCTION remove_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.remove_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.remove_product_tariff_code(p_product_id bigint, p_tariff_code_id bigint) TO admin;


--
-- Name: FUNCTION search_brands(p_embedding public.vector, p_limit integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.search_brands(p_embedding public.vector, p_limit integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.search_brands(p_embedding public.vector, p_limit integer) TO admin;


--
-- Name: FUNCTION search_customers(p_embedding public.vector, p_limit integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.search_customers(p_embedding public.vector, p_limit integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.search_customers(p_embedding public.vector, p_limit integer) TO admin;


--
-- Name: FUNCTION search_manufacturers(p_embedding public.vector, p_limit integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.search_manufacturers(p_embedding public.vector, p_limit integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.search_manufacturers(p_embedding public.vector, p_limit integer) TO admin;


--
-- Name: FUNCTION search_products(p_embedding public.vector, p_limit integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.search_products(p_embedding public.vector, p_limit integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.search_products(p_embedding public.vector, p_limit integer) TO admin;


--
-- Name: FUNCTION set_brand_owner(p_brand_id bigint, p_manufacturer_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.set_brand_owner(p_brand_id bigint, p_manufacturer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.set_brand_owner(p_brand_id bigint, p_manufacturer_id bigint) TO admin;


--
-- Name: FUNCTION test_search_customers(); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.test_search_customers() FROM PUBLIC;
GRANT ALL ON FUNCTION admin.test_search_customers() TO admin;


--
-- Name: FUNCTION update_customer(p_customer_id bigint, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_customer(p_customer_id bigint, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_customer(p_customer_id bigint, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer) TO admin;


--
-- Name: FUNCTION update_customer(p_customer_id bigint, p_name character varying, p_embedding public.vector, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_customer(p_customer_id bigint, p_name character varying, p_embedding public.vector, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_customer(p_customer_id bigint, p_name character varying, p_embedding public.vector, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_pipedrive_deal_id integer) TO admin;


--
-- Name: FUNCTION update_demand_request(p_admin_id bigint, p_request_id bigint, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_demand_request(p_admin_id bigint, p_request_id bigint, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_demand_request(p_admin_id bigint, p_request_id bigint, p_quantity dirac.product_quantity, p_notes text, p_target_unit_price numeric, p_target_unit_price_currency character, p_eu_goods_tier dirac.eu_goods_tier, p_country_of_origin character) TO admin;


--
-- Name: FUNCTION update_manufacturer(p_manufacturer_id bigint, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer) TO admin;


--
-- Name: FUNCTION update_manufacturer(p_manufacturer_id bigint, p_name character varying, p_embedding public.vector, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_name character varying, p_embedding public.vector, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_manufacturer(p_manufacturer_id bigint, p_name character varying, p_embedding public.vector, p_default_moq numeric, p_default_moq_currency character, p_credit_terms_days integer) TO admin;


--
-- Name: FUNCTION update_order_status(p_order_uuid uuid, p_new_status dirac.order_status, p_notes text); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_order_status(p_order_uuid uuid, p_new_status dirac.order_status, p_notes text) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_order_status(p_order_uuid uuid, p_new_status dirac.order_status, p_notes text) TO admin;


--
-- Name: FUNCTION update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_margin_below_competitors_is_percentage boolean); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_margin_below_competitors_is_percentage boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_margin_below_competitors_is_percentage boolean) TO admin;


--
-- Name: FUNCTION update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_competitive_price_metric character varying, p_competitive_price_percentile character varying); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_competitive_price_metric character varying, p_competitive_price_percentile character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_pricing_constants(p_min_margin numeric, p_margin_below_competitors numeric, p_competitive_price_metric character varying, p_competitive_price_percentile character varying) TO admin;


--
-- Name: FUNCTION update_product_image(p_product_id bigint, p_image_id bigint); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_product_image(p_product_id bigint, p_image_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_product_image(p_product_id bigint, p_image_id bigint) TO admin;


--
-- Name: FUNCTION update_product_web_pricing(p_product_id bigint, p_web_unit_price numeric, p_web_unit_price_currency character, p_web_discount bigint, p_web_discount_unit character varying, p_web_product_case_id bigint, p_show_on_web boolean); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.update_product_web_pricing(p_product_id bigint, p_web_unit_price numeric, p_web_unit_price_currency character, p_web_discount bigint, p_web_discount_unit character varying, p_web_product_case_id bigint, p_show_on_web boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.update_product_web_pricing(p_product_id bigint, p_web_unit_price numeric, p_web_unit_price_currency character, p_web_discount bigint, p_web_discount_unit character varying, p_web_product_case_id bigint, p_show_on_web boolean) TO admin;


--
-- Name: FUNCTION upsert_margin_estimate(p_company_name character varying, p_company_domain character varying, p_p20 numeric, p_p50 numeric, p_p80 numeric, p_ignore boolean); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.upsert_margin_estimate(p_company_name character varying, p_company_domain character varying, p_p20 numeric, p_p50 numeric, p_p80 numeric, p_ignore boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.upsert_margin_estimate(p_company_name character varying, p_company_domain character varying, p_p20 numeric, p_p50 numeric, p_p80 numeric, p_ignore boolean) TO admin;


--
-- Name: FUNCTION upsert_product_case(p_case_id bigint, p_product_id bigint, p_case_barcode character varying, p_units_per_case integer, p_cases_per_layer integer, p_layers_per_pallet integer, p_weight_kg numeric, p_height_cm numeric, p_width_cm numeric, p_length_cm numeric); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.upsert_product_case(p_case_id bigint, p_product_id bigint, p_case_barcode character varying, p_units_per_case integer, p_cases_per_layer integer, p_layers_per_pallet integer, p_weight_kg numeric, p_height_cm numeric, p_width_cm numeric, p_length_cm numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.upsert_product_case(p_case_id bigint, p_product_id bigint, p_case_barcode character varying, p_units_per_case integer, p_cases_per_layer integer, p_layers_per_pallet integer, p_weight_kg numeric, p_height_cm numeric, p_width_cm numeric, p_length_cm numeric) TO admin;


--
-- Name: FUNCTION upsert_product_offer(p_supplier_id bigint, p_product_id bigint, p_units_per_case integer, p_case_price_base numeric, p_case_price_currency character, p_sku character varying, p_case_barcode character, p_cases_per_layer integer, p_layers_per_pallet integer, p_moq_cases integer, p_country_of_origin character, p_eu_goods_tier dirac.eu_goods_tier, p_is_active boolean); Type: ACL; Schema: admin; Owner: postgres
--

REVOKE ALL ON FUNCTION admin.upsert_product_offer(p_supplier_id bigint, p_product_id bigint, p_units_per_case integer, p_case_price_base numeric, p_case_price_currency character, p_sku character varying, p_case_barcode character, p_cases_per_layer integer, p_layers_per_pallet integer, p_moq_cases integer, p_country_of_origin character, p_eu_goods_tier dirac.eu_goods_tier, p_is_active boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION admin.upsert_product_offer(p_supplier_id bigint, p_product_id bigint, p_units_per_case integer, p_case_price_base numeric, p_case_price_currency character, p_sku character varying, p_case_barcode character, p_cases_per_layer integer, p_layers_per_pallet integer, p_moq_cases integer, p_country_of_origin character, p_eu_goods_tier dirac.eu_goods_tier, p_is_active boolean) TO admin;


--
-- Name: FUNCTION add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying) TO api;
GRANT ALL ON FUNCTION api.add_location(p_name character varying, p_country character, p_region character varying, p_address text, p_postcode character varying, p_google_place_id character varying) TO admin;


--
-- Name: FUNCTION add_to_basket(p_user_id bigint, p_product_slug character varying, p_case_quantity numeric); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.add_to_basket(p_user_id bigint, p_product_slug character varying, p_case_quantity numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION api.add_to_basket(p_user_id bigint, p_product_slug character varying, p_case_quantity numeric) TO api;
GRANT ALL ON FUNCTION api.add_to_basket(p_user_id bigint, p_product_slug character varying, p_case_quantity numeric) TO admin;


--
-- Name: FUNCTION calculate_checkout_total(p_order_uuid uuid); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.calculate_checkout_total(p_order_uuid uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION api.calculate_checkout_total(p_order_uuid uuid) TO api;
GRANT ALL ON FUNCTION api.calculate_checkout_total(p_order_uuid uuid) TO admin;


--
-- Name: FUNCTION change_password(_session_id uuid, _new_password text, _ip inet, _user_agent text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.change_password(_session_id uuid, _new_password text, _ip inet, _user_agent text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.change_password(_session_id uuid, _new_password text, _ip inet, _user_agent text) TO api;
GRANT ALL ON FUNCTION api.change_password(_session_id uuid, _new_password text, _ip inet, _user_agent text) TO admin;


--
-- Name: FUNCTION create_account(_email text, _password text, _ip inet, _user_agent text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.create_account(_email text, _password text, _ip inet, _user_agent text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.create_account(_email text, _password text, _ip inet, _user_agent text) TO api;
GRANT ALL ON FUNCTION api.create_account(_email text, _password text, _ip inet, _user_agent text) TO admin;


--
-- Name: FUNCTION create_payment_record(p_order_uuid uuid, p_stripe_payment_intent_id character varying, p_amount numeric, p_currency character, p_status character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.create_payment_record(p_order_uuid uuid, p_stripe_payment_intent_id character varying, p_amount numeric, p_currency character, p_status character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.create_payment_record(p_order_uuid uuid, p_stripe_payment_intent_id character varying, p_amount numeric, p_currency character, p_status character varying) TO api;
GRANT ALL ON FUNCTION api.create_payment_record(p_order_uuid uuid, p_stripe_payment_intent_id character varying, p_amount numeric, p_currency character, p_status character varying) TO admin;


--
-- Name: FUNCTION generate_email_verification_token(_email text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.generate_email_verification_token(_email text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.generate_email_verification_token(_email text) TO api;
GRANT ALL ON FUNCTION api.generate_email_verification_token(_email text) TO admin;


--
-- Name: FUNCTION get_basket_items(p_user_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_basket_items(p_user_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_basket_items(p_user_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_basket_items(p_user_id bigint) TO admin;


--
-- Name: FUNCTION get_brands(); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_brands() FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_brands() TO api;
GRANT ALL ON FUNCTION api.get_brands() TO admin;


--
-- Name: FUNCTION get_countries(); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_countries() FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_countries() TO api;
GRANT ALL ON FUNCTION api.get_countries() TO admin;


--
-- Name: FUNCTION get_currencies(); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_currencies() FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_currencies() TO api;
GRANT ALL ON FUNCTION api.get_currencies() TO admin;


--
-- Name: FUNCTION get_customer_data_for_stripe(p_user_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_customer_data_for_stripe(p_user_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_customer_data_for_stripe(p_user_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_customer_data_for_stripe(p_user_id bigint) TO admin;


--
-- Name: FUNCTION get_customer_info(p_customer_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_customer_info(p_customer_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_customer_info(p_customer_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_customer_info(p_customer_id bigint) TO admin;


--
-- Name: FUNCTION get_discount_function(p_discount_function_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_discount_function(p_discount_function_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_discount_function(p_discount_function_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_discount_function(p_discount_function_id bigint) TO admin;


--
-- Name: FUNCTION get_location_by_id(p_location_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_location_by_id(p_location_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_location_by_id(p_location_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_location_by_id(p_location_id bigint) TO admin;


--
-- Name: FUNCTION get_or_create_basket(p_user_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_or_create_basket(p_user_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_or_create_basket(p_user_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_or_create_basket(p_user_id bigint) TO admin;


--
-- Name: FUNCTION get_order_details(p_user_id bigint, p_order_uuid uuid); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_order_details(p_user_id bigint, p_order_uuid uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_order_details(p_user_id bigint, p_order_uuid uuid) TO api;
GRANT ALL ON FUNCTION api.get_order_details(p_user_id bigint, p_order_uuid uuid) TO admin;


--
-- Name: FUNCTION get_order_items(p_user_id bigint, p_order_uuid uuid); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_order_items(p_user_id bigint, p_order_uuid uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_order_items(p_user_id bigint, p_order_uuid uuid) TO api;
GRANT ALL ON FUNCTION api.get_order_items(p_user_id bigint, p_order_uuid uuid) TO admin;


--
-- Name: FUNCTION get_order_uuid_by_session_id(p_session_id character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_order_uuid_by_session_id(p_session_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_order_uuid_by_session_id(p_session_id character varying) TO api;
GRANT ALL ON FUNCTION api.get_order_uuid_by_session_id(p_session_id character varying) TO admin;


--
-- Name: FUNCTION get_pallets_for_order(order_uuid uuid); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_pallets_for_order(order_uuid uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_pallets_for_order(order_uuid uuid) TO api;
GRANT ALL ON FUNCTION api.get_pallets_for_order(order_uuid uuid) TO admin;


--
-- Name: FUNCTION get_product_by_slug(product_slug character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_product_by_slug(product_slug character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_product_by_slug(product_slug character varying) TO api;
GRANT ALL ON FUNCTION api.get_product_by_slug(product_slug character varying) TO admin;


--
-- Name: FUNCTION get_product_detail(product_slug character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_product_detail(product_slug character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_product_detail(product_slug character varying) TO api;
GRANT ALL ON FUNCTION api.get_product_detail(product_slug character varying) TO admin;


--
-- Name: FUNCTION get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector) TO api;
GRANT ALL ON FUNCTION api.get_product_listing(limit_val integer, offset_val integer, brand_name_filter character varying, search_term character varying, order_by character varying, search_embedding public.vector) TO admin;


--
-- Name: FUNCTION get_stripe_customer_id(p_user_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_stripe_customer_id(p_user_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_stripe_customer_id(p_user_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_stripe_customer_id(p_user_id bigint) TO admin;


--
-- Name: FUNCTION get_tariff_codes(limit_val integer, offset_val integer, country_filter character, customs_territory_filter character varying, search_term character varying, depth_filter integer); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_tariff_codes(limit_val integer, offset_val integer, country_filter character, customs_territory_filter character varying, search_term character varying, depth_filter integer) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_tariff_codes(limit_val integer, offset_val integer, country_filter character, customs_territory_filter character varying, search_term character varying, depth_filter integer) TO api;
GRANT ALL ON FUNCTION api.get_tariff_codes(limit_val integer, offset_val integer, country_filter character, customs_territory_filter character varying, search_term character varying, depth_filter integer) TO admin;


--
-- Name: FUNCTION get_user_from_session(p_session_id uuid); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_user_from_session(p_session_id uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_user_from_session(p_session_id uuid) TO api;
GRANT ALL ON FUNCTION api.get_user_from_session(p_session_id uuid) TO admin;


--
-- Name: FUNCTION get_user_orders(p_user_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_user_orders(p_user_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_user_orders(p_user_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_user_orders(p_user_id bigint) TO admin;


--
-- Name: FUNCTION get_user_profile(p_user_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_user_profile(p_user_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_user_profile(p_user_id bigint) TO api;
GRANT ALL ON FUNCTION api.get_user_profile(p_user_id bigint) TO admin;


--
-- Name: FUNCTION get_user_verification_status(_email text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_user_verification_status(_email text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_user_verification_status(_email text) TO api;
GRANT ALL ON FUNCTION api.get_user_verification_status(_email text) TO admin;


--
-- Name: FUNCTION get_vat_rates(); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.get_vat_rates() FROM PUBLIC;
GRANT ALL ON FUNCTION api.get_vat_rates() TO api;
GRANT ALL ON FUNCTION api.get_vat_rates() TO admin;


--
-- Name: FUNCTION is_session_valid(_uuid uuid, _ip inet, _user_agent text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.is_session_valid(_uuid uuid, _ip inet, _user_agent text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.is_session_valid(_uuid uuid, _ip inet, _user_agent text) TO api;
GRANT ALL ON FUNCTION api.is_session_valid(_uuid uuid, _ip inet, _user_agent text) TO admin;


--
-- Name: FUNCTION login(_email text, _password text, _ip inet, _user_agent text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.login(_email text, _password text, _ip inet, _user_agent text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.login(_email text, _password text, _ip inet, _user_agent text) TO api;
GRANT ALL ON FUNCTION api.login(_email text, _password text, _ip inet, _user_agent text) TO admin;


--
-- Name: FUNCTION mark_order_as_paid(p_order_uuid uuid, p_session_id character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.mark_order_as_paid(p_order_uuid uuid, p_session_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.mark_order_as_paid(p_order_uuid uuid, p_session_id character varying) TO api;
GRANT ALL ON FUNCTION api.mark_order_as_paid(p_order_uuid uuid, p_session_id character varying) TO admin;


--
-- Name: FUNCTION remove_from_basket(p_user_id bigint, p_product_slug character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.remove_from_basket(p_user_id bigint, p_product_slug character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.remove_from_basket(p_user_id bigint, p_product_slug character varying) TO api;
GRANT ALL ON FUNCTION api.remove_from_basket(p_user_id bigint, p_product_slug character varying) TO admin;


--
-- Name: FUNCTION save_customer_shipping_info(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint, p_vat_number character varying, p_delivery_instructions text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.save_customer_shipping_info(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint, p_vat_number character varying, p_delivery_instructions text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.save_customer_shipping_info(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint, p_vat_number character varying, p_delivery_instructions text) TO api;
GRANT ALL ON FUNCTION api.save_customer_shipping_info(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint, p_vat_number character varying, p_delivery_instructions text) TO admin;


--
-- Name: FUNCTION search_brands(p_embedding public.vector, p_limit integer); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.search_brands(p_embedding public.vector, p_limit integer) FROM PUBLIC;
GRANT ALL ON FUNCTION api.search_brands(p_embedding public.vector, p_limit integer) TO api;
GRANT ALL ON FUNCTION api.search_brands(p_embedding public.vector, p_limit integer) TO admin;


--
-- Name: FUNCTION store_stripe_session_id(p_order_uuid uuid, p_session_id character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.store_stripe_session_id(p_order_uuid uuid, p_session_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.store_stripe_session_id(p_order_uuid uuid, p_session_id character varying) TO api;
GRANT ALL ON FUNCTION api.store_stripe_session_id(p_order_uuid uuid, p_session_id character varying) TO admin;


--
-- Name: FUNCTION submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) TO api;
GRANT ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) TO admin;


--
-- Name: FUNCTION submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) FROM PUBLIC;
GRANT ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) TO api;
GRANT ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_request_notes text) TO admin;


--
-- Name: FUNCTION submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_barcode character varying, p_request_notes text, p_target_unit_price numeric, p_target_unit_price_currency character); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_barcode character varying, p_request_notes text, p_target_unit_price numeric, p_target_unit_price_currency character) FROM PUBLIC;
GRANT ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_barcode character varying, p_request_notes text, p_target_unit_price numeric, p_target_unit_price_currency character) TO api;
GRANT ALL ON FUNCTION api.submit_demand_request(p_customer_name character varying, p_request_type character varying, p_item_name character varying, p_quantity dirac.product_quantity, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text, p_brand_name character varying, p_barcode character varying, p_request_notes text, p_target_unit_price numeric, p_target_unit_price_currency character) TO admin;


--
-- Name: FUNCTION update_basket_item_quantity(p_user_id bigint, p_product_slug character varying, p_new_case_quantity numeric); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.update_basket_item_quantity(p_user_id bigint, p_product_slug character varying, p_new_case_quantity numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION api.update_basket_item_quantity(p_user_id bigint, p_product_slug character varying, p_new_case_quantity numeric) TO api;
GRANT ALL ON FUNCTION api.update_basket_item_quantity(p_user_id bigint, p_product_slug character varying, p_new_case_quantity numeric) TO admin;


--
-- Name: FUNCTION update_customer_addresses(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.update_customer_addresses(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION api.update_customer_addresses(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint) TO api;
GRANT ALL ON FUNCTION api.update_customer_addresses(p_user_id bigint, p_shipping_location_id bigint, p_billing_location_id bigint) TO admin;


--
-- Name: FUNCTION update_customer_vat_number(p_customer_id bigint, p_vat_number character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.update_customer_vat_number(p_customer_id bigint, p_vat_number character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.update_customer_vat_number(p_customer_id bigint, p_vat_number character varying) TO api;
GRANT ALL ON FUNCTION api.update_customer_vat_number(p_customer_id bigint, p_vat_number character varying) TO admin;


--
-- Name: FUNCTION update_order_status_after_payment(p_order_uuid uuid, p_new_status dirac.order_status); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.update_order_status_after_payment(p_order_uuid uuid, p_new_status dirac.order_status) FROM PUBLIC;
GRANT ALL ON FUNCTION api.update_order_status_after_payment(p_order_uuid uuid, p_new_status dirac.order_status) TO api;
GRANT ALL ON FUNCTION api.update_order_status_after_payment(p_order_uuid uuid, p_new_status dirac.order_status) TO admin;


--
-- Name: FUNCTION update_payment_status(p_stripe_payment_intent_id character varying, p_status character varying, p_payment_method character varying, p_stripe_status character varying, p_failure_reason text, p_metadata jsonb); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.update_payment_status(p_stripe_payment_intent_id character varying, p_status character varying, p_payment_method character varying, p_stripe_status character varying, p_failure_reason text, p_metadata jsonb) FROM PUBLIC;
GRANT ALL ON FUNCTION api.update_payment_status(p_stripe_payment_intent_id character varying, p_status character varying, p_payment_method character varying, p_stripe_status character varying, p_failure_reason text, p_metadata jsonb) TO api;
GRANT ALL ON FUNCTION api.update_payment_status(p_stripe_payment_intent_id character varying, p_status character varying, p_payment_method character varying, p_stripe_status character varying, p_failure_reason text, p_metadata jsonb) TO admin;


--
-- Name: FUNCTION upsert_stripe_customer_id(p_user_id bigint, p_stripe_customer_id character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.upsert_stripe_customer_id(p_user_id bigint, p_stripe_customer_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.upsert_stripe_customer_id(p_user_id bigint, p_stripe_customer_id character varying) TO api;
GRANT ALL ON FUNCTION api.upsert_stripe_customer_id(p_user_id bigint, p_stripe_customer_id character varying) TO admin;


--
-- Name: FUNCTION upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION api.upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying) TO api;
GRANT ALL ON FUNCTION api.upsert_stripe_tax_rate_id(p_fraction numeric, p_stripe_tax_rate_id character varying) TO admin;


--
-- Name: FUNCTION verify_email_token(_token uuid); Type: ACL; Schema: api; Owner: postgres
--

REVOKE ALL ON FUNCTION api.verify_email_token(_token uuid) FROM PUBLIC;
GRANT ALL ON FUNCTION api.verify_email_token(_token uuid) TO api;
GRANT ALL ON FUNCTION api.verify_email_token(_token uuid) TO admin;


--
-- Name: FUNCTION hash_password(password text); Type: ACL; Schema: auth; Owner: postgres
--

REVOKE ALL ON FUNCTION auth.hash_password(password text) FROM PUBLIC;


--
-- Name: FUNCTION verify_password(password text, hash text); Type: ACL; Schema: auth; Owner: postgres
--

REVOKE ALL ON FUNCTION auth.verify_password(password text, hash text) FROM PUBLIC;


--
-- Name: FUNCTION add_manufacturer(manufacturer_name character varying); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.add_manufacturer(manufacturer_name character varying) FROM PUBLIC;


--
-- Name: FUNCTION add_supplier(supplier_name character varying, supplier_embedding public.vector); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.add_supplier(supplier_name character varying, supplier_embedding public.vector) FROM PUBLIC;


--
-- Name: FUNCTION bulk_upsert_products(products dirac.product_input[]); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.bulk_upsert_products(products dirac.product_input[]) FROM PUBLIC;


--
-- Name: FUNCTION calculate_line_item_totals(p_case_quantity numeric, p_case_price numeric, p_discount_applied numeric, p_uk_vat_fraction numeric); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.calculate_line_item_totals(p_case_quantity numeric, p_case_price numeric, p_discount_applied numeric, p_uk_vat_fraction numeric) FROM PUBLIC;


--
-- Name: FUNCTION calculate_order_total(p_order_id bigint); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.calculate_order_total(p_order_id bigint) FROM PUBLIC;


--
-- Name: FUNCTION calculate_shipping_cost(p_order_uuid uuid); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.calculate_shipping_cost(p_order_uuid uuid) FROM PUBLIC;


--
-- Name: FUNCTION check_order_item_currency(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.check_order_item_currency() FROM PUBLIC;


--
-- Name: FUNCTION extract_linkedin_slug(url text); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.extract_linkedin_slug(url text) FROM PUBLIC;


--
-- Name: FUNCTION generate_slug(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.generate_slug() FROM PUBLIC;


--
-- Name: FUNCTION generate_slug(input_text character varying); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.generate_slug(input_text character varying) FROM PUBLIC;


--
-- Name: FUNCTION get_price(p_discount_id bigint, p_base_price numeric, p_qty integer); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.get_price(p_discount_id bigint, p_base_price numeric, p_qty integer) FROM PUBLIC;


--
-- Name: FUNCTION is_valid_slug(text); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.is_valid_slug(text) FROM PUBLIC;


--
-- Name: FUNCTION regenerate_image_uuid(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.regenerate_image_uuid() FROM PUBLIC;


--
-- Name: FUNCTION test_add_demand_request(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_add_demand_request() FROM PUBLIC;


--
-- Name: FUNCTION test_add_manufacturer(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_add_manufacturer() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_first_login(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_first_login() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_inactive_account(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_inactive_account() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_last_login_update(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_last_login_update() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_linked_login(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_linked_login() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_login_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_login_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_multiple_sessions(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_multiple_sessions() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_nonexistent_email(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_nonexistent_email() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_session_expiry(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_session_expiry() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_session_metadata(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_session_metadata() FROM PUBLIC;


--
-- Name: FUNCTION test_admin_oauth_wrong_google_id(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_admin_oauth_wrong_google_id() FROM PUBLIC;


--
-- Name: FUNCTION test_api_role_permissions(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_api_role_permissions() FROM PUBLIC;


--
-- Name: FUNCTION test_auth_permissions(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_auth_permissions() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_barcode_normalization(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_barcode_normalization() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_basic_insert(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_basic_insert() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_brand_resolution(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_brand_resolution() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_brand_slug_conflict(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_brand_slug_conflict() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_duplicate_brand_slugs(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_duplicate_brand_slugs() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_duplicate_product_names_no_barcode(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_duplicate_product_names_no_barcode() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_error_handling(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_error_handling() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_mixed_barcode_products(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_mixed_barcode_products() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_name_conflict_without_barcode(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_name_conflict_without_barcode() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_products_without_barcode(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_products_without_barcode() FROM PUBLIC;


--
-- Name: FUNCTION test_bulk_upsert_tariff_code(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_bulk_upsert_tariff_code() FROM PUBLIC;


--
-- Name: FUNCTION test_calculate_order_total_empty(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_calculate_order_total_empty() FROM PUBLIC;


--
-- Name: FUNCTION test_calculate_order_total_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_calculate_order_total_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_calculate_order_total_mixed_discounts(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_calculate_order_total_mixed_discounts() FROM PUBLIC;


--
-- Name: FUNCTION test_calculate_order_total_multiple_items(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_calculate_order_total_multiple_items() FROM PUBLIC;


--
-- Name: FUNCTION test_calculate_order_total_precision(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_calculate_order_total_precision() FROM PUBLIC;


--
-- Name: FUNCTION test_calculate_order_total_single_item(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_calculate_order_total_single_item() FROM PUBLIC;


--
-- Name: FUNCTION test_calculate_order_total_with_discounts(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_calculate_order_total_with_discounts() FROM PUBLIC;


--
-- Name: FUNCTION test_check_email_edge_cases(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_check_email_edge_cases() FROM PUBLIC;


--
-- Name: FUNCTION test_check_email_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_check_email_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_check_email_invalid(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_check_email_invalid() FROM PUBLIC;


--
-- Name: FUNCTION test_check_email_special_valid(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_check_email_special_valid() FROM PUBLIC;


--
-- Name: FUNCTION test_check_email_undeliverable(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_check_email_undeliverable() FROM PUBLIC;


--
-- Name: FUNCTION test_check_email_valid(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_check_email_valid() FROM PUBLIC;


--
-- Name: FUNCTION test_create_account_duplicate_email(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_create_account_duplicate_email() FROM PUBLIC;


--
-- Name: FUNCTION test_create_account_edge_cases(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_create_account_edge_cases() FROM PUBLIC;


--
-- Name: FUNCTION test_create_account_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_create_account_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_create_account_invalid_email(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_create_account_invalid_email() FROM PUBLIC;


--
-- Name: FUNCTION test_create_account_session_details(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_create_account_session_details() FROM PUBLIC;


--
-- Name: FUNCTION test_create_account_success(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_create_account_success() FROM PUBLIC;


--
-- Name: FUNCTION test_create_account_transaction_safety(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_create_account_transaction_safety() FROM PUBLIC;


--
-- Name: FUNCTION test_discount_function_validation(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_discount_function_validation() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_email_verification_token_after_wait(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_email_verification_token_after_wait() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_email_verification_token_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_email_verification_token_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_email_verification_token_expiry(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_email_verification_token_expiry() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_email_verification_token_rate_limit(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_email_verification_token_rate_limit() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_email_verification_token_replaces(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_email_verification_token_replaces() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_email_verification_token_success(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_email_verification_token_success() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_email_verification_token_user_not_found(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_email_verification_token_user_not_found() FROM PUBLIC;


--
-- Name: FUNCTION test_generate_slug_trigger(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_generate_slug_trigger() FROM PUBLIC;


--
-- Name: FUNCTION test_get_discount(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_get_discount() FROM PUBLIC;


--
-- Name: FUNCTION test_get_product_detail(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_get_product_detail() FROM PUBLIC;


--
-- Name: FUNCTION test_get_product_listing(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_get_product_listing() FROM PUBLIC;


--
-- Name: FUNCTION test_hash_password_basic(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_hash_password_basic() FROM PUBLIC;


--
-- Name: FUNCTION test_hash_password_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_hash_password_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_hash_password_lengths(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_hash_password_lengths() FROM PUBLIC;


--
-- Name: FUNCTION test_hash_password_null(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_hash_password_null() FROM PUBLIC;


--
-- Name: FUNCTION test_hash_password_uniqueness(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_hash_password_uniqueness() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_deleted_user(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_deleted_user() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_edge_cases(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_edge_cases() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_expired(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_expired() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_multiple_sessions(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_multiple_sessions() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_nonexistent(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_nonexistent() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_success(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_success() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_wrong_ip(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_wrong_ip() FROM PUBLIC;


--
-- Name: FUNCTION test_is_session_valid_wrong_user_agent(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_session_valid_wrong_user_agent() FROM PUBLIC;


--
-- Name: FUNCTION test_is_valid_slug(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_is_valid_slug() FROM PUBLIC;


--
-- Name: FUNCTION test_login_edge_cases(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_edge_cases() FROM PUBLIC;


--
-- Name: FUNCTION test_login_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_login_failed_no_last_login_update(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_failed_no_last_login_update() FROM PUBLIC;


--
-- Name: FUNCTION test_login_multiple_sessions(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_multiple_sessions() FROM PUBLIC;


--
-- Name: FUNCTION test_login_nonexistent_email(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_nonexistent_email() FROM PUBLIC;


--
-- Name: FUNCTION test_login_nonexistent_no_last_login(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_nonexistent_no_last_login() FROM PUBLIC;


--
-- Name: FUNCTION test_login_success(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_success() FROM PUBLIC;


--
-- Name: FUNCTION test_login_timing_attack(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_timing_attack() FROM PUBLIC;


--
-- Name: FUNCTION test_login_updates_last_login(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_updates_last_login() FROM PUBLIC;


--
-- Name: FUNCTION test_login_wrong_password(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_login_wrong_password() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_addresses_and_notes(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_addresses_and_notes() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_email_not_verified(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_email_not_verified() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_empty_basket(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_empty_basket() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_invalid_billing_address(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_invalid_billing_address() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_invalid_shipping_address(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_invalid_shipping_address() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_no_basket(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_no_basket() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_no_customer(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_no_customer() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_no_shipping_address(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_no_shipping_address() FROM PUBLIC;


--
-- Name: FUNCTION test_place_order_success(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_place_order_success() FROM PUBLIC;


--
-- Name: FUNCTION test_schema_validation(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_schema_validation() FROM PUBLIC;


--
-- Name: FUNCTION test_to_cm(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_to_cm() FROM PUBLIC;


--
-- Name: FUNCTION test_to_gtin_14(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_to_gtin_14() FROM PUBLIC;


--
-- Name: FUNCTION test_to_kg(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_to_kg() FROM PUBLIC;


--
-- Name: FUNCTION test_to_ml(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_to_ml() FROM PUBLIC;


--
-- Name: FUNCTION test_update_order_total_basic(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_update_order_total_basic() FROM PUBLIC;


--
-- Name: FUNCTION test_update_order_total_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_update_order_total_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_update_order_total_idempotent(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_update_order_total_idempotent() FROM PUBLIC;


--
-- Name: FUNCTION test_update_order_total_null(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_update_order_total_null() FROM PUBLIC;


--
-- Name: FUNCTION test_update_order_total_overwrite(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_update_order_total_overwrite() FROM PUBLIC;


--
-- Name: FUNCTION test_update_order_total_reflects_changes(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_update_order_total_reflects_changes() FROM PUBLIC;


--
-- Name: FUNCTION test_upsert_customer(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_upsert_customer() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_already_verified(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_already_verified() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_clears_token(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_clears_token() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_expired(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_expired() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_expiry_edge(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_expiry_edge() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_multiple_users(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_multiple_users() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_not_found(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_not_found() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_email_token_success(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_email_token_success() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_password_correct(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_password_correct() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_password_edge_cases(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_password_edge_cases() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_password_exists(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_password_exists() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_password_invalid_hash(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_password_invalid_hash() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_password_null(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_password_null() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_password_timing(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_password_timing() FROM PUBLIC;


--
-- Name: FUNCTION test_verify_password_wrong(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_verify_password_wrong() FROM PUBLIC;


--
-- Name: FUNCTION test_weight_volume_types(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.test_weight_volume_types() FROM PUBLIC;


--
-- Name: FUNCTION to_cm(l dirac.length); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.to_cm(l dirac.length) FROM PUBLIC;


--
-- Name: FUNCTION to_gtin_14(barcode character varying); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.to_gtin_14(barcode character varying) FROM PUBLIC;


--
-- Name: FUNCTION to_kg(w dirac.weight); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.to_kg(w dirac.weight) FROM PUBLIC;


--
-- Name: FUNCTION to_ml(v dirac.volume); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.to_ml(v dirac.volume) FROM PUBLIC;


--
-- Name: FUNCTION trigger_update_order_total(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.trigger_update_order_total() FROM PUBLIC;


--
-- Name: FUNCTION update_order_total(p_order_id bigint); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.update_order_total(p_order_id bigint) FROM PUBLIC;


--
-- Name: FUNCTION update_updated_at_column(); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.update_updated_at_column() FROM PUBLIC;


--
-- Name: FUNCTION upsert_brand(p_name character varying, p_embedding public.vector, p_supplier_id bigint); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.upsert_brand(p_name character varying, p_embedding public.vector, p_supplier_id bigint) FROM PUBLIC;


--
-- Name: FUNCTION upsert_customer(p_name character varying, p_pipedrive_deal_id integer, p_embedding public.vector, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.upsert_customer(p_name character varying, p_pipedrive_deal_id integer, p_embedding public.vector, p_email character varying, p_business_registration_number character varying, p_website_url character varying, p_phone_number character varying, p_country_code character, p_customer_notes text) FROM PUBLIC;


--
-- Name: FUNCTION validate_discounts(discounts dirac.discount_range[]); Type: ACL; Schema: dirac; Owner: postgres
--

REVOKE ALL ON FUNCTION dirac.validate_discounts(discounts dirac.discount_range[]) FROM PUBLIC;


--
-- Name: FUNCTION get_organizations_for_persona_search(persona_name text); Type: ACL; Schema: enrichment; Owner: postgres
--

REVOKE ALL ON FUNCTION enrichment.get_organizations_for_persona_search(persona_name text) FROM PUBLIC;


--
-- Name: FUNCTION get_persona_filters(persona_name text); Type: ACL; Schema: enrichment; Owner: postgres
--

REVOKE ALL ON FUNCTION enrichment.get_persona_filters(persona_name text) FROM PUBLIC;


--
-- Name: FUNCTION get_unenriched_domains(domains text[]); Type: ACL; Schema: enrichment; Owner: postgres
--

REVOKE ALL ON FUNCTION enrichment.get_unenriched_domains(domains text[]) FROM PUBLIC;


--
-- Name: FUNCTION mark_persona_searched(org_ids bigint[], persona_name text); Type: ACL; Schema: enrichment; Owner: postgres
--

REVOKE ALL ON FUNCTION enrichment.mark_persona_searched(org_ids bigint[], persona_name text) FROM PUBLIC;


--
-- Name: FUNCTION upsert_organizations(orgs jsonb); Type: ACL; Schema: enrichment; Owner: postgres
--

REVOKE ALL ON FUNCTION enrichment.upsert_organizations(orgs jsonb) FROM PUBLIC;


--
-- Name: FUNCTION upsert_people(people jsonb); Type: ACL; Schema: enrichment; Owner: postgres
--

REVOKE ALL ON FUNCTION enrichment.upsert_people(people jsonb) FROM PUBLIC;


--
-- Name: FUNCTION parse_relative_timestamp(p_relative_time text); Type: ACL; Schema: linkedin; Owner: postgres
--

REVOKE ALL ON FUNCTION linkedin.parse_relative_timestamp(p_relative_time text) FROM PUBLIC;
GRANT ALL ON FUNCTION linkedin.parse_relative_timestamp(p_relative_time text) TO admin;
GRANT ALL ON FUNCTION linkedin.parse_relative_timestamp(p_relative_time text) TO linkedin;


--
-- Name: FUNCTION upsert_search_extraction(p_extraction_data jsonb); Type: ACL; Schema: linkedin; Owner: postgres
--

REVOKE ALL ON FUNCTION linkedin.upsert_search_extraction(p_extraction_data jsonb) FROM PUBLIC;
GRANT ALL ON FUNCTION linkedin.upsert_search_extraction(p_extraction_data jsonb) TO admin;
GRANT ALL ON FUNCTION linkedin.upsert_search_extraction(p_extraction_data jsonb) TO linkedin;


--
-- Name: FUNCTION complete_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.complete_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.complete_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer) TO outbound_user;


--
-- Name: FUNCTION get_available_calls(); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.get_available_calls() FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.get_available_calls() TO outbound_user;


--
-- Name: FUNCTION get_user_by_google_id(p_google_id character varying); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.get_user_by_google_id(p_google_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.get_user_by_google_id(p_google_id character varying) TO outbound_user;


--
-- Name: FUNCTION get_user_goto_info(p_google_id character varying); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.get_user_goto_info(p_google_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.get_user_goto_info(p_google_id character varying) TO outbound_user;


--
-- Name: FUNCTION get_user_goto_token(p_google_id character varying); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.get_user_goto_token(p_google_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.get_user_goto_token(p_google_id character varying) TO outbound_user;


--
-- Name: FUNCTION lock_call_for_initiation(p_call_id integer, p_user_id character varying); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.lock_call_for_initiation(p_call_id integer, p_user_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.lock_call_for_initiation(p_call_id integer, p_user_id character varying) TO outbound_user;


--
-- Name: FUNCTION lock_call_for_user(p_call_id integer, p_user_id character varying); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.lock_call_for_user(p_call_id integer, p_user_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.lock_call_for_user(p_call_id integer, p_user_id character varying) TO outbound_user;


--
-- Name: FUNCTION mark_call_in_progress(p_call_id integer, p_user_id character varying); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.mark_call_in_progress(p_call_id integer, p_user_id character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.mark_call_in_progress(p_call_id integer, p_user_id character varying) TO outbound_user;


--
-- Name: FUNCTION mark_missing_persons_as_gone(p_pipedrive_person_ids integer[]); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.mark_missing_persons_as_gone(p_pipedrive_person_ids integer[]) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.mark_missing_persons_as_gone(p_pipedrive_person_ids integer[]) TO outbound_user;


--
-- Name: FUNCTION opt_out_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.opt_out_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.opt_out_call(p_call_id integer, p_user_id character varying, p_notes text, p_activity_id integer) TO outbound_user;


--
-- Name: FUNCTION unlock_stale_calls(); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.unlock_stale_calls() FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.unlock_stale_calls() TO outbound_user;


--
-- Name: FUNCTION update_user_goto_line(p_google_id character varying, p_goto_line text, p_goto_line_display character varying); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.update_user_goto_line(p_google_id character varying, p_goto_line text, p_goto_line_display character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.update_user_goto_line(p_google_id character varying, p_goto_line text, p_goto_line_display character varying) TO outbound_user;


--
-- Name: FUNCTION update_user_goto_token(p_google_id character varying, p_goto_token jsonb); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.update_user_goto_token(p_google_id character varying, p_goto_token jsonb) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.update_user_goto_token(p_google_id character varying, p_goto_token jsonb) TO outbound_user;


--
-- Name: FUNCTION upsert_pipedrive_person(p_pipedrive_person_id integer, p_pipedrive_org_id integer, p_person_name character varying, p_organization_name character varying, p_phone_number character varying, p_timezone character varying, p_timezone_offset integer); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.upsert_pipedrive_person(p_pipedrive_person_id integer, p_pipedrive_org_id integer, p_person_name character varying, p_organization_name character varying, p_phone_number character varying, p_timezone character varying, p_timezone_offset integer) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.upsert_pipedrive_person(p_pipedrive_person_id integer, p_pipedrive_org_id integer, p_person_name character varying, p_organization_name character varying, p_phone_number character varying, p_timezone character varying, p_timezone_offset integer) TO outbound_user;


--
-- Name: FUNCTION upsert_user(in_google_id character varying, in_email character varying, in_name character varying, in_picture text); Type: ACL; Schema: outbound; Owner: postgres
--

REVOKE ALL ON FUNCTION outbound.upsert_user(in_google_id character varying, in_email character varying, in_name character varying, in_picture text) FROM PUBLIC;
GRANT ALL ON FUNCTION outbound.upsert_user(in_google_id character varying, in_email character varying, in_name character varying, in_picture text) TO outbound_user;


--
-- Name: FUNCTION check_email(email_address text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION public.check_email(email_address text) FROM PUBLIC;


--
-- Name: TABLE company; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.company TO linkedin;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.company TO admin;


--
-- Name: SEQUENCE company_id_seq; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT USAGE ON SEQUENCE linkedin.company_id_seq TO linkedin;
GRANT USAGE ON SEQUENCE linkedin.company_id_seq TO admin;


--
-- Name: TABLE "group"; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin."group" TO linkedin;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin."group" TO admin;


--
-- Name: TABLE person; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.person TO linkedin;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.person TO admin;


--
-- Name: SEQUENCE person_id_seq; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT USAGE ON SEQUENCE linkedin.person_id_seq TO linkedin;
GRANT USAGE ON SEQUENCE linkedin.person_id_seq TO admin;


--
-- Name: TABLE post; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.post TO linkedin;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.post TO admin;


--
-- Name: SEQUENCE post_id_seq; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT USAGE ON SEQUENCE linkedin.post_id_seq TO linkedin;
GRANT USAGE ON SEQUENCE linkedin.post_id_seq TO admin;


--
-- Name: TABLE search_result; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.search_result TO linkedin;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE linkedin.search_result TO admin;


--
-- Name: SEQUENCE search_result_id_seq; Type: ACL; Schema: linkedin; Owner: postgres
--

GRANT USAGE ON SEQUENCE linkedin.search_result_id_seq TO linkedin;
GRANT USAGE ON SEQUENCE linkedin.search_result_id_seq TO admin;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: admin; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA admin GRANT ALL ON FUNCTIONS TO admin;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: api; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA api GRANT ALL ON FUNCTIONS TO api;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA api GRANT ALL ON FUNCTIONS TO admin;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: linkedin; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA linkedin GRANT ALL ON FUNCTIONS TO admin;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA linkedin GRANT ALL ON FUNCTIONS TO linkedin;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: -; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres REVOKE ALL ON FUNCTIONS FROM PUBLIC;


--
-- PostgreSQL database dump complete
--

\unrestrict ZayBcrqv3zzCm7TallgSbvuhWeAUijNb4WVj2dfO5AlTd2IIRnvbamYD5p0b90b


